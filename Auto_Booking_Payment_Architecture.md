# Auto Booking Payment Architecture

Parker Flight Auto‑Booking Payment Architecture
Executive Summary
Parker Flight’s auto-booking payment system will be built around Stripe for secure, PCI-compliant handling of customer payments. The design ensures no raw card data ever touches Parker’s servers or Supabase database – instead, travelers’ payment details are tokenized and stored in Stripe. Each traveler (or user profile) is linked to a Stripe Customer object and one or more PaymentMethod tokens, enabling off-session charges for flights at a later date. This architecture supports long-running “auto-booking” campaigns (via the Duffel API for flight booking) by saving a user’s payment method up front and charging it weeks or months later when a flight is auto-booked. Key goals include robust security (via Stripe’s PCI compliance and Radar fraud detection), ability to handle payment method expiration or failures gracefully, and future scalability for multiple travelers, multiple currencies, and evolving compliance needs. The solution aligns with Parker’s tech stack (React/TypeScript front-end, Supabase back-end on Vercel, Supabase Auth, and Stripe) and is designed for immediate implementation by the Warp engineering team. In summary, Parker’s payment flow will collect cards through Stripe Elements (or Payment Sheet) on the front-end, secure them as Stripe PaymentMethods, and store only Stripe identifiers in the database. An Edge Function will handle creating Stripe Setup Intents for saving cards and Payment Intents for charging later. A long-running campaign will thus have an associated saved payment method that can be charged off-session when the flight is ready to book. Stripe’s Customer object will tie together a user’s various payment methods and provide a stable identifier to use in our database (e.g. storing stripe_customer_id on the user’s profile
bootstrapped.app
). This design leverages best practices: no sensitive PCI data in our system, use of Stripe for all card storage and 3D Secure (SCA) handling, robust webhook handling for asynchronous events, and a clear separation between Parker’s app data and payment data. We outline below the end-to-end payment flow (with diagram), each architecture component, the API/Function design, error handling approaches, testing plan, phased roadmap, and compliance considerations.
Payment Flow Overview (Card Capture to Auto‑Booking Charge)
Payment flow from initial card capture to off-session charge and flight booking. The payment process is divided into two phases: (1) Payment Method Setup and (2) Off-Session Charge for Auto-Booking.
Payment Method Setup (Up-Front): When a user creates an auto-booking campaign, they are prompted to enter payment details if not already on file. The React/TypeScript front-end uses Stripe.js (Elements) to collect card information in a secure iframe (ensuring the data goes directly to Stripe’s servers and never to our backend, qualifying us for PCI SAQ A compliance
stripe.com
). Parker’s backend (Supabase Edge Function) creates a Stripe Customer for the user (if one doesn’t exist) and then creates a SetupIntent for that customer, with usage="off_session". This SetupIntent’s client secret is sent to the front-end, where Stripe.js is used to confirm card setup and securely vault the card as a Stripe PaymentMethod. During this process, Stripe may prompt the user for 3D Secure authentication if required (for example, European cards needing SCA) – this happens in Stripe’s modal or redirect as part of confirmCardSetup. Once the SetupIntent succeeds, Stripe attaches the new PaymentMethod to the Customer. Parker’s backend listens for the setup_intent.succeeded webhook (or alternatively, receives the PaymentMethod ID from the front-end upon confirmation) and stores the relevant identifiers in Supabase (e.g. updating the traveler’s profile with the stripe_customer_id and the new default_payment_method_id). No actual charge is made at this stage; the card is simply saved (“tokenized”) for future use
docs.stripe.com
. The user’s profile now has a Stripe Customer reference with a default payment method ready.
Off-Session Auto-Booking Charge (Delayed): The user’s campaign runs over weeks or months, watching for a flight that meets their criteria (via Duffel API). When it’s time to book a flight automatically, the backend triggers a payment attempt using the saved payment credentials. An Edge Function (e.g. prepareAutoBookingCharge) will retrieve the campaign details (price, currency, traveler info) and the user’s Stripe Customer ID and PaymentMethod ID from Supabase. It then creates a PaymentIntent via Stripe’s API with the specific amount (flight cost, possibly plus any fees/markup) and currency, and with parameters customer=<ID>, payment_method=<ID>, off_session=true, and confirm=true
docs.stripe.com
. This instructs Stripe to immediately attempt the charge on the saved card, even though the user is not present. Stripe’s handling of SCA for off-session is engaged here: because we marked the card for future use and flagged this PaymentIntent as off-session, Stripe will either charge it if possible (possibly using an SCA exemption from the earlier setup authentication) or decline with an error if additional authentication is required
docs.stripe.com
docs.stripe.com
.
If the PaymentIntent succeeds, the charge is completed and funds are on their way to Parker’s Stripe account. The backend then proceeds to book the flight via Duffel API. (If Parker uses Duffel Payments, this step might be integrated – but assuming Parker uses Duffel Balance or its own funds, Parker would now use the collected payment to pay the airline through Duffel.) The booking confirmation from Duffel is stored in the database (flight details, ticket info, etc.), and the user is notified (email or app notification) that their flight was successfully booked and paid. The PaymentIntent success is also received via Stripe webhook (payment_intent.succeeded), which we’ll log for redundancy and auditing.
If the PaymentIntent fails (e.g. card declined, expired, or requires 3D Secure), our system will catch the error. Stripe immediately returns a failure if the card is declined or if SCA is required but cannot be fulfilled off-session (banks may decline such off-session attempts with a “authentication_required” reason
docs.stripe.com
). In these cases, no charge is made. The backend will mark the auto-booking attempt as failed for that campaign and not proceed with the Duffel booking. A few strategies then come into play: if the user has a backup payment method on file, the system can automatically retry the charge with the alternate method (after creating a new PaymentIntent for that method). Otherwise, Parker will notify the user that the payment failed – prompting them to update their card or complete an authentication. For instance, if the failure reason was SCA required, we could send the user a secure link to complete 3D Secure authentication for the charge (by re-attempting it on-session)
support.stripe.com
support.stripe.com
. Typically, the campaign would be put on hold until the payment issue is resolved. All such events (failure reasons, etc.) would be recorded via Stripe webhooks (payment_intent.payment_failed) and tied back to the user’s campaign record.
The diagram above illustrates this flow: the user’s card details flow directly to Stripe (Step 1), Stripe returns a token (PaymentMethod) which is saved in our DB (Step 2), and later the backend uses that token to initiate a charge (Step 3) which either succeeds and triggers a booking (Step 4) or fails and triggers an error handling path (Step 4 alt).
Architecture Components
Stripe Customer and PaymentMethod Usage
Stripe Customers: Each Parker Flight traveler (or user account) gets a unique Stripe Customer ID upon first saving a payment method. This Customer object in Stripe serves as the container for all of that user’s payment instruments and payment history. We do not expose Stripe Customer IDs to the client; they are stored in our database and used server-side for Stripe API calls. By linking a Supabase user to a Stripe Customer, we can charge that user in the future without asking for card details again
bootstrapped.app
. The Customer object also lets us store metadata (like a user reference or email) and is required for certain Stripe operations (e.g., to save multiple payment methods, or to create subscriptions in the future if needed). Stripe PaymentMethods: We use Stripe’s PaymentMethod API to handle credit card details. When a user enters a card, Stripe’s Elements (or PaymentSheet) converts it to a PaymentMethod token (e.g., pm_xxx) – this token represents the card info (card number, exp, CVC, billing name, etc.) and is securely stored on Stripe’s side. Our backend creates a SetupIntent with customer set to the user’s Stripe Customer ID and usage="off_session", then provides the client secret to the front-end to confirm and attach the PaymentMethod to the Customer. Marking the SetupIntent for off-session use is critical – it tells Stripe to authenticate the card for future charges (invoking 3DS/SCA upfront if needed) so that subsequent off-session charges can succeed without user intervention
docs.stripe.com
. After a successful SetupIntent, the PaymentMethod ID and the Stripe Customer ID are stored in our database (on the traveler’s profile). We never store full card numbers, only metadata like last4 digits or card brand (for display purposes) and the Stripe IDs. This approach keeps us PCI compliant while allowing future charges: to charge the card later, we create a PaymentIntent referencing the customer + payment_method rather than raw card data
docs.stripe.com
. If multiple cards per user are supported, Stripe Customer allows that – we’d simply attach additional PaymentMethods to the same customer and decide which to use for a given campaign or charge. Using Stripe in this manner ensures PCI Level 1 compliance on Stripe’s side and minimal scope on ours. All sensitive actions are tokenized: for example, the front-end calls stripe.confirmCardSetup(clientSecret) which directly communicates with Stripe. Parker’s backend only handles the resulting token IDs. In effect, Stripe acts as our secure vault for payment data, and we leverage their APIs to create charges using those vaulted methods when needed. Off-session charges are made possible by storing the PaymentMethod with the Customer and flagging off_session=true on the PaymentIntent
docs.stripe.com
. Stripe will handle the heavy lifting of fraud checks and issuer communication. In case an off-session charge requires authentication that wasn’t handled at setup (e.g., card issuer insists on 3DS for this specific transaction), Stripe will decline the PaymentIntent with an error, which we catch and handle (see Error Handling section). We also plan to enable Stripe’s “automatic_payment_methods” where appropriate so that Stripe can handle payment method selection or future payment method types, though initially we will focus on cards.
Supabase Schema: Storing References, Not Card Data
Our Supabase Postgres database will only store references to Stripe objects and high-level payment records, never raw PANs (Primary Account Numbers) or CVCs. We will extend the schema to support this integration as follows:
Traveler Profile Table (or augment the existing user profile table): stores each user’s Stripe customer ID and perhaps a default payment method ID. For example:
sql
Copy
-- Assuming a 'profiles' table linked to auth.users
alter table profiles
  add column stripe_customer_id text,
  add column default_payment_method_id text;
In TypeScript, an interface might look like:
ts
Copy
interface TravelerProfile {
  userId: string;
  stripeCustomerId: string;
  defaultPaymentMethodId?: string;
  // ... other fields like name, email, etc.
}
The stripeCustomerId (e.g. cus_ABC123) ties the user to Stripe, and defaultPaymentMethodId (e.g. pm_XYZ456) is the PaymentMethod the user wants to use for auto-bookings by default. These fields are filled when the user saves a card. We enforce that only authenticated users can read/write their own payment IDs (using Supabase’s Row-Level Security policies) so that one user cannot see another’s Stripe IDs.
Payment Methods Table (future enhancement): In Phase 1, we might simply store a single default PaymentMethod per user for simplicity. In Phase 3, to support multiple saved cards, we’d create a separate table, e.g. user_payment_methods, with fields: id (PK), user_id (FK), stripe_payment_method_id, card_brand, card_last4, exp_month, exp_year, is_default etc. This table would allow a user to have several PaymentMethods on file. We’d populate the brand/last4 via Stripe API when the card is added (Stripe’s PaymentMethod object provides those details). Storing the last4 and brand is handy for UI (e.g. “Visa ending 4242”) and is not sensitive personal data. The actual full card number remains only with Stripe. An example TS interface:
ts
Copy
interface UserPaymentMethod {
  id: string;
  userId: string;
  stripePaymentMethodId: string;
  cardBrand: string;
  last4: string;
  expMonth: number;
  expYear: number;
  isDefault: boolean;
}
Auto-Booking Campaigns Table: Each auto-booking campaign (the long-running flight search) will reference the traveler and possibly a specific payment method. We’ll add a foreign key like traveler_profile_id (and optionally payment_method_id if we allow choosing a non-default card per campaign). In the MVP, we can assume the default card is used for all campaigns for that user; in future, we allow selecting a payment at campaign setup. The campaign record will also store details like destination, date range, price limit, etc., and importantly the current payment status of the campaign (e.g. awaiting_charge, payment_succeeded, payment_failed). This status gets updated via our payment webhook handling.
By storing only Stripe IDs and minimal card info (brand/last4), we avoid PCI-sensitive data in Supabase. Even if our database were compromised, an attacker cannot get card numbers – at best they’d get a Stripe customer or token ID, which is useless without our Stripe secret key (which is kept out of the DB, in server env vars). This design also simplifies compliance: we’re effectively outsourcing card storage to Stripe (a PCI Level 1 provider)
stripe.com
. Our Supabase schema acts as a mapping layer: linking users to Stripe customers, linking campaigns to payment methods, and logging transaction outcomes. We will also create a Payments Transactions log table to record each charge we attempt (with fields like user, campaign, Stripe payment_intent_id, amount, currency, status, timestamp). This provides an audit trail and makes it easy to display history to the user (“Flight to SFO – $300 – Charged on 2025-08-01”). For example, after a successful PaymentIntent, we’d insert a row into payments table with stripe_payment_id, amount, currency, status='succeeded'
bootstrapped.app
. If using webhooks, we reconcile these statuses based on Stripe’s events to ensure accuracy.
Linking Payment Methods to Auto-Booking Campaigns
To ensure each auto-booking campaign knows which payment method to charge when a flight is found, we establish clear links in our data model:
Each Campaign will be associated with a Traveler Profile (the person traveling). In the simplest case, the traveler is the user themselves, so there’s a 1:1 link between user and campaign. In future multi-traveler scenarios, a user could create campaigns for different traveler profiles (e.g. self, spouse, etc.), so the campaign would reference the appropriate profile. The Traveler Profile, in turn, knows the Stripe Customer ID and default PaymentMethod for that traveler.
We assume that by default the campaign will use the traveler’s default payment method on file. This keeps things simple – the user effectively has a “primary card” used for all their bookings unless specified otherwise. We will surface in the UI which card is being used for the campaign (e.g., “Charges will be made to Visa ending 4242 up to your budget amount”). If the user wants to use a different card for a specific campaign, we have two approaches:
Single-Method MVP: The user can change their default card in their profile before the campaign triggers. All campaigns just pull the current default card at charge time.
Campaign-Specific PaymentMethod (future): We allow selecting from saved cards when setting up the campaign. In this case, the campaign record would have a payment_method_id (or the Stripe PaymentMethod ID directly) field. When charging, we use that specific PaymentMethod instead of the profile’s default. This is an extension for Phase 3 when multiple payment methods are supported.
Internally, when prepareAutoBookingCharge runs for a given campaign, it will:
Look up the campaign → get traveler_profile_id (or user id).
From profile, get stripe_customer_id and either the default_payment_method_id or the campaign’s specified payment_method_id.
Use those to create the PaymentIntent (customer + payment method in the Stripe API call)
docs.stripe.com
.
This linking ensures we never store raw card data in the campaign or profile, just references. It also cleanly separates concerns: the campaign doesn’t need to know anything about cards or Stripe; it just carries a foreign key that our payment module uses to find the actual token. If a user updates their default card in between (and the campaign is using default), we will charge the new default – which is likely desirable (e.g., their old card expired, they added a new one, so all future auto-charges should use the new card). We’ll need to communicate to users that if they change their default card, it affects pending bookings. Additionally, linking via Stripe Customer allows for multi-traveler support down the line: We might create a separate Stripe Customer for each distinct traveler profile if, say, Parker wants to track charges per traveler (however, it might be simpler to keep one Stripe Customer per user account and just attach all cards there – one user can pay for multiple travelers). For now, we’ll assume one Stripe Customer per user. If a user sponsors multiple travelers, they still pay with their cards, so it’s fine to use one Stripe customer (the charges can still have metadata indicating which traveler or campaign for our records). In summary, every auto-booking campaign is securely tethered to a payment method via a Stripe Customer. This design avoids any need to pause a campaign to ask for payment info when it finds a flight – the payment is ready to go, which is crucial for a seamless auto-booking experience.
Handling Expired or Failed Cards
Credit cards can expire or be cancelled between the time a user saves them and the time we charge them. Our architecture proactively and reactively handles these scenarios:
Stripe Card Updater & Expiry Info: Stripe provides card expiry detection and updates. When a user’s saved card is nearing expiration, Stripe typically knows from the card networks. While Stripe doesn’t send explicit webhooks for upcoming expiration, we can retrieve expiry info from the PaymentMethod (it has exp_month and exp_year). We will periodically check (or use Stripe’s email alerts) for cards that will expire before any upcoming campaign end-date, and notify the user to update their card. (In future, we could automate an email: “Your card on file expires next month, please update to avoid interruption.”) If the user adds a new card, we update the default PaymentMethod ID.
Before Charge Attempt: Right before creating the PaymentIntent for an auto-booking, our function can double-check the PaymentMethod’s status via a quick Stripe API call (retrieve the PaymentMethod to ensure it’s still valid and not expired or detached). This is a safeguard to possibly avoid a failed charge call. However, in most cases we can just attempt the PaymentIntent and handle errors, since Stripe will immediately throw an error for an expired card.
Payment Failure Handling: If an off-session charge fails due to card issues, our webhook handler and charge function logic will catch it. Common failure reasons:
Card declined: Could be insufficient funds, stolen card, network rejection, etc. In this case, payment_intent.status = requires_payment_method (meaning it failed and needs a new method)
docs.stripe.com
. We mark the campaign’s payment status as failed. If the user has an alternate card on file (and we have logic for fallback), we will attempt that automatically (perhaps only if the failure reason is soft, like insufficient funds, and not a hard fraud decline). Otherwise, we notify the user immediately. The user can then go to their Parker dashboard and add a new card or retry.
Card requires SCA (3D Secure): In off-session, if a card’s issuer demands 3D Secure for the charge and no prior exemption covers it, Stripe will decline the off-session PaymentIntent – it often returns an error indicating “authentication_required”. The PaymentIntent might not go to requires_action state for off-session; instead it goes to requires_payment_method (since it can’t prompt the user)
support.stripe.com
. Our strategy then is to prompt the user to authenticate. We can do this by creating a new PaymentIntent (or updating the failed one) and attempting confirmation with off_session=false (on-session)
support.stripe.com
support.stripe.com
. This will produce a PaymentIntent in requires_action status with a 3DS challenge. We then inform the user (via email with a secure link, or an in-app alert) that “Your presence is required to complete the booking payment.” When the user clicks that link (authenticated), we load Stripe.js and call stripe.confirmCardPayment with the PaymentIntent client secret, which will pop up the bank’s 3DS challenge for the user to complete
docs.stripe.com
docs.stripe.com
. If they succeed, the payment succeeds and we proceed with booking; if they abandon or fail, we mark it accordingly. This flow is essentially a manual fallback when an automatic charge fails due to SCA. We’ll implement this in Phase 2 as part of hardening (since initial launch might just fail and notify).
Card expired: Stripe will decline the PaymentIntent with an “expired_card” error. Handling is similar to a decline – user must update the card. If they had another card on file, we could automatically try that as a backup.
Network or API errors: If Stripe’s API is temporarily unreachable or returns an unknown error, our function can catch exceptions. In such cases, we should retry the PaymentIntent after a short delay (to mitigate transient issues). We will implement idempotency keys on PaymentIntent creation (using Stripe’s idempotency_key header) so that if our function retries due to a network issue, we won’t double-charge the user
bootstrapped.app
 (the first attempt’s idempotent key will ensure the second attempt just gets the same result or no duplicate).
Backup Payment Methods: Once we allow users to store multiple cards (Phase 3), we will implement automatic fallback logic. For example, if the default card fails, our charge function can immediately try the next preferred card. We will need to be careful here to only do one additional attempt, to avoid spamming multiple charges. A smart strategy: mark the first card as “failed for this transaction” (and possibly demote it if failure is persistent), notify the user of the failure but also inform “we tried your backup card ending 6789 which succeeded.” This gives a seamless experience if the second card goes through. If all cards fail, the campaign remains unfulfilled and user is alerted to fix payment.
Webhooks and User Notifications: The payment_intent.failed webhook provides failure reasons, which we can log. We’ll translate those into user-friendly messages (e.g., “Your card was declined by the bank – please contact your bank or use a different card”). If a card fails due to insufficient funds, we could optionally schedule a retry a day later (Stripe does this automatically for subscription invoices, but for our one-off charges we’d have to implement our own retry if desired). Given flight bookings are time-sensitive, a better approach is to fail fast and let the user manually confirm if they want to try again, rather than retrying many hours later when the flight deal might be gone. We’ll likely do at most one automated retry (maybe 5-10 minutes later) for transient failures, then require user intervention.
Card Updates: If a user updates their payment method (adds a new card or changes default) while a campaign is ongoing, our system will use the latest information at charge time. We’ll ensure that changing the default card on the profile immediately reflects in any yet-to-be-charged campaigns. If a PaymentIntent is already in progress or succeeded, changing the default won’t affect that, of course.
Overall, our system is designed to fail safe – if a payment cannot be completed, we don’t book the flight (so Parker isn’t out of pocket), and the user’s campaign remains pending. The user is then looped in to resolve the issue. By leveraging Stripe’s error codes and webhooks, we can give clear guidance. We also incorporate Stripe’s features like automatic network card updates (Stripe may automatically update saved card details if the bank provides updated expiry or number due to reissue) and Radar’s fraud insights to decide how to handle failures (e.g., if Radar flags a payment as fraudulent, we might not retry at all and instead reach out to the user).
Fraud Prevention and Verification
Security is paramount, especially for a system that stores payment credentials for long periods and charges cards automatically. We employ multiple layers of fraud prevention and verification, primarily by utilizing Stripe’s built-in tools:
Stripe Radar: All payments will be screened by Stripe Radar, Stripe’s machine-learning based fraud detection system. By default, Radar evaluates every charge across Stripe’s network and assigns a risk score, automatically blocking many high-risk payments
stripe.com
. We will use Stripe’s default Radar rules, which include rules to block likely fraudulent transactions and may require 3D Secure on certain high-risk charges. For example, Radar can be configured to “require 3D Secure for all European cards or for charges over $X” etc. Initially, we trust Radar’s defaults which have a proven track record of stopping fraud with minimal false positives
stripe.com
. As Parker scales, we can review fraud results in the Stripe Dashboard and add custom Radar rules (e.g., block transactions from certain countries if Parker only sells to specific regions, or require manual review for very large ticket prices beyond a threshold). Radar also uses tools like device fingerprinting and historical data to identify fraud patterns automatically.
3D Secure (SCA): Stripe will handle 3DS authentication whenever mandated or appropriate. Because we use SetupIntent with usage=off_session, Stripe will prompt 3DS during card setup if the card or region requires it (e.g., an EU customer’s card will go through 3DS verification at save time)
docs.stripe.com
. This means by the time we charge off-session, the card is flagged as having been authenticated for future use (merchant-initiated transaction), reducing the chance of a decline
docs.stripe.com
docs.stripe.com
. If an off-session charge still requires 3DS (no exemption granted), our aforementioned flow will involve the user to authenticate. We will also enforce 3DS on the first charge of any new card if Stripe doesn’t do it by default. Essentially, SCA compliance is built-in: we obtain the user’s consent and authentication for future charges when they save the card, fulfilling regulatory requirements for recurring/off-session payments. In our UI/terms, we’ll explicitly state the user authorizes us to charge their card for bookings (mandate), as required by PSD2/SCA rules
docs.stripe.com
.
Customer Verification (Stripe Identity): For additional verification of user identity (to prevent stolen cards usage), Parker could integrate Stripe Identity in the future. For instance, if a user is making exceptionally high-value bookings or triggers some risk signals (like multiple payment failures or mismatched names), we could ask them to complete a one-time ID verification through Stripe’s Identity service (which checks government IDs, selfies, etc.). This is an added layer beyond payments. It may not be needed for MVP, but it’s a tool available if fraud rates become a concern. We mention it for completeness: e.g., before issuing tickets worth $10,000, perhaps verify the user’s identity to avoid chargeback fraud. Stripe Identity integrates with Stripe’s API and we can store an “verified” flag on the user once completed.
Email and 2FA: Parker uses Supabase Auth for user login; we’ll encourage strong authentication for user accounts (e.g., two-factor auth for user login could be enabled to prevent account takeovers – so someone can’t hack a Parker account and misuse the saved card). While not a direct payment fraud measure, securing user login is important since an attacker in control of a Parker account with auto-book enabled could potentially cause charges (though they can only book flights for the card owner, which likely wouldn’t benefit the attacker, but still).
Transaction Metadata & Reconciliation: We will attach useful metadata to each Stripe PaymentIntent (like metadata: {campaign_id, user_id, route: "NYC-MVY", traveler_name} etc.). This not only helps in our own logs but also in case of disputes: if a user later claims “I don’t recognize this charge,” we have clear records of what it was for. We expect low likelihood of friendly fraud if we communicate clearly, but having metadata in Stripe can assist Stripe’s Radar and our customer support in verifying legitimate charges.
Stripe Radar and Rules Tuning: Over time, Parker can fine-tune fraud rules. For example, if Parker operates only in certain markets, we might block charges from other regions by rule. If most users book flights under $2,000, a rule to flag anything above, say, $5,000 for manual review could be wise. Radar allows us to mark charges for review rather than outright block – for auto-booking, though, manual review might not be feasible in real-time. So likely we’d lean on automated measures. Stripe’s network and Radar’s ML are a strong first line of defense, which is why we chose Stripe.
In short, Parker’s payment architecture entrusts fraud prevention to Stripe’s battle-tested systems (Radar’s ML, card issuer checks, 3DS). We also implement necessary mandates and user consent for off-session charges to minimize dispute risk (making sure users know what they’re signing up for). In case of a dispute (chargeback), Stripe will notify us via webhook. Parker can then decide if we have the mandate and proof to challenge it (e.g., if a user claims fraud, but we have their agreement to charge for the booking, we might submit evidence). Notably, if a 3D Secure auth was completed on a charge, liability shifts to the issuer for fraud disputes
docs.stripe.com
 – another reason to utilize 3DS, as it protects Parker from eating the cost of fraudulent charges.
Currency Support for International Users
Parker Flight aims to serve travelers globally, so the payment system is built to handle multiple currencies. Stripe natively supports charging in 135+ currencies as long as they are enabled on our Stripe account
duffel.com
. Our design considerations for multi-currency are:
Currency Field on Campaigns: Each auto-booking campaign will have an associated currency for its budget/price (likely derived from the user’s preference or the point-of-sale location). For example, a user in Europe might set a budget in EUR, while a US user uses USD. We will store the currency (ISO code) along with the campaign or use a default from the user’s profile.
Charging in Currency: When creating the Stripe PaymentIntent for the booking, we specify the currency along with the amount
docs.stripe.com
. Stripe will then charge the card in that currency. If our Stripe account’s settlement currency is different, Stripe will automatically convert and deposit funds in our account’s currency (with a conversion fee). For instance, Parker might have a US-based Stripe account (default USD), but can still charge €500 to a European customer’s card – Stripe will handle conversion to USD in our payout, or we could hold a separate Stripe balance in EUR if desired. The key is to pass the correct currency code from the campaign to Stripe so the customer is charged in their expected currency.
Duffel API and Currency: We must ensure the currency we charge matches the currency we pay the airline. If using Duffel Payments, Duffel might handle multi-currency transparently. If using Duffel Balance, Parker will likely pay airlines in their local currency or a chosen currency. There may be some complexity if, say, a user sets a budget in USD for a European flight priced in EUR – Parker might either restrict campaigns to use the user’s local currency or do a conversion at booking time. For simplicity, Phase 1 can be region-specific (e.g., Parker launches in US only, using USD). But the architecture is ready to expand – just need to store an extra field and pass it to Stripe.
Stripe Customer and Multi-currency: Stripe Customers and PaymentMethods are currency-agnostic; a saved card can be charged in any currency that the card network and Stripe support. However, certain payment methods (like ACH or certain wallets) are currency-specific. Initially we stick to major credit cards, which typically can handle multi-currency charges (the issuer does conversion for the cardholder if needed).
Display and Conversion: Parker’s UI should display prices and budgets in the user’s currency. For multi-currency support, we might integrate a currency conversion API to show approximate converted amounts if needed (not a core payment architecture issue, but a UX note). The actual charge amount will be exactly as per the campaign currency and price.
Testing multi-currency: We’ll test with Stripe’s test cards in various currencies (Stripe allows specifying currency in test mode to ensure our code paths work). Also ensure our backend calculations multiply out to the correct smallest currency unit (Stripe expects amount in cents for USD, but for JPY it’s in yen since no decimals, etc.). The Stripe API handles this as long as we know the minor unit for each currency.
Expansion considerations: If Parker expands to regions where having separate Stripe accounts is beneficial (e.g., a European Stripe account for European customers to improve authorization rates or to get local acquiring benefits), our architecture could support that by routing payments through different Stripe accounts based on region. That adds complexity (managing multiple secret keys and customer IDs per region), so likely not in initial scope. For now, one Stripe account with multi-currency enabled is sufficient, which is straightforward as Stripe is global by default.
In summary, the payment architecture is currency-flexible. We simply treat currency as another attribute of a campaign’s payment intent. By leveraging Stripe’s support for 135+ currencies, we ensure that international users can be charged in their local currency
duffel.com
 (avoiding surprise FX fees for them and aligning with Duffel’s multi-currency capabilities). Parker Flight can collect payments in USD, EUR, GBP, AUD, etc., as needed, with minimal changes in code (mostly configuration and testing).
API and Edge Function Design Patterns
To implement this architecture, we will create a set of secure backend endpoints (Edge Functions on Supabase or serverless API routes on Vercel) that handle all payment-related operations. These functions ensure that sensitive operations (creating intents, handling webhooks) are done server-side with the Stripe secret key. Below are the key API/Function patterns:
POST /payments/savePaymentMethod (Edge Function): Purpose: Save a new payment method for a user.
Flow: The front-end calls this when a user submits their card details. The function requires user authentication (we’ll use the Supabase JWT to identify the user). Steps:
Create Stripe Customer if needed: Look up the user’s stripe_customer_id in Supabase. If not present, call stripe.customers.create({ email, metadata }) to create a new Customer
bootstrapped.app
. Store the returned id in the user profile. (We include the user’s email and possibly Supabase UID in metadata for traceability).
Create SetupIntent: Call stripe.setupIntents.create({ customer: <id>, usage: 'off_session' })
docs.stripe.com
. Optionally, we can set payment_method_types: ['card'] to limit to card, and a metadata note like "Setup for Parker auto-booking". Stripe returns a client_secret.
Respond to client: Send back { clientSecret: "<...>" }. The function does not handle card data itself.
(Front-end will use Stripe.js to confirm the SetupIntent with the client secret and card details.)
Webhook handling: On success, a setup_intent.succeeded event will fire. Alternatively, we could have the front-end send us the PaymentMethod ID after confirmation – but the webhook is more secure. In either case, we then attach the PaymentMethod ID to the user in DB: update default_payment_method_id and optionally insert into a PaymentMethods table with details. If using webhooks, the setup_intent.succeeded handler will do this DB update (see webhooks below).
Security: This endpoint does not accept raw card info – only creates intents. It must verify the caller is an authenticated user (Supabase’s built-in JWT and RLS ensure only logged-in users can hit it). Also, ensure rate limiting (to prevent abuse of creating too many Stripe objects).
POST /payments/prepareAutoBookingCharge (Edge Function / Serverless function): Purpose: Attempt to charge the user’s saved card and book the flight when campaign criteria are met.
Trigger: This might be called by our scheduler or by a background worker when a flight deal is found. In Supabase, we could use pg_cron or an external job that, upon finding a suitable flight, calls this function.
Input: It needs the campaign or booking details (e.g., campaign_id or directly flight offer details). We might pass just an ID and have the function load the necessary data from DB (safer).
Steps:
AuthZ: This function may be initiated by the system rather than a user, so we’ll secure it by a service role key or a restricted JWT that our backend holds. Alternatively, no auth if it’s invoked internally (but if exposed as HTTP, protect it).
Load Data: Retrieve campaign record from DB. Ensure it is indeed in a state ready to book (not already booked or cancelled).
Get Stripe IDs: Fetch the associated stripe_customer_id and payment_method_id (default or specified) via the campaign’s traveler profile.
Amount & Currency: Determine the final price to charge. Likely we have a quote from Duffel for the flight cost. Use that as amount (ensuring to convert to the smallest currency unit, e.g. dollars to cents). Include Parker’s fee or markup if any.
Create PaymentIntent: Call stripe.paymentIntents.create({ amount, currency, customer: id, payment_method: id, off_session: true, confirm: true, description: "Flight booking for [Traveler/Route]", metadata: {campaign_id, ...} })
docs.stripe.com
. This immediately attempts the charge. Use an idempotency key (like key = campaign_<id> or the Duffel offer ID) to avoid double-charging if this function is accidentally invoked twice.
Handle Stripe Response: If PaymentIntent is succeeded (status='succeeded'), proceed. If an error is thrown (exception), catch it:
If error requires_payment_method (meaning failure), parse the StripeCardError to get decline code or message. Update DB: mark campaign payment_status = 'failed', record failure reason. Trigger notification to user (could enqueue an email).
If error indicates requires_action (unlikely directly in off_session create, but just in case), we will follow up via webhook or separate flow as described (flag that user action is needed).
End the function in failure case (do not call Duffel).
If succeeded: Mark payment_status = 'succeeded_pending_booking'. Then call Duffel API (likely an authenticated call to duffel.orders.create or similar) to book the flight. Supply passenger info, etc., which we have from the campaign. If Duffel confirms booking (order creation successful), update campaign status to 'booked', save order ID, ticket info etc. If Duffel booking fails for some reason (e.g., price changed or seat sold out):
We have a charged PaymentIntent but no booking. In this rare case, we must void or refund the charge to the user. If the PaymentIntent is still uncaptured (we could create it with capture_method='manual' to delay capture until after booking confirmation), we could cancel it. But since we set confirm=true it likely captured. So we would issue a stripe.refunds.create({ payment_intent: id }) to return the money. Update campaign status accordingly (perhaps back to active or cancelled) and inform the user that the booking couldn’t be fulfilled and they weren’t charged (net).
This is an edge scenario, but we’ll handle it to ensure users aren’t charged without a booking. We’ll prefer to use capture_method=manual in Phase 2 to make this a two-phase commit: authorize card, attempt booking, then capture or release.
Finish: On success, trigger an email to user: “Your flight is booked! Receipt ...”. Also consider sending a receipt via Stripe’s system or our own (Stripe can automatically email receipts if enabled, or we do it and include Stripe charge ID and our details).
POST /payments/webhook (Stripe Webhook handler): Purpose: Receive events from Stripe for asynchronous payment updates.
Setup: We’ll configure Stripe to send events (like setup_intent.succeeded, payment_intent.succeeded, payment_intent.payment_failed, charge.dispute.created, etc.) to this endpoint. It will be a serverless function with Stripe’s signing secret to verify authenticity.
Behavior: The function will read the raw request body and headers to verify the Stripe signature
bootstrapped.app
 (security critical). Then parse the event type and act accordingly:
setup_intent.succeeded: Extract the SetupIntent ID and its attached PaymentMethod. Find which user it belongs to (we might store a mapping of SetupIntent to user in a temporary table when we create it, or use the Stripe Customer ID in it to look up the user). Update the user’s profile: set stripe_customer_id (if not already) and default_payment_method_id = the new PaymentMethod ID. Also, use Stripe’s API to retrieve the PaymentMethod object so we can log brand and last4 in our user_payment_methods table. Mark any previous card as replaced if needed.
setup_intent.setup_failed (if user’s card setup was denied): We can notify the user or simply log it and let the front-end handle (the front-end would have gotten an error on confirmation in that case).
payment_intent.succeeded: Mark the corresponding payment record (campaign) as paid. We likely have already handled booking in the function call, but webhook ensures we don’t miss it. This could be used as a backup to trigger booking if our function crashed after charging (though that scenario is unlikely if we do charge and book synchronously in one function). It’s also useful for logging and for triggering any post-payment processes (like sending a receipt or updating analytics).
payment_intent.payment_failed: This informs us an off-session charge failed (could be from our auto attempt, or if we had any scheduled retries). We will update the campaign status if not already done, and ensure the user is notified. This webhook is crucial if a failure happens asynchronously (for example, if we had set confirm=false and were waiting, but in our case we confirm immediately so failures come in response).
charge.dispute.created: If a user disputes a charge (chargeback), Stripe will alert us. We then flag that in our system for follow-up. Possibly freeze that user’s campaigns until resolved (to prevent further auto-charges). Also gather evidence (we have the mandate and any emails to prove user consent).
Other events: customer.subscription.* are not used now (no subscriptions), payment_method.attached might fire when we attach to customer (duplicate info to setup_intent.succeeded), etc. We will log unhandled events just in case.
We implement webhook handler carefully to be idempotent (Stripe may retry events), and to handle events in the correct order. We might use event id to ensure we don’t double process. Supabase Edge Functions run on Deno which can handle this, or we can use a Vercel API route (Node) similarly.
Helper Functions / Other APIs:
GET /payments/methods – return list of saved cards (PaymentMethods) for the logged-in user, with last4/brand info for display (data coming from our DB which we keep in sync with Stripe).
POST /payments/removePaymentMethod – allow user to remove a card (except maybe if it’s tied to active campaigns, we’ll warn them). This would call Stripe to detach the PaymentMethod from customer, and update our DB.
POST /payments/updateDefault – switch default card on file. Update DB and maybe set a flag in Stripe (Stripe has invoice_settings.default_payment_method on Customer which is mainly for subscription billing, but we can set it for consistency).
POST /payments/testCharge – (for dev/testing only) to simulate a charge; not in prod.
Edge Function security: All these endpoints will authenticate the user via Supabase JWT and enforce RLS where appropriate. The webhook endpoint is an exception – it’s authenticated via the Stripe signature header instead.
Duffel Integration Point: While not a Stripe function, it’s worth noting how we integrate the booking API. Likely, after a payment success, we call an internal API or service that communicates with Duffel. This might be within the same prepareAutoBookingCharge function or a separate job triggered by the webhook payment_intent.succeeded. The choice may depend on ensuring we book quickly after payment to lock in the price. We prefer to book in the same transaction flow to avoid time lag (so the user’s card is charged and flight immediately booked). However, doing both in one serverless function call means that function will be waiting on an external API (Duffel) – possibly a few seconds. That should be fine. Alternatively, we could respond success to the PaymentIntent call, then let webhook event handle the Duffel booking asynchronously; but the risk is a slight delay where payment succeeded but booking hasn’t started yet. For MVP, we can book immediately in the same call if possible.
Summary of design patterns: We separate concerns – one endpoint to handle saving cards (customer & setup intent creation), one to handle charging (payment intent and booking logic), and a webhook to handle async confirmations. This approach keeps the front-end code minimal (just handling Stripe Elements and showing statuses) and leverages serverless functions for security (Stripe secret key usage) and flexibility (we can update logic without app redeploy). All secrets (Stripe secret key, webhook signing secret, Duffel API key) will be stored as environment variables in the serverless environment (Vercel or Supabase Edge) and not exposed to the client. We will also incorporate robust error handling and logging in these functions – e.g., if Stripe API fails, we catch and log the error, and possibly report it to an error monitoring service. Each function will respond with clear error messages to the frontend (though front-end will rarely call the charge function, since that’s triggered internally).
Error Handling and Fallback Strategies
Despite best efforts, errors and edge cases will occur – the payment architecture is designed to handle these gracefully and provide a good user experience even when issues arise:
Real-Time Payment Failures: As discussed, if a PaymentIntent fails immediately during prepareAutoBookingCharge, we catch it and update the campaign status. The user is quickly notified. For example, if Stripe throws an error “card_declined” or “insufficient_funds,” we might mark the campaign as “Payment Failed” and send an email like “We tried to book your flight but your card was declined for insufficient funds. No charge was made. Please update your payment method and we can try again.” The campaign could remain active in a “paused” state so that once the user fixes their card, they can resume it (if the flight deal is still available or for future deals).
Retries: In some cases, an immediate retry might succeed (e.g., network glitch or Stripe service momentary issue). We will implement a simple retry mechanism for idempotent operations:
If a PaymentIntent creation fails due to a network timeout or Stripe internal error, our function can safely retry once using the same idempotency key. If it fails again, likely an actual issue, so we stop and mark an error for ops to check.
We avoid retrying hard declines (e.g., do not attempt the same card again if it was explicitly declined, as banks often count multiple rapid retries as fraud signals).
For insufficient_funds or daily limit errors, an immediate retry is pointless; better to alert user. We could allow the user to manually click “retry charge” after they perhaps move funds or choose another card.
Backup PaymentMethod Fallback: As mentioned, when multiple cards are on file, the system can fall back automatically. This will be implemented with caution:
We will ask user permission during card setup or campaign creation: e.g., “If your primary card fails, do you allow us to try your backup card? – Yes/No”. Users might appreciate auto-fallback to not miss a deal. If they opt in, we implement it.
The algorithm: upon failure of default, select the next card (maybe the user can rank their cards). Create a new PaymentIntent for that card and attempt. This all would happen quickly within the same prepareAutoBookingCharge execution, so that booking can still proceed near instantly. If second card succeeds, we continue to booking and notify user “Card A failed, but Card B was charged successfully.” If second card also fails, then we fail overall.
We will log both attempts clearly in the payments table for transparency.
User Intervention for SCA: For off-session SCA-required cases (which result in requires_action needed), our strategy acts as a fallback: mark the payment attempt as requiring action, notify the user with a deep link to complete payment. The user coming back on-session to authenticate is effectively a “retry” with their involvement. If they complete it, then the booking continues. We must ensure the flight offer is still available during this time; possibly, we might hold the reservation (if Duffel supports hold without payment for short time) until auth is done. This is complex – so more likely we’ll implement that if a 3DS is required, we cannot auto-book at that moment. We’d notify the user and possibly convert that booking to a normal user checkout (they complete manually). This might be a rare scenario depending on regions.
System Errors & Webhooks: If our serverless function crashes or times out after charging the card but before booking, the webhook payment_intent.succeeded acts as a safety net. We could have logic in the webhook like: if we see a succeeded payment for a campaign that is not marked as booked, attempt the booking or at least alert staff. This prevents money from being captured without a booking. Such recovery logic ensures consistency.
Insufficient Duffel Balance / Payment: If Parker uses Duffel Balance (i.e., we need enough money in Duffel account to pay the airline), a possible error is that Parker doesn’t have funds. We should monitor and top-up Duffel Balance as needed. If, at booking time, Duffel returns “Insufficient balance,” we have a problem – user was charged but booking not completed. To avoid this, we will have an automated check: before charging the user, ensure Parker’s Duffel Balance >= flight cost. If not, either top-up (if automated or using Duffel Payments so not needed) or do not proceed with charge (mark error, and alert admin). Keeping Parker’s funds in sync is operational, but we mention it as a fallback consideration.
Timeouts and Idempotency: All our critical calls (Stripe charges, Duffel booking) will use idempotency keys or unique identifiers so that if a function timeouts or retried, we don’t duplicate actions. For example, if a function times out after booking but before sending response, a retry might attempt booking again – but using the same Duffel request ID or detecting that the campaign is already booked will prevent duplication. Similarly, the idempotent Stripe key avoids double charge. This ensures that even if our system experiences a glitch, the external side (Stripe, Duffel) won’t double execute.
Logging and Alerts: We will implement logging for payment attempts. If a payment fails for any reason, it will be logged with context. We might also set up alerts for certain conditions: e.g., if any PaymentIntent fails with a “fraud_declined” code (meaning Stripe suspect fraud), we alert our team to potentially reach out to the user or investigate. If multiple campaigns fail due to expired cards, that’s a signal to improve our card update reminders. Essentially, error logs will feed back into product improvements.
User Experience on Failures: In the Parker dashboard, we will have a Payment Status indicator for each campaign. For example, “✅ Payment method on file” vs “⚠️ Payment issue – action required.” If a payment fails, the user should see that their campaign needs attention. We will provide an easy way to fix (like an “Update Card” button right there, or a “Retry Payment” after they update). The goal is to let them recover without friction. Additionally, for failures, we consider pausing the campaign’s flight search (since no point continuing if payment can’t go through). Or we continue searching but ensure no booking happens until payment is resolved. We’ll likely pause it, because we don’t want to find a great flight but then not book it due to payment – better to resolve payment first.
Graceful Degradation: If for some reason Stripe itself is down (rare, but could happen) at the moment a flight deal is found, we could either hold the reservation until Stripe is back or at least not crash. Possibly inform the user that we couldn’t charge right now due to technical issues. These scenarios are extreme, but our code should handle Stripe API errors gracefully and try again a bit later if possible.
In summary, our error handling strategy is fail-safe and user-friendly: no silent failures, immediate user notification for issues, minimal automatic retries to avoid user confusion, and robust fallback to backup methods or user action as needed. By planning for these cases, we ensure the auto-booking feature feels reliable and transparent, building user trust.
Testing Strategy
Testing the payment architecture is crucial given the complexity of delayed charges and external integrations. We will employ a multi-faceted testing approach: 1. Unit and Integration Tests: We’ll write automated tests for the serverless functions:
Unit tests to simulate logic in a sandbox: e.g., test that savePaymentMethod creates a customer if none, test that prepareAutoBookingCharge chooses the right PaymentMethod and handles various Stripe responses properly (we can mock Stripe API calls using stubbed responses).
Integration tests on a test environment (e.g., using Stripe’s test mode with our dev Supabase instance). We can use the Stripe test API keys and the special test card numbers to simulate scenarios:
Use 4242 4242 4242 4242 (Visa test) for a normal successful flow
docs.stripe.com
.
Use 4000 0025 0000 3155 (test card that requires 3DS once) to simulate a card that will prompt authentication on setup
docs.stripe.com
.
Use 4000 0027 6000 3184 (card that requires 3DS for every charge) to simulate an off-session 3DS required scenario
docs.stripe.com
. This will let us test our fallback to on-session authentication.
Use 4000 0000 0000 9995 to simulate a card that is declined
docs.stripe.com
, ensuring our system properly handles the payment_failed event and user notification.
We will also test expiration handling by using Stripe’s test feature to update a card’s exp date or using a card that is already expired (Stripe has test tokens that simulate expired card error).
Integration with Duffel: In test mode, Duffel provides a sandbox API. We’ll simulate a full flow: save card (Stripe test mode), create a dummy campaign, then trigger a fake “found flight” event to call prepareAutoBookingCharge, which charges say $50 (in test mode Stripe doesn’t actually move money) and then call Duffel sandbox to book a test flight (Duffel likely has dummy flights in sandbox). This end-to-end test ensures all pieces talk to each other. We’ll verify that after this, the Supabase DB has the booking record, payment record, and the user got a confirmation (in test we might capture emails or simulate that step).
2. Stripe Webhook Testing: We will use the Stripe CLI in development to send test webhook events to our local or staging server. For example, run stripe trigger payment_intent.succeeded with a given PaymentIntent ID to see that our webhook correctly updates the DB. Also test signature verification – sending a webhook with wrong secret should be rejected (we expect a 400 error in that case). We’ll simulate setup_intent.succeeded through the CLI as well after a test card setup to ensure our webhook logic properly writes the profile. Essentially, we want to confirm that even if the initial function doesn’t directly update DB, the webhook does its job. 3. Front-End Testing: On the front-end, we’ll test the Stripe Elements integration:
Ensure the Stripe Elements form properly handles error states (like card declined on setup shows an error message to user).
Test that our savePaymentMethod function is called and returns clientSecret, and Stripe.js can use it to complete a setup. We can use Stripe’s test publishable key and Elements in a staging environment to simulate an entire card save from UI perspective.
Test UI flows for “update card”, “select different card”, etc., if implemented.
4. Long-Running Scenario Simulation: Since the core of this feature is long-running campaigns, we should simulate a scenario:
User sets up a campaign (we save a PaymentMethod in Jan 2025).
We then (in test) fast-forward time or simply wait, and trigger a booking event in, say, March 2025.
We ensure that the PaymentIntent still works with the PaymentMethod from January (in Stripe test mode, tokens don’t expire, but in real life, card could expire – we simulate by using an exp date that goes past that date).
This gives confidence that storing for long duration is fine. Additionally, we might manually expire a card in Stripe Dashboard and see how our charge responds (should decline).
5. Edge Case Testing:
Removing a card that’s in use by a campaign: we should prevent removal or test what happens if it’s removed (probably the campaign should gracefully handle “no payment method”).
Concurrent operations: two campaigns trying to charge the same card at once (unlikely unless user sets two separate campaigns that both trigger together). We test if our architecture can handle that (Stripe would allow it, but if they exceed credit limit maybe one fails – fine).
Multi-currency: use test currency like EUR (Stripe test mode supports eur). Confirm amounts and currency are handled properly through the system (no hard-coded “usd” anywhere).
6. Performance Testing:
Though each charge and booking is individual, we should test that our functions can handle, say, 100 campaigns triggering at the same time. Stripe can handle high concurrency; we need to ensure our DB and webhook processing can too. We’ll simulate bursts of PaymentIntents in test to see if any race conditions occur (like two webhooks updating same record – should be fine if idempotent).
Also test cold start time of edge functions (should be quick on Vercel/Supabase, but important that a triggered booking doesn’t delay too long).
7. Security Testing:
Attempt to call the payment functions with invalid auth (should be rejected).
Try to tamper with IDs (like calling prepareAutoBookingCharge for a campaign that isn’t yours – RLS or function logic should forbid).
Webhook endpoint: try calling it from a non-Stripe source (should get rejected due to signature).
Ensure no sensitive data leaks: for instance, logging should not output full card numbers. We’ll review logs in test to ensure they only contain token IDs or last4 at most.
8. User Acceptance Testing:
Finally, we’ll run through the workflow in a staging environment with a small user group or team members. They will simulate being a user: add card, start campaign, perhaps trigger a dummy booking. Verify that from their perspective, everything is clear: did they get confirmation emails? Did the UI update correctly? If a card fails, do they understand what to do? We’ll incorporate feedback to refine messaging or steps.
We will use Stripe’s test cards and dashboard extensively. The Stripe dashboard in test mode will show us events and logs – we’ll confirm our webhook events show “Succeeded” responses and that no events are left unacknowledged. For testing 3DS specifically, Stripe’s regulatory test cards (3155 and 3184 as above) will be key. We need to ensure our flow for handling requires_action events is solid. Possibly we’ll simulate it manually: cause a requires_action, get the PaymentIntent secret and mimic a user completing it (maybe by hitting the return_url or using Stripe CLI’s stripe confirm command). Testing Duffel Integration: We must test that booking a flight after payment works. In Duffel’s test mode, they might not charge anything, but we see if an order is created. We’ll test a case where we intentionally don’t charge (simulate payment failure) and ensure no Duffel order is created. And a case where Duffel fails after a successful charge to ensure our refund logic triggers. Finally, our testing strategy will include GDPR compliance testing: e.g., if a user deletes their account, ensure the Stripe customer ID is deleted or anonymized (in test mode we can simulate account deletion and ensure our deletion routines call stripe to detach cards or delete customer). By covering unit, integration, and end-to-end tests, we’ll gain confidence before going live. Additionally, we’ll run tests whenever we update the payment code (continuous integration) to avoid regressions.
Implementation Roadmap for Warp Team
Implementing this architecture will be done in phases, allowing us to deliver value early and then enhance security and features iteratively:
Phase 1: MVP Campaign-Linked Payments – Focus: core functionality working end-to-end.
Stripe Integration Basics: Implement card saving via Stripe Elements and SetupIntent. Users can add a card to their profile. Store stripe_customer_id and default_payment_method_id in Supabase
bootstrapped.app
. Ensure Supabase Auth and Stripe customer creation are linked (e.g., create Stripe customer at signup or at first card add).
Auto-Booking Charge Flow: Implement the prepareAutoBookingCharge function to create PaymentIntents off-session and handle responses. Integrate with Duffel API to actually book flights after a successful charge. For MVP, we can assume only one card (so no card selection UI) and one traveler per account.
Webhooks: Set up the Stripe webhook receiver to update payment status and profile info. At minimum, handle setup_intent.succeeded (to update DB with PaymentMethod ID) and payment_intent.succeeded/failed for logging.
Basic UI: In the front-end, add pages for Payment Method management (add card, display last4 of card on file, remove/update card if needed) and show payment status in campaign details. Also, ensure when creating a campaign, if no card on file, prompt to add one.
Notifications: Implement simple email notifications for success (booking confirmation) and failure (payment failed) – this could leverage existing Parker Flight email systems.
Testing & Launch: Test thoroughly with Stripe test mode. For launch, use Stripe in production mode with live API keys. Initially launch perhaps in a limited beta to gather real-world feedback.
Success criteria: Users can successfully save a card and the system can auto-charge and book a flight without manual intervention. No raw card data in our system, and basic fraud checks (Stripe default) in place. MVP might not handle every edge case (e.g., if an off-session 3DS is required, the booking might just fail and user will be told to rebook manually – which is acceptable in early stage).
Phase 2: Security Hardening and Recurring Billing Logic – Focus: robustness, SCA full compliance, and preparation for any repeated payments.
Strong Customer Authentication (SCA) Enhancements: Implement the full flow for handling requires_action on off-session payments. This includes generating a one-time link or in-app flow for users to authenticate if needed (as described in Error Handling). Essentially, build the UI/UX for “Confirm your payment” when an off-session charge needs 3DS. Also update terms/consent language to explicitly cover off-session charges (Mandate)
docs.stripe.com
.
Retry & Fallback Mechanisms: Add the capability for storing multiple payment methods and let the user designate a backup. Implement automatic retry with backup on failure (with user opt-in). Also possibly implement limited automated retry for transient failures (e.g., try again in 15 minutes if airline still has seat).
Fraud Rules and Monitoring: Review early usage to see if any fraud slipped through. Potentially enable more stringent Radar rules if needed (e.g., require 3DS on all international transactions). Set up monitoring/alerting: e.g., if X payment failures in a row for a user, flag account; if high-risk charge flagged by Stripe, maybe require manual approval (for now, maybe just alert admin).
Logging & Auditing: Enhance logging of all payment events (maybe create an admin dashboard to view payment logs, or at least secure DB tables for it). Make sure we log Stripe event IDs for traceability.
Recurring/Subscription Logic: Parker might consider charging a service fee or subscription for using auto-book (for example, a monthly fee or a per-campaign fee). If that’s planned, Phase 2 could integrate Stripe Billing for subscriptions. However, if “recurring billing logic” refers to charging the same PaymentMethod multiple times (which we already do for multiple campaigns), we should ensure we handle subsequent charges gracefully. Possibly add logic to avoid simultaneous charges on the same card if not intended (though multiple campaigns could legitimately charge around the same time). Also ensure that if a user sets up a recurring campaign (like continuous search) we can repeatedly charge when each booking happens. The architecture already supports multiple charges over time per customer.
Performance & Scaling: Optimize any slow parts. For example, if we find webhook handling slow, consider queueing tasks. Ensure idempotency keys are in use to prevent dupes. If necessary, introduce a job queue for booking steps so that if 100 bookings trigger at once, we handle them without timeouts.
PCI Compliance Check: By Phase 2, we likely have real users, so we will do a PCI DSS review. Using Stripe Elements means we likely just need to attest SAQ A compliance
stripe.com
. We’ll generate the prefilled SAQ A from Stripe’s dashboard (Stripe provides a form for this) and make sure our processes (like annual security training, etc.) are in place. Similarly, ensure GDPR compliance – e.g., update privacy policy to cover how we store Stripe IDs, and implement a way to delete a user’s Stripe data if they delete their Parker account (Stripe API allows customer deletion or at least detaching all payment methods).
Dispute/Chargeback Handling: Create processes to handle Stripe disputes. Likely rare (user could dispute if they forgot about auto-book or are unhappy). We should have a template response (since we have their opt-in and perhaps 3DS, we can usually contest fraud claims successfully). Possibly log disputes in our DB and prevent new bookings for that user until resolved, to limit risk.
Phase 3: Multi-Traveler and Multi-Currency Expansion – Focus: extending functionality to more complex use cases and global users.
Multiple Traveler Profiles: Modify the data model and UI to let a user manage multiple travelers (e.g., family members). Each traveler profile can have its own saved payment method or use the user’s default. Decide if each traveler gets a distinct Stripe Customer. A simple approach: still one Stripe Customer per user (since one person paying) but allow multiple profiles linked to that user. If we anticipate scenarios like corporate accounts where different travelers might be billed to different accounts, we might need multiple Stripe Customers. In either case, adapt the campaign creation flow to select a traveler profile and a payment method for that profile. Ensure the booking info passes the correct traveler data to Duffel while charging the correct payer.
Multi-Currency & Localization: Officially support multiple currencies as first-class. This means showing currency options or auto-detecting based on user location. Ensure our front-end can display and accept budgets in various currencies (and that we handle formatting, e.g., comma vs decimal). On the back-end, extend tests to cover currency conversions. Also, enable relevant currencies in Stripe dashboard. If needed, create separate Stripe accounts for different regions (only if there’s a benefit). But likely one account is fine – Stripe can settle in multiple currencies to our bank or convert.
Alternative Payment Methods: While not explicitly asked, with international users we might consider adding support for alternative payment methods via Stripe (e.g., ACH bank debit for US, SEPA for EU, etc.). However, because auto-booking needs an instant charge capability, credit/debit cards (and perhaps wallets like Apple Pay which ultimately tokenizes a card) are the most suitable. Bank transfers or slower methods wouldn’t work for instant booking. So we might stick to cards, but we could allow Apple Pay/Google Pay on the front-end (Stripe makes it easy to tokenize those as PaymentMethods) in Phase 3 as a user convenience.
Scale and Robustness: By Phase 3, assume we have many users and campaigns. We should consider scaling aspects: partitioning webhook handling if volume is high (maybe Stripe sends many events, but Stripe can handle thousands per second – our architecture using serverless can scale automatically as long as code is efficient). We might integrate a message queue (like if we move booking actions to a queue to be processed asynchronously to ensure no drop). Also implement more metrics – like track how many bookings succeed, how many payment failures, average processing time, etc., to keep an eye on system health.
UI/UX Improvements: With more travelers and options, refine the user experience. For example, allow naming saved cards (“Travel Card” vs “Personal Card”), show card icons, allow direct update of an expired card (Stripe has a feature to update card info in place via Elements). Also, provide clarity in the UI about off-session charges: maybe a setting per campaign “auto-charge enabled (on)” which they can toggle to essentially pause auto-booking without canceling the whole campaign.
Continuous Compliance: As we expand globally, ensure compliance with each region’s laws (GDPR in EU for data, PSD2 for SCA – we covered that, maybe CCPA in California, etc.). Stripe as a processor helps offload a lot of that, but Parker still must handle data responsibly.
Customer Support Tools: By this phase, build admin tools to assist with payments – e.g., an admin can see a user’s saved payment methods (last4) to help debug, or a way to manually trigger a retry or a refund from Parker’s admin panel that calls Stripe API. This is not user-facing but important for operations.
Each phase builds on the previous. The idea is to get a working product quickly (Phase 1), then layer on the more complex but important safeguards (Phase 2), and finally broaden the feature set (Phase 3). This agile approach allows the Warp team to deliver incremental value and incorporate real user feedback – for example, if users demand multi-currency sooner, we can adjust priorities. Throughout all phases, maintaining extensive test coverage and monitoring is key, especially as we introduce changes in Phase 2 and 3 to a live system handling real money. We will also coordinate deployment carefully: e.g., adding webhook endpoints and testing them in dev before pointing Stripe live webhooks to production, migrating database schema with minimal downtime (Supabase migrations are straightforward but we do them in phases if needed, e.g., adding new tables for multiple payment methods without breaking existing single-card logic). By the end of Phase 3, Parker Flight will have a mature, flexible payment infrastructure: able to handle multiple travelers, accept payments from users around the world in their currency of choice, and automatically and securely charge and book flights with minimal friction.
Compliance and Security Considerations
Designing a payment system involves strict adherence to compliance standards and ensuring user data is protected. Parker Flight’s approach leverages Stripe’s compliance to simplify our burden, but we still must address the following:
PCI DSS Compliance: Because we chose Stripe Elements/Payments, Parker does not handle cardholder data directly. All card data entry is done either through Stripe-hosted fields (Elements iframe) or Stripe’s secure servers, meaning card data never touches our servers
stripe.com
. This qualifies our integration as PCI SAQ A – the simplest level of compliance. Stripe is a PCI Level 1 service provider, and our use of them means most PCI requirements (encryption, secure storage, network segregation, etc.) are handled by Stripe
stripe.com
. We still have responsibilities: we must attest annually to PCI (Stripe provides a pre-filled SAQ A form), keep our Stripe integration (js library) updated, and ensure that we never attempt to log or store card details inadvertently. All team members will be trained on PCI compliance basics (like not asking for card info in support tickets, etc.). Our database only holds Stripe IDs and limited info (last4, etc.), which is not considered sensitive card data under PCI. Additionally, our systems (Supabase, Vercel) should be secure (Supabase uses encrypted storage, etc.) and we restrict access to production DB and Stripe keys to essential personnel. We will also enforce TLS everywhere (frontend to backend, backend to Stripe) – which is naturally done via HTTPS.
GDPR and Data Privacy: We will store personal data like user name, email, and possibly traveler passport info (for booking) in our database, and Stripe will also store some (billing info, last4). Under GDPR (and analogous laws), we need to allow users to request deletion of their data. Our design allows this: if a user deletes their Parker account, we will:
Delete or anonymize their personal data in Supabase (Supabase can cascade delete profiles, campaigns, etc.).
For Stripe, we cannot fully delete payment records that were used (for financial record-keeping, Stripe retains charge info). But Stripe allows deletion of a Customer which will also detach and delete their saved PaymentMethods. We will invoke stripe.customers.del(customerId) upon account deletion to remove their data from our active Stripe records. (Stripe might keep some internally for compliance, but it won’t be accessible to us or anyone).
We’ll update our privacy policy to clearly state what we store (e.g., “We store tokens linked to your payment method via Stripe; we do not store your full card details.”) and how users can contact us to exercise data rights. Because we rely on Stripe, we’ll also ensure Stripe’s GDPR compliance (which they have in place as a processor) is addressed in our terms.
Minimization: We only collect what’s necessary (card token, not the card itself; and maybe billing ZIP code if needed for Stripe’s risk checks). We won’t collect extraneous PII related to payments.
Consent for Off-Session Charges: It is both a best practice and a legal requirement (under card network rules and PSD2 in Europe) to obtain the customer’s explicit consent for future charges. We will incorporate a step in the UI (likely when a user starts an auto-booking campaign or saves a card) where they agree to terms allowing Parker to charge their card on their behalf when booking a flight. For example, a checkbox that says: “I authorize Parker Flight to charge my saved payment method for the cost of booked flights up to my specified budget without further approval.” The user must accept this to use auto-booking. We’ll log this consent (could be as simple as a timestamp field in DB or a clause in our Terms of Service that the user agrees to). This covers us in case of disputes and is required for Stripe to treat charges as “Merchant Initiated Transactions (MIT)” with SCA exemption
docs.stripe.com
. We’ll include the frequency (one-time when flight found) and amount (up to budget) in that agreement text, as recommended
docs.stripe.com
.
Stripe Best Practices:
API Versioning: We will lock to a specific Stripe API version (the latest at time of dev) and not upgrade without testing. All our Stripe calls will include our API version to ensure consistent behavior even if Stripe updates their defaults.
Secret Management: Our Stripe secret key and webhook signing secret will be stored securely (e.g., in Supabase Function secrets or Vercel env vars). We’ll restrict who has access. Never expose secret in client code or logs.
Webhook Security: Verify signatures of incoming webhooks
bootstrapped.app
 using the Stripe library to prevent fake events. Also use network allow-list if possible (Stripe IPs) though signature check is usually enough.
Idempotency: Use idempotency keys on all POST requests to Stripe that are not naturally idempotent (like charges) to handle retry safely
bootstrapped.app
.
Error Handling & Monitoring: Use try/catch around Stripe calls and log errors with sufficient detail. Potentially integrate Sentry or similar error tracking for our edge functions to catch any unexpected exceptions.
Testing in Production (safe manner): Initially run some real transactions with our own cards (small $ charges) to verify live mode. Also possibly use Stripe’s “Test Clock” feature for simulating time if we had subscriptions (not directly needed for one-off charges).
Stripe Dashboard Settings: Make sure to enable “Radar for Fraud Teams” (if we have it) or at least review default Radar rules. Enable email alerts for suspicious activity. Turn on Stripe’s email receipt option for charges (so users get an official receipt to their email from Stripe, which we can customize with Parker branding).
3DS Settings: In Stripe dashboard, ensure “Requires 3D Secure if mandated by region” is on (it usually is by default), and consider toggling “3D Secure recommended on high-risk payments” depending on our experience. We might also enable Stripe’s new Checkout or Payment Element in the future if we want Stripe to handle more of this, but for now our custom flow suffices.
Supabase Security:
Use Row-Level Security to ensure users can only read/write their own payment reference info. For instance, the profiles table with stripe_customer_id should have RLS such that only the logged-in user (or service role) can select those fields. The same for campaigns – users see only their campaigns.
The Edge Functions run with service role (full DB access), so we code carefully to only manipulate relevant records.
Ensure our database backups or logs don’t inadvertently contain sensitive info. Stripe IDs are fine, but we ensure no one writes down actual card in any note field. (We won’t even have it, so that’s good).
Limit privileges: Only the backend service should be able to create PaymentIntents. We do not allow any client-side direct Stripe charges (to prevent tampering). The client only ever gets client_secret for SetupIntent and uses publishable key for that purpose, which is safe.
Compliance with Duffel/Travel Regulations:
Duffel may have its own requirements for handling payments (especially if using Duffel Payments, which basically we are, through Stripe). We’ll ensure we abide by their terms – e.g., not storing customer passports in unsecured way, etc. Also for travel, PCI covers the card data; any personal traveler info (PII) we store needs to be protected under privacy laws as well.
We might need to handle VAT or tax for certain jurisdictions if we charge in different currencies – not directly a payment architecture issue but something to be aware of as we expand.
Audit and Logs: We plan to keep logs of all transactions and important events. In case of an audit or incident, we can trace what happened (e.g., user complained “I was charged wrong amount on Jan 5”, we can look up Stripe logs and our DB records to verify the amount and reason). We also ensure clock synchronization on servers (so timestamps are accurate). Supabase and Stripe both provide logs we can rely on.
Service Continuity and Failover: While not a direct compliance issue, it’s a reliability one: our architecture should be tolerant to downtime. If Supabase or our edge functions are down exactly when a booking trigger occurs, we might miss a deal. We mitigate by having re-checks. If Stripe is down (rare), we won’t be able to charge, but we could either queue the booking or hold reservation via Duffel if possible. Planning for these scenarios ensures we meet any SLAs we promise users. We should also communicate in our terms that bookings are not guaranteed if payments fail (to set user expectations correctly).
In conclusion, Parker Flight’s payment system is built with compliance in mind from day one. By using Stripe’s hosted fields and tokenization, we offload the riskiest aspects of PCI compliance
stripe.com
. We respect user privacy by storing minimal info and offering transparency and control (users can delete data, see what payment methods are on file, etc.). We will continuously monitor changes in regulations (for instance, if PSD3 or new card network rules come, or if certain countries require additional authentication like OTP, we will adapt possibly via Stripe’s updates). Our partnership with Stripe means we also inherit their constant improvements in security (e.g., Stripe Radar updates, new fraud signals) without additional effort. The Warp engineering team, following this design, should prioritize security reviews at each phase – perhaps have an external security audit after Phase 2 (when system is stable) to double-check everything. By diligently following these practices, Parker Flight can confidently handle users’ payments, maintaining trust and safety which are critical for a service that automatically spends users’ money to secure them great flight deals.