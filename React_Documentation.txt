React Documentation
===================

This document is for storing React documentation and notes.

---

React Reference Overview
This section provides detailed reference documentation for working with React. For an introduction to React, please visit the Learn section.
The React reference documentation is broken down into functional subsections:
React 
Programmatic React features:
Hooks - Use different React features from your components.
Components - Built-in components that you can use in your JSX.
APIs - APIs that are useful for defining components.
Directives - Provide instructions to bundlers compatible with React Server Components.
React DOM 
React-dom contains features that are only supported for web applications (which run in the browser DOM environment). This section is broken into the following:
Hooks - Hooks for web applications which run in the browser DOM environment.
Components - React supports all of the browser built-in HTML and SVG components.
APIs - The react-dom package contains methods supported only in web applications.
Client APIs - The react-dom/client APIs let you render React components on the client (in the browser).
Server APIs - The react-dom/server APIs let you render React components to HTML on the server.
Rules of React 
React has idioms — or rules — for how to express patterns in a way that is easy to understand and yields high-quality applications:
Components and Hooks must be pure – Purity makes your code easier to understand, debug, and allows React to automatically optimize your components and hooks correctly.
React calls Components and Hooks – React is responsible for rendering components and hooks when necessary to optimize the user experience.
Rules of Hooks – Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called.
Legacy APIs 
Legacy APIs - Exported from the react package, but not recommended for use in newly written code.
Built-in React Hooks
Hooks let you use different React features from your components. You can either use the built-in Hooks or combine them to build your own. This page lists all built-in Hooks in React.

State Hooks 
State lets a component “remember” information like user input. For example, a form component can use state to store the input value, while an image gallery component can use state to store the selected image index.
To add state to a component, use one of these Hooks:
useState declares a state variable that you can update directly.
useReducer declares a state variable with the update logic inside a reducer function.
function ImageGallery() {
 const [index, setIndex] = useState(0);
 // ...

Context Hooks 
Context lets a component receive information from distant parents without passing it as props. For example, your app’s top-level component can pass the current UI theme to all components below, no matter how deep.
useContext reads and subscribes to a context.
function Button() {
 const theme = useContext(ThemeContext);
 // ...

Ref Hooks 
Refs let a component hold some information that isn’t used for rendering, like a DOM node or a timeout ID. Unlike with state, updating a ref does not re-render your component. Refs are an “escape hatch” from the React paradigm. They are useful when you need to work with non-React systems, such as the built-in browser APIs.
useRef declares a ref. You can hold any value in it, but most often it’s used to hold a DOM node.
useImperativeHandle lets you customize the ref exposed by your component. This is rarely used.
function Form() {
 const inputRef = useRef(null);
 // ...

Effect Hooks 
Effects let a component connect to and synchronize with external systems. This includes dealing with network, browser DOM, animations, widgets written using a different UI library, and other non-React code.
useEffect connects a component to an external system.
function ChatRoom({ roomId }) {
 useEffect(() => {
   const connection = createConnection(roomId);
   connection.connect();
   return () => connection.disconnect();
 }, [roomId]);
 // ...
Effects are an “escape hatch” from the React paradigm. Don’t use Effects to orchestrate the data flow of your application. If you’re not interacting with an external system, you might not need an Effect.
There are two rarely used variations of useEffect with differences in timing:
useLayoutEffect fires before the browser repaints the screen. You can measure layout here.
useInsertionEffect fires before React makes changes to the DOM. Libraries can insert dynamic CSS here.

Performance Hooks 
A common way to optimize re-rendering performance is to skip unnecessary work. For example, you can tell React to reuse a cached calculation or to skip a re-render if the data has not changed since the previous render.
To skip calculations and unnecessary re-rendering, use one of these Hooks:
useMemo lets you cache the result of an expensive calculation.
useCallback lets you cache a function definition before passing it down to an optimized component.
function TodoList({ todos, tab, theme }) {
 const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);
 // ...
}
Sometimes, you can’t skip re-rendering because the screen actually needs to update. In that case, you can improve performance by separating blocking updates that must be synchronous (like typing into an input) from non-blocking updates which don’t need to block the user interface (like updating a chart).
To prioritize rendering, use one of these Hooks:
useTransition lets you mark a state transition as non-blocking and allow other updates to interrupt it.
useDeferredValue lets you defer updating a non-critical part of the UI and let other parts update first.

Other Hooks 
These Hooks are mostly useful to library authors and aren’t commonly used in the application code.
useDebugValue lets you customize the label React DevTools displays for your custom Hook.
useId lets a component associate a unique ID with itself. Typically used with accessibility APIs.
useSyncExternalStore lets a component subscribe to an external store.
useActionState allows you to manage state of actions.

Your own Hooks 
You can also define your own custom Hooks as JavaScript functions.

useActionState
useActionState is a Hook that allows you to update state based on the result of a form action.
const [state, formAction, isPending] = useActionState(fn, initialState, permalink?);
Note
In earlier React Canary versions, this API was part of React DOM and called useFormState.
Reference
useActionState(action, initialState, permalink?)
Usage
Using information returned by a form action
Troubleshooting
My action can no longer read the submitted form data

Reference 
useActionState(action, initialState, permalink?) 
Call useActionState at the top level of your component to create component state that is updated when a form action is invoked. You pass useActionState an existing form action function as well as an initial state, and it returns a new action that you use in your form, along with the latest form state and whether the Action is still pending. The latest form state is also passed to the function that you provided.
import { useActionState } from "react";

async function increment(previousState, formData) {
 return previousState + 1;
}

function StatefulForm({}) {
 const [state, formAction] = useActionState(increment, 0);
 return (
   <form>
     {state}
     <button formAction={formAction}>Increment</button>
   </form>
 )
}
The form state is the value returned by the action when the form was last submitted. If the form has not yet been submitted, it is the initial state that you pass.
If used with a Server Function, useActionState allows the server’s response from submitting the form to be shown even before hydration has completed.
See more examples below.
Parameters 
fn: The function to be called when the form is submitted or button pressed. When the function is called, it will receive the previous state of the form (initially the initialState that you pass, subsequently its previous return value) as its initial argument, followed by the arguments that a form action normally receives.
initialState: The value you want the state to be initially. It can be any serializable value. This argument is ignored after the action is first invoked.
optional permalink: A string containing the unique page URL that this form modifies. For use on pages with dynamic content (eg: feeds) in conjunction with progressive enhancement: if fn is a server function and the form is submitted before the JavaScript bundle loads, the browser will navigate to the specified permalink URL, rather than the current page’s URL. Ensure that the same form component is rendered on the destination page (including the same action fn and permalink) so that React knows how to pass the state through. Once the form has been hydrated, this parameter has no effect.
Returns 
useActionState returns an array with the following values:
The current state. During the first render, it will match the initialState you have passed. After the action is invoked, it will match the value returned by the action.
A new action that you can pass as the action prop to your form component or formAction prop to any button component within the form. The action can also be called manually within startTransition.
The isPending flag that tells you whether there is a pending Transition.
Caveats 
When used with a framework that supports React Server Components, useActionState lets you make forms interactive before JavaScript has executed on the client. When used without Server Components, it is equivalent to component local state.
The function passed to useActionState receives an extra argument, the previous or initial state, as its first argument. This makes its signature different than if it were used directly as a form action without using useActionState.

Usage 
Using information returned by a form action 
Call useActionState at the top level of your component to access the return value of an action from the last time a form was submitted.
import { useActionState } from 'react';
import { action } from './actions.js';

function MyComponent() {
 const [state, formAction] = useActionState(action, null);
 // ...
 return (
   <form action={formAction}>
     {/* ... */}
   </form>
 );
}
useActionState returns an array with the following items:
The current state of the form, which is initially set to the initial state you provided, and after the form is submitted is set to the return value of the action you provided.
A new action that you pass to <form> as its action prop or call manually within startTransition.
A pending state that you can utilise while your action is processing.
When the form is submitted, the action function that you provided will be called. Its return value will become the new current state of the form.
The action that you provide will also receive a new first argument, namely the current state of the form. The first time the form is submitted, this will be the initial state you provided, while with subsequent submissions, it will be the return value from the last time the action was called. The rest of the arguments are the same as if useActionState had not been used.
function action(currentState, formData) {
 // ...
 return 'next state';
}
Display information after submitting a form
1. Display form errors2. Display structured information after submitting a form
Example 1 of 2: Display form errors 
To display messages such as an error message or toast that’s returned by a Server Function, wrap the action in a call to useActionState.
App.jsactions.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
import { useActionState, useState } from "react";
import { addToCart } from "./actions.js";

function AddToCartForm({itemID, itemTitle}) {
 const [message, formAction, isPending] = useActionState(addToCart, null);
 return (
   <form action={formAction}>
     <h2>{itemTitle}</h2>
     <input type="hidden" name="itemID" value={itemID} />
     <button type="submit">Add to Cart</button>
     {isPending ? "Loading..." : message}
   </form>
 );
}

export default function App() {
 return (
   <>
     <AddToCartForm itemID="1" itemTitle="JavaScript: The Definitive Guide" />
     <AddToCartForm itemID="2" itemTitle="JavaScript: The Good Parts" />
   </>
 )
}

Show more
Next Example
Troubleshooting 
My action can no longer read the submitted form data 
When you wrap an action with useActionState, it gets an extra argument as its first argument. The submitted form data is therefore its second argument instead of its first as it would usually be. The new first argument that gets added is the current state of the form.
function action(currentState, formData) {
 // ...
}
PreviousHooks

useCallback
useCallback is a React Hook that lets you cache a function definition between re-renders.
const cachedFn = useCallback(fn, dependencies)
Reference
useCallback(fn, dependencies)
Usage
Skipping re-rendering of components
Updating state from a memoized callback
Preventing an Effect from firing too often
Optimizing a custom Hook
Troubleshooting
Every time my component renders, useCallback returns a different function
I need to call useCallback for each list item in a loop, but it’s not allowed

Reference 
useCallback(fn, dependencies) 
Call useCallback at the top level of your component to cache a function definition between re-renders:
import { useCallback } from 'react';

export default function ProductPage({ productId, referrer, theme }) {
 const handleSubmit = useCallback((orderDetails) => {
   post('/product/' + productId + '/buy', {
     referrer,
     orderDetails,
   });
 }, [productId, referrer]);
See more examples below.
Parameters 
fn: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function again if the dependencies have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it.
dependencies: The list of all reactive values referenced inside of the fn code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison algorithm.
Returns 
On the initial render, useCallback returns the fn function you have passed.
During subsequent renders, it will either return an already stored fn  function from the last render (if the dependencies haven’t changed), or return the fn function you have passed during this render.
Caveats 
useCallback is a Hook, so you can only call it at the top level of your component or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.
React will not throw away the cached function unless there is a specific reason to do that. For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cache—for example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should match your expectations if you rely on useCallback as a performance optimization. Otherwise, a state variable or a ref may be more appropriate.

Usage 
Skipping re-rendering of components 
When you optimize rendering performance, you will sometimes need to cache the functions that you pass to child components. Let’s first look at the syntax for how to do this, and then see in which cases it’s useful.
To cache a function between re-renders of your component, wrap its definition into the useCallback Hook:
import { useCallback } from 'react';

function ProductPage({ productId, referrer, theme }) {
 const handleSubmit = useCallback((orderDetails) => {
   post('/product/' + productId + '/buy', {
     referrer,
     orderDetails,
   });
 }, [productId, referrer]);
 // ...
You need to pass two things to useCallback:
A function definition that you want to cache between re-renders.
A list of dependencies including every value within your component that’s used inside your function.
On the initial render, the returned function you’ll get from useCallback will be the function you passed.
On the following renders, React will compare the dependencies with the dependencies you passed during the previous render. If none of the dependencies have changed (compared with Object.is), useCallback will return the same function as before. Otherwise, useCallback will return the function you passed on this render.
In other words, useCallback caches a function between re-renders until its dependencies change.
Let’s walk through an example to see when this is useful.
Say you’re passing a handleSubmit function down from the ProductPage to the ShippingForm component:
function ProductPage({ productId, referrer, theme }) {
 // ...
 return (
   <div className={theme}>
     <ShippingForm onSubmit={handleSubmit} />
   </div>
 );
You’ve noticed that toggling the theme prop freezes the app for a moment, but if you remove <ShippingForm /> from your JSX, it feels fast. This tells you that it’s worth trying to optimize the ShippingForm component.
By default, when a component re-renders, React re-renders all of its children recursively. This is why, when ProductPage re-renders with a different theme, the ShippingForm component also re-renders. This is fine for components that don’t require much calculation to re-render. But if you verified a re-render is slow, you can tell ShippingForm to skip re-rendering when its props are the same as on last render by wrapping it in memo:
import { memo } from 'react';

const ShippingForm = memo(function ShippingForm({ onSubmit }) {
 // ...
});
With this change, ShippingForm will skip re-rendering if all of its props are the same as on the last render. This is when caching a function becomes important! Let’s say you defined handleSubmit without useCallback:
function ProductPage({ productId, referrer, theme }) {
 // Every time the theme changes, this will be a different function...
 function handleSubmit(orderDetails) {
   post('/product/' + productId + '/buy', {
     referrer,
     orderDetails,
   });
 }

 return (
   <div className={theme}>
     {/* ... so ShippingForm's props will never be the same, and it will re-render every time */}
     <ShippingForm onSubmit={handleSubmit} />
   </div>
 );
}
In JavaScript, a function () {} or () => {} always creates a different function, similar to how the {} object literal always creates a new object. Normally, this wouldn’t be a problem, but it means that ShippingForm props will never be the same, and your memo optimization won’t work. This is where useCallback comes in handy:
function ProductPage({ productId, referrer, theme }) {
 // Tell React to cache your function between re-renders...
 const handleSubmit = useCallback((orderDetails) => {
   post('/product/' + productId + '/buy', {
     referrer,
     orderDetails,
   });
 }, [productId, referrer]); // ...so as long as these dependencies don't change...

 return (
   <div className={theme}>
     {/* ...ShippingForm will receive the same props and can skip re-rendering */}
     <ShippingForm onSubmit={handleSubmit} />
   </div>
 );
}
By wrapping handleSubmit in useCallback, you ensure that it’s the same function between the re-renders (until dependencies change). You don’t have to wrap a function in useCallback unless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped in memo, and this lets it skip re-rendering. There are other reasons you might need useCallback which are described further on this page.
Note
You should only rely on useCallback as a performance optimization. If your code doesn’t work without it, find the underlying problem and fix it first. Then you may add useCallback back.
Deep Dive
How is useCallback related to useMemo? 
Show Details




























Deep Dive
Should you add useCallback everywhere? 
Show Details














The difference between useCallback and declaring a function directly
1. Skipping re-rendering with useCallback and memo2. Always re-rendering a component
Example 1 of 2: Skipping re-rendering with useCallback and memo 
In this example, the ShippingForm component is artificially slowed down so that you can see what happens when a React component you’re rendering is genuinely slow. Try incrementing the counter and toggling the theme.
Incrementing the counter feels slow because it forces the slowed down ShippingForm to re-render. That’s expected because the counter has changed, and so you need to reflect the user’s new choice on the screen.
Next, try toggling the theme. Thanks to useCallback together with memo, it’s fast despite the artificial slowdown! ShippingForm skipped re-rendering because the handleSubmit function has not changed. The handleSubmit function has not changed because both productId and referrer (your useCallback dependencies) haven’t changed since last render.
App.jsProductPage.jsShippingForm.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
import { useCallback } from 'react';
import ShippingForm from './ShippingForm.js';

export default function ProductPage({ productId, referrer, theme }) {
 const handleSubmit = useCallback((orderDetails) => {
   post('/product/' + productId + '/buy', {
     referrer,
     orderDetails,
   });
 }, [productId, referrer]);

 return (
   <div className={theme}>
     <ShippingForm onSubmit={handleSubmit} />
   </div>
 );
}

function post(url, data) {
 // Imagine this sends a request...
 console.log('POST /' + url);
 console.log(data);
}

Show more
Next Example

Updating state from a memoized callback 
Sometimes, you might need to update state based on previous state from a memoized callback.
This handleAddTodo function specifies todos as a dependency because it computes the next todos from it:
function TodoList() {
 const [todos, setTodos] = useState([]);

 const handleAddTodo = useCallback((text) => {
   const newTodo = { id: nextId++, text };
   setTodos([...todos, newTodo]);
 }, [todos]);
 // ...
You’ll usually want memoized functions to have as few dependencies as possible. When you read some state only to calculate the next state, you can remove that dependency by passing an updater function instead:
function TodoList() {
 const [todos, setTodos] = useState([]);

 const handleAddTodo = useCallback((text) => {
   const newTodo = { id: nextId++, text };
   setTodos(todos => [...todos, newTodo]);
 }, []); // ✅ No need for the todos dependency
 // ...
Here, instead of making todos a dependency and reading it inside, you pass an instruction about how to update the state (todos => [...todos, newTodo]) to React. Read more about updater functions.

Preventing an Effect from firing too often 
Sometimes, you might want to call a function from inside an Effect:
function ChatRoom({ roomId }) {
 const [message, setMessage] = useState('');

 function createOptions() {
   return {
     serverUrl: 'https://localhost:1234',
     roomId: roomId
   };
 }

 useEffect(() => {
   const options = createOptions();
   const connection = createConnection(options);
   connection.connect();
   // ...
This creates a problem. Every reactive value must be declared as a dependency of your Effect. However, if you declare createOptions as a dependency, it will cause your Effect to constantly reconnect to the chat room:
 useEffect(() => {
   const options = createOptions();
   const connection = createConnection(options);
   connection.connect();
   return () => connection.disconnect();
 }, [createOptions]); // 🔴 Problem: This dependency changes on every render
 // ...
To solve this, you can wrap the function you need to call from an Effect into useCallback:
function ChatRoom({ roomId }) {
 const [message, setMessage] = useState('');

 const createOptions = useCallback(() => {
   return {
     serverUrl: 'https://localhost:1234',
     roomId: roomId
   };
 }, [roomId]); // ✅ Only changes when roomId changes

 useEffect(() => {
   const options = createOptions();
   const connection = createConnection(options);
   connection.connect();
   return () => connection.disconnect();
 }, [createOptions]); // ✅ Only changes when createOptions changes
 // ...
This ensures that the createOptions function is the same between re-renders if the roomId is the same. However, it’s even better to remove the need for a function dependency. Move your function inside the Effect:
function ChatRoom({ roomId }) {
 const [message, setMessage] = useState('');

 useEffect(() => {
   function createOptions() { // ✅ No need for useCallback or function dependencies!
     return {
       serverUrl: 'https://localhost:1234',
       roomId: roomId
     };
   }

   const options = createOptions();
   const connection = createConnection(options);
   connection.connect();
   return () => connection.disconnect();
 }, [roomId]); // ✅ Only changes when roomId changes
 // ...
Now your code is simpler and doesn’t need useCallback. Learn more about removing Effect dependencies.

Optimizing a custom Hook 
If you’re writing a custom Hook, it’s recommended to wrap any functions that it returns into useCallback:
function useRouter() {
 const { dispatch } = useContext(RouterStateContext);

 const navigate = useCallback((url) => {
   dispatch({ type: 'navigate', url });
 }, [dispatch]);

 const goBack = useCallback(() => {
   dispatch({ type: 'back' });
 }, [dispatch]);

 return {
   navigate,
   goBack,
 };
}
This ensures that the consumers of your Hook can optimize their own code when needed.

Troubleshooting 
Every time my component renders, useCallback returns a different function 
Make sure you’ve specified the dependency array as a second argument!
If you forget the dependency array, useCallback will return a new function every time:
function ProductPage({ productId, referrer }) {
 const handleSubmit = useCallback((orderDetails) => {
   post('/product/' + productId + '/buy', {
     referrer,
     orderDetails,
   });
 }); // 🔴 Returns a new function every time: no dependency array
 // ...
This is the corrected version passing the dependency array as a second argument:
function ProductPage({ productId, referrer }) {
 const handleSubmit = useCallback((orderDetails) => {
   post('/product/' + productId + '/buy', {
     referrer,
     orderDetails,
   });
 }, [productId, referrer]); // ✅ Does not return a new function unnecessarily
 // ...
If this doesn’t help, then the problem is that at least one of your dependencies is different from the previous render. You can debug this problem by manually logging your dependencies to the console:
 const handleSubmit = useCallback((orderDetails) => {
   // ..
 }, [productId, referrer]);

 console.log([productId, referrer]);
You can then right-click on the arrays from different re-renders in the console and select “Store as a global variable” for both of them. Assuming the first one got saved as temp1 and the second one got saved as temp2, you can then use the browser console to check whether each dependency in both arrays is the same:
Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?
Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?
Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ...
When you find which dependency is breaking memoization, either find a way to remove it, or memoize it as well.

I need to call useCallback for each list item in a loop, but it’s not allowed 
Suppose the Chart component is wrapped in memo. You want to skip re-rendering every Chart in the list when the ReportList component re-renders. However, you can’t call useCallback in a loop:
function ReportList({ items }) {
 return (
   <article>
     {items.map(item => {
       // 🔴 You can't call useCallback in a loop like this:
       const handleClick = useCallback(() => {
         sendReport(item)
       }, [item]);

       return (
         <figure key={item.id}>
           <Chart onClick={handleClick} />
         </figure>
       );
     })}
   </article>
 );
}
Instead, extract a component for an individual item, and put useCallback there:
function ReportList({ items }) {
 return (
   <article>
     {items.map(item =>
       <Report key={item.id} item={item} />
     )}
   </article>
 );
}

function Report({ item }) {
 // ✅ Call useCallback at the top level:
 const handleClick = useCallback(() => {
   sendReport(item)
 }, [item]);

 return (
   <figure>
     <Chart onClick={handleClick} />
   </figure>
 );
}
Alternatively, you could remove useCallback in the last snippet and instead wrap Report itself in memo. If the item prop does not change, Report will skip re-rendering, so Chart will skip re-rendering too:
function ReportList({ items }) {
 // ...
}

const Report = memo(function Report({ item }) {
 function handleClick() {
   sendReport(item);
 }

 return (
   <figure>
     <Chart onClick={handleClick} />
   </figure>
 );
});

SomeContext: The context that you’ve previously created with createContext. The context itself does not hold the information, it only represents the kind of information you can provide or read from components.
Returns 
useContext returns the context value for the calling component. It is determined as the value passed to the closest SomeContext above the calling component in the tree. If there is no such provider, then the returned value will be the defaultValue you have passed to createContext for that context. The returned value is always up-to-date. React automatically re-renders components that read some context if it changes.
Caveats 
useContext() call in a component is not affected by providers returned from the same component. The corresponding <Context> needs to be above the component doing the useContext() call.
React automatically re-renders all the children that use a particular context starting from the provider that receives a different value. The previous and the next values are compared with the Object.is comparison. Skipping re-renders with memo does not prevent the children receiving fresh context values.
If your build system produces duplicates modules in the output (which can happen with symlinks), this can break context. Passing something via context only works if SomeContext that you use to provide context and SomeContext that you use to read it are exactly the same object, as determined by a === comparison.

Usage 
Passing data deeply into the tree 
Call useContext at the top level of your component to read and subscribe to context.
import { useContext } from 'react';

function Button() {
 const theme = useContext(ThemeContext);
 // ...
useContext returns the context value for the context you passed. To determine the context value, React searches the component tree and finds the closest context provider above for that particular context.
To pass context to a Button, wrap it or one of its parent components into the corresponding context provider:
function MyPage() {
 return (
   <ThemeContext value="dark">
     <Form />
   </ThemeContext>
 );
}

function Form() {
 // ... renders buttons inside ...
}
It doesn’t matter how many layers of components there are between the provider and the Button. When a Button anywhere inside of Form calls useContext(ThemeContext), it will receive "dark" as the value.
Pitfall
useContext() always looks for the closest provider above the component that calls it. It searches upwards and does not consider providers in the component from which you’re calling useContext().
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
import { createContext, useContext } from 'react';

const ThemeContext = createContext(null);

export default function MyApp() {
 return (
   <ThemeContext value="dark">
     <Form />
   </ThemeContext>
 )
}

function Form() {
 return (
   <Panel title="Welcome">
     <Button>Sign up</Button>
     <Button>Log in</Button>
   </Panel>
 );
}

function Panel({ title, children }) {
 const theme = useContext(ThemeContext);
 const className = 'panel-' + theme;
 return (
   <section className={className}>
     <h1>{title}</h1>
     {children}
   </section>
 )
}

function Button({ children }) {
 const theme = useContext(ThemeContext);
 const className = 'button-' + theme;
 return (
Show more

Updating data passed via context 
Often, you’ll want the context to change over time. To update context, combine it with state. Declare a state variable in the parent component, and pass the current state down as the context value to the provider.
function MyPage() {
 const [theme, setTheme] = useState('dark');
 return (
   <ThemeContext value={theme}>
     <Form />
     <Button onClick={() => {
       setTheme('light');
     }}>
       Switch to light theme
     </Button>
   </ThemeContext>
 );
}
Now any Button inside of the provider will receive the current theme value. If you call setTheme to update the theme value that you pass to the provider, all Button components will re-render with the new 'light' value.
Examples of updating context
1. Updating a value via context2. Updating an object via context3. Multiple contexts4. Extracting providers to a component5. Scaling up with context and a reducer
Example 1 of 5: Updating a value via context 
In this example, the MyApp component holds a state variable which is then passed to the ThemeContext provider. Checking the “Dark mode” checkbox updates the state. Changing the provided value re-renders all the components using that context.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
import { createContext, useContext, useState } from 'react';

const ThemeContext = createContext(null);

export default function MyApp() {
 const [theme, setTheme] = useState('light');
 return (
   <ThemeContext value={theme}>
     <Form />
     <label>
       <input
         type="checkbox"
         checked={theme === 'dark'}
         onChange={(e) => {
           setTheme(e.target.checked ? 'dark' : 'light')
         }}
       />
       Use dark mode
     </label>
   </ThemeContext>
 )
}

function Form({ children }) {
 return (
   <Panel title="Welcome">
     <Button>Sign up</Button>
     <Button>Log in</Button>
   </Panel>
 );
}

function Panel({ title, children }) {
 const theme = useContext(ThemeContext);
 const className = 'panel-' + theme;
 return (
Show more
Note that value="dark" passes the "dark" string, but value={theme} passes the value of the JavaScript theme variable with JSX curly braces. Curly braces also let you pass context values that aren’t strings.
Next Example

Specifying a fallback default value 
If React can’t find any providers of that particular context in the parent tree, the context value returned by useContext() will be equal to the default value that you specified when you created that context:
const ThemeContext = createContext(null);
The default value never changes. If you want to update context, use it with state as described above.
Often, instead of null, there is some more meaningful value you can use as a default, for example:
const ThemeContext = createContext('light');
This way, if you accidentally render some component without a corresponding provider, it won’t break. This also helps your components work well in a test environment without setting up a lot of providers in the tests.
In the example below, the “Toggle theme” button is always light because it’s outside any theme context provider and the default context theme value is 'light'. Try editing the default theme to be 'dark'.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
import { createContext, useContext, useState } from 'react';

const ThemeContext = createContext('light');

export default function MyApp() {
 const [theme, setTheme] = useState('light');
 return (
   <>
     <ThemeContext value={theme}>
       <Form />
     </ThemeContext>
     <Button onClick={() => {
       setTheme(theme === 'dark' ? 'light' : 'dark');
     }}>
       Toggle theme
     </Button>
   </>
 )
}

function Form({ children }) {
 return (
   <Panel title="Welcome">
     <Button>Sign up</Button>
     <Button>Log in</Button>
   </Panel>
 );
}

function Panel({ title, children }) {
 const theme = useContext(ThemeContext);
 const className = 'panel-' + theme;
 return (
   <section className={className}>
     <h1>{title}</h1>
     {children}
Show more

Overriding context for a part of the tree 
You can override the context for a part of the tree by wrapping that part in a provider with a different value.
<ThemeContext value="dark">
 ...
 <ThemeContext value="light">
   <Footer />
 </ThemeContext>
 ...
</ThemeContext>
You can nest and override providers as many times as you need.
Examples of overriding context
1. Overriding a theme2. Automatically nested headings
Example 1 of 2: Overriding a theme 
Here, the button inside the Footer receives a different context value ("light") than the buttons outside ("dark").
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
import { createContext, useContext } from 'react';

const ThemeContext = createContext(null);

export default function MyApp() {
 return (
   <ThemeContext value="dark">
     <Form />
   </ThemeContext>
 )
}

function Form() {
 return (
   <Panel title="Welcome">
     <Button>Sign up</Button>
     <Button>Log in</Button>
     <ThemeContext value="light">
       <Footer />
     </ThemeContext>
   </Panel>
 );
}

function Footer() {
 return (
   <footer>
     <Button>Settings</Button>
   </footer>
 );
}

function Panel({ title, children }) {
 const theme = useContext(ThemeContext);
 const className = 'panel-' + theme;
 return (
Show more
Next Example

Optimizing re-renders when passing objects and functions 
You can pass any values via context, including objects and functions.
function MyApp() {
 const [currentUser, setCurrentUser] = useState(null);

 function login(response) {
   storeCredentials(response.credentials);
   setCurrentUser(response.user);
 }

 return (
   <AuthContext value={{ currentUser, login }}>
     <Page />
   </AuthContext>
 );
}
Here, the context value is a JavaScript object with two properties, one of which is a function. Whenever MyApp re-renders (for example, on a route update), this will be a different object pointing at a different function, so React will also have to re-render all components deep in the tree that call useContext(AuthContext).
In smaller apps, this is not a problem. However, there is no need to re-render them if the underlying data, like currentUser, has not changed. To help React take advantage of that fact, you may wrap the login function with useCallback and wrap the object creation into useMemo. This is a performance optimization:
import { useCallback, useMemo } from 'react';

function MyApp() {
 const [currentUser, setCurrentUser] = useState(null);

 const login = useCallback((response) => {
   storeCredentials(response.credentials);
   setCurrentUser(response.user);
 }, []);

 const contextValue = useMemo(() => ({
   currentUser,
   login
 }), [currentUser, login]);

 return (
   <AuthContext value={contextValue}>
     <Page />
   </AuthContext>
 );
}
As a result of this change, even if MyApp needs to re-render, the components calling useContext(AuthContext) won’t need to re-render unless currentUser has changed.
Read more about useMemo and useCallback.

Troubleshooting 
My component doesn’t see the value from my provider 
There are a few common ways that this can happen:
You’re rendering <SomeContext> in the same component (or below) as where you’re calling useContext(). Move <SomeContext> above and outside the component calling useContext().
You may have forgotten to wrap your component with <SomeContext>, or you might have put it in a different part of the tree than you thought. Check whether the hierarchy is right using React DevTools.
You might be running into some build issue with your tooling that causes SomeContext as seen from the providing component and SomeContext as seen by the reading component to be two different objects. This can happen if you use symlinks, for example. You can verify this by assigning them to globals like window.SomeContext1 and window.SomeContext2 and then checking whether window.SomeContext1 === window.SomeContext2 in the console. If they’re not the same, fix that issue on the build tool level.
I am always getting undefined from my context although the default value is different 
You might have a provider without a value in the tree:
// 🚩 Doesn't work: no value prop
<ThemeContext>
  <Button />
</ThemeContext>
If you forget to specify value, it’s like passing value={undefined}.
You may have also mistakingly used a different prop name by mistake:
// 🚩 Doesn't work: prop should be called "value"
<ThemeContext theme={theme}>
  <Button />
</ThemeContext>
In both of these cases you should see a warning from React in the console. To fix them, call the prop value:
// ✅ Passing the value prop
<ThemeContext value={theme}>
  <Button />
</ThemeContext>
Note that the default value from your createContext(defaultValue) call is only used if there is no matching provider above at all. If there is a <SomeContext value={undefined}> component somewhere in the parent tree, the component calling useContext(SomeContext) will receive undefined as the context value.
useDebugValue
useDebugValue is a React Hook that lets you add a label to a custom Hook in React DevTools.
useDebugValue(value, format?)
Reference
useDebugValue(value, format?)
Usage
Adding a label to a custom Hook
Deferring formatting of a debug value

Reference 
useDebugValue(value, format?) 
Call useDebugValue at the top level of your custom Hook to display a readable debug value:
import { useDebugValue } from 'react';

function useOnlineStatus() {
 // ...
 useDebugValue(isOnline ? 'Online' : 'Offline');
 // ...
}
See more examples below.
Parameters 
value: The value you want to display in React DevTools. It can have any type.
optional format: A formatting function. When the component is inspected, React DevTools will call the formatting function with the value as the argument, and then display the returned formatted value (which may have any type). If you don’t specify the formatting function, the original value itself will be displayed.
Returns 
useDebugValue does not return anything.
Usage 
Adding a label to a custom Hook 
Call useDebugValue at the top level of your custom Hook to display a readable debug value for React DevTools.
import { useDebugValue } from 'react';

function useOnlineStatus() {
 // ...
 useDebugValue(isOnline ? 'Online' : 'Offline');
 // ...
}
This gives components calling useOnlineStatus a label like OnlineStatus: "Online" when you inspect them:

Without the useDebugValue call, only the underlying data (in this example, true) would be displayed.
App.jsuseOnlineStatus.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
import { useSyncExternalStore, useDebugValue } from 'react';

export function useOnlineStatus() {
 const isOnline = useSyncExternalStore(subscribe, () => navigator.onLine, () => true);
 useDebugValue(isOnline ? 'Online' : 'Offline');
 return isOnline;
}

function subscribe(callback) {
 window.addEventListener('online', callback);
 window.addEventListener('offline', callback);
 return () => {
   window.removeEventListener('online', callback);
   window.removeEventListener('offline', callback);
 };
}

Show more
Note
Don’t add debug values to every custom Hook. It’s most valuable for custom Hooks that are part of shared libraries and that have a complex internal data structure that’s difficult to inspect.

Deferring formatting of a debug value 
You can also pass a formatting function as the second argument to useDebugValue:
useDebugValue(date, date => date.toDateString());
Your formatting function will receive the debug value as a parameter and should return a formatted display value. When your component is inspected, React DevTools will call this function and display its result.
This lets you avoid running potentially expensive formatting logic unless the component is actually inspected. For example, if date is a Date value, this avoids calling toDateString() on it for every render.
useDeferredValue
useDeferredValue is a React Hook that lets you defer updating a part of the UI.
const deferredValue = useDeferredValue(value)
Reference
useDeferredValue(value, initialValue?)
Usage
Showing stale content while fresh content is loading
Indicating that the content is stale
Deferring re-rendering for a part of the UI

Reference 
useDeferredValue(value, initialValue?) 
Call useDeferredValue at the top level of your component to get a deferred version of that value.
import { useState, useDeferredValue } from 'react';

function SearchPage() {
 const [query, setQuery] = useState('');
 const deferredQuery = useDeferredValue(query);
 // ...
}
See more examples below.
Parameters 
value: The value you want to defer. It can have any type.
optional initialValue: A value to use during the initial render of a component. If this option is omitted, useDeferredValue will not defer during the initial render, because there’s no previous version of value that it can render instead.
Returns 
currentValue: During the initial render, the returned deferred value will be the initialValue, or the same as the value you provided. During updates, React will first attempt a re-render with the old value (so it will return the old value), and then try another re-render in the background with the new value (so it will return the updated value).
Caveats 
When an update is inside a Transition, useDeferredValue always returns the new value and does not spawn a deferred render, since the update is already deferred.
The values you pass to useDeferredValue should either be primitive values (like strings and numbers) or objects created outside of rendering. If you create a new object during rendering and immediately pass it to useDeferredValue, it will be different on every render, causing unnecessary background re-renders.
When useDeferredValue receives a different value (compared with Object.is), in addition to the current render (when it still uses the previous value), it schedules a re-render in the background with the new value. The background re-render is interruptible: if there’s another update to the value, React will restart the background re-render from scratch. For example, if the user is typing into an input faster than a chart receiving its deferred value can re-render, the chart will only re-render after the user stops typing.
useDeferredValue is integrated with <Suspense>. If the background update caused by a new value suspends the UI, the user will not see the fallback. They will see the old deferred value until the data loads.
useDeferredValue does not by itself prevent extra network requests.
There is no fixed delay caused by useDeferredValue itself. As soon as React finishes the original re-render, React will immediately start working on the background re-render with the new deferred value. Any updates caused by events (like typing) will interrupt the background re-render and get prioritized over it.
The background re-render caused by useDeferredValue does not fire Effects until it’s committed to the screen. If the background re-render suspends, its Effects will run after the data loads and the UI updates.

Usage 
Showing stale content while fresh content is loading 
Call useDeferredValue at the top level of your component to defer updating some part of your UI.
import { useState, useDeferredValue } from 'react';

function SearchPage() {
 const [query, setQuery] = useState('');
 const deferredQuery = useDeferredValue(query);
 // ...
}
During the initial render, the deferred value will be the same as the value you provided.
During updates, the deferred value will “lag behind” the latest value. In particular, React will first re-render without updating the deferred value, and then try to re-render with the newly received value in the background.
Let’s walk through an example to see when this is useful.
Note
This example assumes you use a Suspense-enabled data source:
Data fetching with Suspense-enabled frameworks like Relay and Next.js
Lazy-loading component code with lazy
Reading the value of a Promise with use
Learn more about Suspense and its limitations.
In this example, the SearchResults component suspends while fetching the search results. Try typing "a", waiting for the results, and then editing it to "ab". The results for "a" get replaced by the loading fallback.
App.jsSearchResults.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
import { Suspense, useState } from 'react';
import SearchResults from './SearchResults.js';

export default function App() {
 const [query, setQuery] = useState('');
 return (
   <>
     <label>
       Search albums:
       <input value={query} onChange={e => setQuery(e.target.value)} />
     </label>
     <Suspense fallback={<h2>Loading...</h2>}>
       <SearchResults query={query} />
     </Suspense>
   </>
 );
}

Show more
A common alternative UI pattern is to defer updating the list of results and to keep showing the previous results until the new results are ready. Call useDeferredValue to pass a deferred version of the query down:
export default function App() {
 const [query, setQuery] = useState('');
 const deferredQuery = useDeferredValue(query);
 return (
   <>
     <label>
       Search albums:
       <input value={query} onChange={e => setQuery(e.target.value)} />
     </label>
     <Suspense fallback={<h2>Loading...</h2>}>
       <SearchResults query={deferredQuery} />
     </Suspense>
   </>
 );
}
The query will update immediately, so the input will display the new value. However, the deferredQuery will keep its previous value until the data has loaded, so SearchResults will show the stale results for a bit.
Enter "a" in the example below, wait for the results to load, and then edit the input to "ab". Notice how instead of the Suspense fallback, you now see the stale result list until the new results have loaded:
App.jsSearchResults.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
import { Suspense, useState, useDeferredValue } from 'react';
import SearchResults from './SearchResults.js';

export default function App() {
 const [query, setQuery] = useState('');
 const deferredQuery = useDeferredValue(query);
 return (
   <>
     <label>
       Search albums:
       <input value={query} onChange={e => setQuery(e.target.value)} />
     </label>
     <Suspense fallback={<h2>Loading...</h2>}>
       <SearchResults query={deferredQuery} />
     </Suspense>
   </>
 );
}

Show more
Deep Dive
How does deferring a value work under the hood? 
Hide Details
You can think of it as happening in two steps:
First, React re-renders with the new query ("ab") but with the old deferredQuery (still "a"). The deferredQuery value, which you pass to the result list, is deferred: it “lags behind” the query value.
In the background, React tries to re-render with both query and deferredQuery updated to "ab". If this re-render completes, React will show it on the screen. However, if it suspends (the results for "ab" have not loaded yet), React will abandon this rendering attempt, and retry this re-render again after the data has loaded. The user will keep seeing the stale deferred value until the data is ready.
The deferred “background” rendering is interruptible. For example, if you type into the input again, React will abandon it and restart with the new value. React will always use the latest provided value.
Note that there is still a network request per each keystroke. What’s being deferred here is displaying results (until they’re ready), not the network requests themselves. Even if the user continues typing, responses for each keystroke get cached, so pressing Backspace is instant and doesn’t fetch again.

Indicating that the content is stale 
In the example above, there is no indication that the result list for the latest query is still loading. This can be confusing to the user if the new results take a while to load. To make it more obvious to the user that the result list does not match the latest query, you can add a visual indication when the stale result list is displayed:
<div style={{
 opacity: query !== deferredQuery ? 0.5 : 1,
}}>
 <SearchResults query={deferredQuery} />
</div>
With this change, as soon as you start typing, the stale result list gets slightly dimmed until the new result list loads. You can also add a CSS transition to delay dimming so that it feels gradual, like in the example below:
App.jsSearchResults.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
import { Suspense, useState, useDeferredValue } from 'react';
import SearchResults from './SearchResults.js';

export default function App() {
 const [query, setQuery] = useState('');
 const deferredQuery = useDeferredValue(query);
 const isStale = query !== deferredQuery;
 return (
   <>
     <label>
       Search albums:
       <input value={query} onChange={e => setQuery(e.target.value)} />
     </label>
     <Suspense fallback={<h2>Loading...</h2>}>
       <div style={{
         opacity: isStale ? 0.5 : 1,
         transition: isStale ? 'opacity 0.2s 0.2s linear' : 'opacity 0s 0s linear'
       }}>
         <SearchResults query={deferredQuery} />
       </div>
     </Suspense>
   </>
 );
}

Show more

Deferring re-rendering for a part of the UI 
You can also apply useDeferredValue as a performance optimization. It is useful when a part of your UI is slow to re-render, there’s no easy way to optimize it, and you want to prevent it from blocking the rest of the UI.
Imagine you have a text field and a component (like a chart or a long list) that re-renders on every keystroke:
function App() {
 const [text, setText] = useState('');
 return (
   <>
     <input value={text} onChange={e => setText(e.target.value)} />
     <SlowList text={text} />
   </>
 );
}
First, optimize SlowList to skip re-rendering when its props are the same. To do this, wrap it in memo:
const SlowList = memo(function SlowList({ text }) {
 // ...
});
However, this only helps if the SlowList props are the same as during the previous render. The problem you’re facing now is that it’s slow when they’re different, and when you actually need to show different visual output.
Concretely, the main performance problem is that whenever you type into the input, the SlowList receives new props, and re-rendering its entire tree makes the typing feel janky. In this case, useDeferredValue lets you prioritize updating the input (which must be fast) over updating the result list (which is allowed to be slower):
function App() {
 const [text, setText] = useState('');
 const deferredText = useDeferredValue(text);
 return (
   <>
     <input value={text} onChange={e => setText(e.target.value)} />
     <SlowList text={deferredText} />
   </>
 );
}
This does not make re-rendering of the SlowList faster. However, it tells React that re-rendering the list can be deprioritized so that it doesn’t block the keystrokes. The list will “lag behind” the input and then “catch up”. Like before, React will attempt to update the list as soon as possible, but will not block the user from typing.
The difference between useDeferredValue and unoptimized re-rendering
1. Deferred re-rendering of the list2. Unoptimized re-rendering of the list
Example 1 of 2: Deferred re-rendering of the list 
In this example, each item in the SlowList component is artificially slowed down so that you can see how useDeferredValue lets you keep the input responsive. Type into the input and notice that typing feels snappy while the list “lags behind” it.
App.jsSlowList.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
import { useState, useDeferredValue } from 'react';
import SlowList from './SlowList.js';

export default function App() {
 const [text, setText] = useState('');
 const deferredText = useDeferredValue(text);
 return (
   <>
     <input value={text} onChange={e => setText(e.target.value)} />
     <SlowList text={deferredText} />
   </>
 );
}

Console (2)
[ARTIFICIALLY SLOW] Rendering 250 <SlowItem />
[ARTIFICIALLY SLOW] Rendering 250 <SlowItem />
Next Example
Pitfall
This optimization requires SlowList to be wrapped in memo. This is because whenever the text changes, React needs to be able to re-render the parent component quickly. During that re-render, deferredText still has its previous value, so SlowList is able to skip re-rendering (its props have not changed). Without memo, it would have to re-render anyway, defeating the point of the optimization.
Deep Dive
How is deferring a value different from debouncing and throttling? 
Hide Details
There are two common optimization techniques you might have used before in this scenario:
Debouncing means you’d wait for the user to stop typing (e.g. for a second) before updating the list.
Throttling means you’d update the list every once in a while (e.g. at most once a second).
While these techniques are helpful in some cases, useDeferredValue is better suited to optimizing rendering because it is deeply integrated with React itself and adapts to the user’s device.
Unlike debouncing or throttling, it doesn’t require choosing any fixed delay. If the user’s device is fast (e.g. powerful laptop), the deferred re-render would happen almost immediately and wouldn’t be noticeable. If the user’s device is slow, the list would “lag behind” the input proportionally to how slow the device is.
Also, unlike with debouncing or throttling, deferred re-renders done by useDeferredValue are interruptible by default. This means that if React is in the middle of re-rendering a large list, but the user makes another keystroke, React will abandon that re-render, handle the keystroke, and then start rendering in the background again. By contrast, debouncing and throttling still produce a janky experience because they’re blocking: they merely postpone the moment when rendering blocks the keystroke.
If the work you’re optimizing doesn’t happen during rendering, debouncing and throttling are still useful. For example, they can let you fire fewer network requests. You can also use these techniques together.
PrevioususeDebugValue
NextuseEffect

Copyright © Meta Platforms, Inc
uwu?
Learn React
Quick Start
Installation
Describing the UI
Adding Interactivity
Managing State
Escape Hatches
API Reference
React APIs
React DOM APIs
Community
Code of Conduct
Meet the Team
Docs Contributors
Acknowledgements
More
Blog
React Native
Privacy
Terms
On this page
Overview
Reference
useDeferredValue(value, initialValue?)
Usage
Showing stale content while fresh content is loading
Indicating that the content is stale
Deferring re-rendering for a part of the UI
useDeferredValue – React
useEffect
useEffect is a React Hook that lets you synchronize a component with an external system.
useEffect(setup, dependencies?)
Reference
useEffect(setup, dependencies?)
Usage
Connecting to an external system
Wrapping Effects in custom Hooks
Controlling a non-React widget
Fetching data with Effects
Specifying reactive dependencies
Updating state based on previous state from an Effect
Removing unnecessary object dependencies
Removing unnecessary function dependencies
Reading the latest props and state from an Effect
Displaying different content on the server and the client
Troubleshooting
My Effect runs twice when the component mounts
My Effect runs after every re-render
My Effect keeps re-running in an infinite cycle
My cleanup logic runs even though my component didn’t unmount
My Effect does something visual, and I see a flicker before it runs

Reference 
useEffect(setup, dependencies?) 
Call useEffect at the top level of your component to declare an Effect:
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

function ChatRoom({ roomId }) {
 const [serverUrl, setServerUrl] = useState('https://localhost:1234');

 useEffect(() => {
   const connection = createConnection(serverUrl, roomId);
   connection.connect();
   return () => {
     connection.disconnect();
   };
 }, [serverUrl, roomId]);
 // ...
}
See more examples below.
Parameters 
setup: The function with your Effect’s logic. Your setup function may also optionally return a cleanup function. When your component is added to the DOM, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. After your component is removed from the DOM, React will run your cleanup function.
optional dependencies: The list of all reactive values referenced inside of the setup code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison. If you omit this argument, your Effect will re-run after every re-render of the component. See the difference between passing an array of dependencies, an empty array, and no dependencies at all.
Returns 
useEffect returns undefined.
Caveats 
useEffect is a Hook, so you can only call it at the top level of your component or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.
If you’re not trying to synchronize with some external system, you probably don’t need an Effect.
When Strict Mode is on, React will run one extra development-only setup+cleanup cycle before the first real setup. This is a stress-test that ensures that your cleanup logic “mirrors” your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, implement the cleanup function.
If some of your dependencies are objects or functions defined inside the component, there is a risk that they will cause the Effect to re-run more often than needed. To fix this, remove unnecessary object and function dependencies. You can also extract state updates and non-reactive logic outside of your Effect.
If your Effect wasn’t caused by an interaction (like a click), React will generally let the browser paint the updated screen first before running your Effect. If your Effect is doing something visual (for example, positioning a tooltip), and the delay is noticeable (for example, it flickers), replace useEffect with useLayoutEffect.
If your Effect is caused by an interaction (like a click), React may run your Effect before the browser paints the updated screen. This ensures that the result of the Effect can be observed by the event system. Usually, this works as expected. However, if you must defer the work until after paint, such as an alert(), you can use setTimeout. See reactwg/react-18/128 for more information.
Even if your Effect was caused by an interaction (like a click), React may allow the browser to repaint the screen before processing the state updates inside your Effect. Usually, this works as expected. However, if you must block the browser from repainting the screen, you need to replace useEffect with useLayoutEffect.
Effects only run on the client. They don’t run during server rendering.

Usage 
Connecting to an external system 
Some components need to stay connected to the network, some browser API, or a third-party library, while they are displayed on the page. These systems aren’t controlled by React, so they are called external.
To connect your component to some external system, call useEffect at the top level of your component:
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

function ChatRoom({ roomId }) {
 const [serverUrl, setServerUrl] = useState('https://localhost:1234');

 useEffect(() => {
 	const connection = createConnection(serverUrl, roomId);
   connection.connect();
 	return () => {
     connection.disconnect();
 	};
 }, [serverUrl, roomId]);
 // ...
}
You need to pass two arguments to useEffect:
A setup function with setup code that connects to that system.
It should return a cleanup function with cleanup code that disconnects from that system.
A list of dependencies including every value from your component used inside of those functions.
React calls your setup and cleanup functions whenever it’s necessary, which may happen multiple times:
Your setup code runs when your component is added to the page (mounts).
After every re-render of your component where the dependencies have changed:
First, your cleanup code runs with the old props and state.
Then, your setup code runs with the new props and state.
Your cleanup code runs one final time after your component is removed from the page (unmounts).
Let’s illustrate this sequence for the example above.
When the ChatRoom component above gets added to the page, it will connect to the chat room with the initial serverUrl and roomId. If either serverUrl or roomId change as a result of a re-render (say, if the user picks a different chat room in a dropdown), your Effect will disconnect from the previous room, and connect to the next one. When the ChatRoom component is removed from the page, your Effect will disconnect one last time.
To help you find bugs, in development React runs setup and cleanup one extra time before the setup. This is a stress-test that verifies your Effect’s logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn’t be able to distinguish between the setup being called once (as in production) and a setup → cleanup → setup sequence (as in development). See common solutions.
Try to write every Effect as an independent process and think about a single setup/cleanup cycle at a time. It shouldn’t matter whether your component is mounting, updating, or unmounting. When your cleanup logic correctly “mirrors” the setup logic, your Effect is resilient to running setup and cleanup as often as needed.
Note
An Effect lets you keep your component synchronized with some external system (like a chat service). Here, external system means any piece of code that’s not controlled by React, such as:
A timer managed with setInterval() and clearInterval().
An event subscription using window.addEventListener() and window.removeEventListener().
A third-party animation library with an API like animation.start() and animation.reset().
If you’re not connecting to any external system, you probably don’t need an Effect.
Examples of connecting to an external system
1. Connecting to a chat server2. Listening to a global browser event3. Triggering an animation4. Controlling a modal dialog5. Tracking element visibility
Example 1 of 5: Connecting to a chat server 
In this example, the ChatRoom component uses an Effect to stay connected to an external system defined in chat.js. Press “Open chat” to make the ChatRoom component appear. This sandbox runs in development mode, so there is an extra connect-and-disconnect cycle, as explained here. Try changing the roomId and serverUrl using the dropdown and the input, and see how the Effect re-connects to the chat. Press “Close chat” to see the Effect disconnect one last time.
App.jschat.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

function ChatRoom({ roomId }) {
 const [serverUrl, setServerUrl] = useState('https://localhost:1234');

 useEffect(() => {
   const connection = createConnection(serverUrl, roomId);
   connection.connect();
   return () => {
     connection.disconnect();
   };
 }, [roomId, serverUrl]);

 return (
   <>
     <label>
       Server URL:{' '}
       <input
         value={serverUrl}
         onChange={e => setServerUrl(e.target.value)}
       />
     </label>
     <h1>Welcome to the {roomId} room!</h1>
   </>
 );
}

export default function App() {
 const [roomId, setRoomId] = useState('general');
 const [show, setShow] = useState(false);
 return (
   <>
     <label>
       Choose the chat room:{' '}
       <select
Show more
Next Example

Wrapping Effects in custom Hooks 
Effects are an “escape hatch”: you use them when you need to “step outside React” and when there is no better built-in solution for your use case. If you find yourself often needing to manually write Effects, it’s usually a sign that you need to extract some custom Hooks for common behaviors your components rely on.
For example, this useChatRoom custom Hook “hides” the logic of your Effect behind a more declarative API:
function useChatRoom({ serverUrl, roomId }) {
 useEffect(() => {
   const options = {
     serverUrl: serverUrl,
     roomId: roomId
   };
   const connection = createConnection(options);
   connection.connect();
   return () => connection.disconnect();
 }, [roomId, serverUrl]);
}
Then you can use it from any component like this:
function ChatRoom({ roomId }) {
 const [serverUrl, setServerUrl] = useState('https://localhost:1234');

 useChatRoom({
   roomId: roomId,
   serverUrl: serverUrl
 });
 // ...
There are also many excellent custom Hooks for every purpose available in the React ecosystem.
Learn more about wrapping Effects in custom Hooks.
Examples of wrapping Effects in custom Hooks
1. Custom useChatRoom Hook2. Custom useWindowListener Hook3. Custom useIntersectionObserver Hook
Example 1 of 3: Custom useChatRoom Hook 
This example is identical to one of the earlier examples, but the logic is extracted to a custom Hook.
App.jsuseChatRoom.jschat.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
import { useState } from 'react';
import { useChatRoom } from './useChatRoom.js';

function ChatRoom({ roomId }) {
 const [serverUrl, setServerUrl] = useState('https://localhost:1234');

 useChatRoom({
   roomId: roomId,
   serverUrl: serverUrl
 });

 return (
   <>
     <label>
       Server URL:{' '}
       <input
         value={serverUrl}
         onChange={e => setServerUrl(e.target.value)}
       />
     </label>
     <h1>Welcome to the {roomId} room!</h1>
   </>
 );
}

export default function App() {
 const [roomId, setRoomId] = useState('general');
 const [show, setShow] = useState(false);
 return (
   <>
     <label>
       Choose the chat room:{' '}
       <select
         value={roomId}
         onChange={e => setRoomId(e.target.value)}
       >
Show more
Next Example

Controlling a non-React widget 
Sometimes, you want to keep an external system synchronized to some prop or state of your component.
For example, if you have a third-party map widget or a video player component written without React, you can use an Effect to call methods on it that make its state match the current state of your React component. This Effect creates an instance of a MapWidget class defined in map-widget.js. When you change the zoomLevel prop of the Map component, the Effect calls the setZoom() on the class instance to keep it synchronized:
App.jsMap.jsmap-widget.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
import { useRef, useEffect } from 'react';
import { MapWidget } from './map-widget.js';

export default function Map({ zoomLevel }) {
 const containerRef = useRef(null);
 const mapRef = useRef(null);

 useEffect(() => {
   if (mapRef.current === null) {
     mapRef.current = new MapWidget(containerRef.current);
   }

   const map = mapRef.current;
   map.setZoom(zoomLevel);
 }, [zoomLevel]);

 return (
   <div
     style={{ width: 200, height: 200 }}
     ref={containerRef}
   />
 );
}

Show more
In this example, a cleanup function is not needed because the MapWidget class manages only the DOM node that was passed to it. After the Map React component is removed from the tree, both the DOM node and the MapWidget class instance will be automatically garbage-collected by the browser JavaScript engine.

Fetching data with Effects 
You can use an Effect to fetch data for your component. Note that if you use a framework, using your framework’s data fetching mechanism will be a lot more efficient than writing Effects manually.
If you want to fetch data from an Effect manually, your code might look like this:
import { useState, useEffect } from 'react';
import { fetchBio } from './api.js';

export default function Page() {
 const [person, setPerson] = useState('Alice');
 const [bio, setBio] = useState(null);

 useEffect(() => {
   let ignore = false;
   setBio(null);
   fetchBio(person).then(result => {
     if (!ignore) {
       setBio(result);
     }
   });
   return () => {
     ignore = true;
   };
 }, [person]);

 // ...
Note the ignore variable which is initialized to false, and is set to true during cleanup. This ensures your code doesn’t suffer from “race conditions”: network responses may arrive in a different order than you sent them.
App.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
import { useState, useEffect } from 'react';
import { fetchBio } from './api.js';

export default function Page() {
 const [person, setPerson] = useState('Alice');
 const [bio, setBio] = useState(null);
 useEffect(() => {
   let ignore = false;
   setBio(null);
   fetchBio(person).then(result => {
     if (!ignore) {
       setBio(result);
     }
   });
   return () => {
     ignore = true;
   }
 }, [person]);

 return (
   <>
     <select value={person} onChange={e => {
       setPerson(e.target.value);
     }}>
       <option value="Alice">Alice</option>
       <option value="Bob">Bob</option>
       <option value="Taylor">Taylor</option>
     </select>
     <hr />
     <p><i>{bio ?? 'Loading...'}</i></p>
   </>
 );
}

Show more
You can also rewrite using the async / await syntax, but you still need to provide a cleanup function:
App.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
import { useState, useEffect } from 'react';
import { fetchBio } from './api.js';

export default function Page() {
 const [person, setPerson] = useState('Alice');
 const [bio, setBio] = useState(null);
 useEffect(() => {
   async function startFetching() {
     setBio(null);
     const result = await fetchBio(person);
     if (!ignore) {
       setBio(result);
     }
   }

   let ignore = false;
   startFetching();
   return () => {
     ignore = true;
   }
 }, [person]);

 return (
   <>
     <select value={person} onChange={e => {
       setPerson(e.target.value);
     }}>
       <option value="Alice">Alice</option>
       <option value="Bob">Bob</option>
       <option value="Taylor">Taylor</option>
     </select>
     <hr />
     <p><i>{bio ?? 'Loading...'}</i></p>
   </>
 );
}

Show more
Writing data fetching directly in Effects gets repetitive and makes it difficult to add optimizations like caching and server rendering later. It’s easier to use a custom Hook—either your own or maintained by the community.
Deep Dive
What are good alternatives to data fetching in Effects? 
Hide Details
Writing fetch calls inside Effects is a popular way to fetch data, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:
Effects don’t run on the server. This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.
Fetching directly in Effects makes it easy to create “network waterfalls”. You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.
Fetching directly in Effects usually means you don’t preload or cache data. For example, if the component unmounts and then mounts again, it would have to fetch the data again.
It’s not very ergonomic. There’s quite a bit of boilerplate code involved when writing fetch calls in a way that doesn’t suffer from bugs like race conditions.
This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:
If you use a framework, use its built-in data fetching mechanism. Modern React frameworks have integrated data fetching mechanisms that are efficient and don’t suffer from the above pitfalls.
Otherwise, consider using or building a client-side cache. Popular open source solutions include React Query, useSWR, and React Router 6.4+. You can build your own solution too, in which case you would use Effects under the hood but also add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes).
You can continue fetching data directly in Effects if neither of these approaches suit you.

Specifying reactive dependencies 
Notice that you can’t “choose” the dependencies of your Effect. Every reactive value used by your Effect’s code must be declared as a dependency. Your Effect’s dependency list is determined by the surrounding code:
function ChatRoom({ roomId }) { // This is a reactive value
 const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // This is a reactive value too

 useEffect(() => {
   const connection = createConnection(serverUrl, roomId); // This Effect reads these reactive values
   connection.connect();
   return () => connection.disconnect();
 }, [serverUrl, roomId]); // ✅ So you must specify them as dependencies of your Effect
 // ...
}
If either serverUrl or roomId change, your Effect will reconnect to the chat using the new values.
Reactive values include props and all variables and functions declared directly inside of your component. Since roomId and serverUrl are reactive values, you can’t remove them from the dependencies. If you try to omit them and your linter is correctly configured for React, the linter will flag this as a mistake you need to fix:
function ChatRoom({ roomId }) {
 const [serverUrl, setServerUrl] = useState('https://localhost:1234');

 useEffect(() => {
   const connection = createConnection(serverUrl, roomId);
   connection.connect();
   return () => connection.disconnect();
 }, []); // 🔴 React Hook useEffect has missing dependencies: 'roomId' and 'serverUrl'
 // ...
}
To remove a dependency, you need to “prove” to the linter that it doesn’t need to be a dependency. For example, you can move serverUrl out of your component to prove that it’s not reactive and won’t change on re-renders:
const serverUrl = 'https://localhost:1234'; // Not a reactive value anymore

function ChatRoom({ roomId }) {
 useEffect(() => {
   const connection = createConnection(serverUrl, roomId);
   connection.connect();
   return () => connection.disconnect();
 }, [roomId]); // ✅ All dependencies declared
 // ...
}
Now that serverUrl is not a reactive value (and can’t change on a re-render), it doesn’t need to be a dependency. If your Effect’s code doesn’t use any reactive values, its dependency list should be empty ([]):
const serverUrl = 'https://localhost:1234'; // Not a reactive value anymore
const roomId = 'music'; // Not a reactive value anymore

function ChatRoom() {
 useEffect(() => {
   const connection = createConnection(serverUrl, roomId);
   connection.connect();
   return () => connection.disconnect();
 }, []); // ✅ All dependencies declared
 // ...
}
An Effect with empty dependencies doesn’t re-run when any of your component’s props or state change.
Pitfall
If you have an existing codebase, you might have some Effects that suppress the linter like this:
useEffect(() => {
 // ...
 // 🔴 Avoid suppressing the linter like this:
 // eslint-ignore-next-line react-hooks/exhaustive-deps
}, []);
When dependencies don’t match the code, there is a high risk of introducing bugs. By suppressing the linter, you “lie” to React about the values your Effect depends on. Instead, prove they’re unnecessary.
Examples of passing reactive dependencies
1. Passing a dependency array2. Passing an empty dependency array3. Passing no dependency array at all
Example 2 of 3: Passing an empty dependency array 
If your Effect truly doesn’t use any reactive values, it will only run after the initial render.
useEffect(() => {
 // ...
}, []); // Does not run again (except once in development)
Even with empty dependencies, setup and cleanup will run one extra time in development to help you find bugs.
In this example, both serverUrl and roomId are hardcoded. Since they’re declared outside the component, they are not reactive values, and so they aren’t dependencies. The dependency list is empty, so the Effect doesn’t re-run on re-renders.
App.jschat.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';
const roomId = 'music';

function ChatRoom() {
 const [message, setMessage] = useState('');

 useEffect(() => {
   const connection = createConnection(serverUrl, roomId);
   connection.connect();
   return () => connection.disconnect();
 }, []);

 return (
   <>
     <h1>Welcome to the {roomId} room!</h1>
     <label>
       Your message:{' '}
       <input value={message} onChange={e => setMessage(e.target.value)} />
     </label>
   </>
 );
}

export default function App() {
 const [show, setShow] = useState(false);
 return (
   <>
     <button onClick={() => setShow(!show)}>
       {show ? 'Close chat' : 'Open chat'}
     </button>
     {show && <hr />}
     {show && <ChatRoom />}
   </>
 );
}

Show less
Next Example

Updating state based on previous state from an Effect 
When you want to update state based on previous state from an Effect, you might run into a problem:
function Counter() {
 const [count, setCount] = useState(0);

 useEffect(() => {
   const intervalId = setInterval(() => {
     setCount(count + 1); // You want to increment the counter every second...
   }, 1000)
   return () => clearInterval(intervalId);
 }, [count]); // 🚩 ... but specifying `count` as a dependency always resets the interval.
 // ...
}
Since count is a reactive value, it must be specified in the list of dependencies. However, that causes the Effect to cleanup and setup again every time the count changes. This is not ideal.
To fix this, pass the c => c + 1 state updater to setCount:
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
import { useState, useEffect } from 'react';

export default function Counter() {
 const [count, setCount] = useState(0);

 useEffect(() => {
   const intervalId = setInterval(() => {
     setCount(c => c + 1); // ✅ Pass a state updater
   }, 1000);
   return () => clearInterval(intervalId);
 }, []); // ✅ Now count is not a dependency

 return <h1>{count}</h1>;
}

Now that you’re passing c => c + 1 instead of count + 1, your Effect no longer needs to depend on count. As a result of this fix, it won’t need to cleanup and setup the interval again every time the count changes.

Removing unnecessary object dependencies 
If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the options object is different for every render:
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
 const [message, setMessage] = useState('');

 const options = { // 🚩 This object is created from scratch on every re-render
   serverUrl: serverUrl,
   roomId: roomId
 };

 useEffect(() => {
   const connection = createConnection(options); // It's used inside the Effect
   connection.connect();
   return () => connection.disconnect();
 }, [options]); // 🚩 As a result, these dependencies are always different on a re-render
 // ...
Avoid using an object created during rendering as a dependency. Instead, create the object inside the Effect:
App.jschat.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
 const [message, setMessage] = useState('');

 useEffect(() => {
   const options = {
     serverUrl: serverUrl,
     roomId: roomId
   };
   const connection = createConnection(options);
   connection.connect();
   return () => connection.disconnect();
 }, [roomId]);

 return (
   <>
     <h1>Welcome to the {roomId} room!</h1>
     <input value={message} onChange={e => setMessage(e.target.value)} />
   </>
 );
}

export default function App() {
 const [roomId, setRoomId] = useState('general');
 return (
   <>
     <label>
       Choose the chat room:{' '}
       <select
         value={roomId}
         onChange={e => setRoomId(e.target.value)}
       >
Console (3)
✅ Connecting to "general" room at https://localhost:1234...
❌ Disconnected from "general" room at https://localhost:1234
✅ Connecting to "general" room at https://localhost:1234...
Show more
Now that you create the options object inside the Effect, the Effect itself only depends on the roomId string.
With this fix, typing into the input doesn’t reconnect the chat. Unlike an object which gets re-created, a string like roomId doesn’t change unless you set it to another value. Read more about removing dependencies.

Removing unnecessary function dependencies 
If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the createOptions function is different for every render:
function ChatRoom({ roomId }) {
 const [message, setMessage] = useState('');

 function createOptions() { // 🚩 This function is created from scratch on every re-render
   return {
     serverUrl: serverUrl,
     roomId: roomId
   };
 }

 useEffect(() => {
   const options = createOptions(); // It's used inside the Effect
   const connection = createConnection();
   connection.connect();
   return () => connection.disconnect();
 }, [createOptions]); // 🚩 As a result, these dependencies are always different on a re-render
 // ...
By itself, creating a function from scratch on every re-render is not a problem. You don’t need to optimize that. However, if you use it as a dependency of your Effect, it will cause your Effect to re-run after every re-render.
Avoid using a function created during rendering as a dependency. Instead, declare it inside the Effect:
App.jschat.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
 const [message, setMessage] = useState('');

 useEffect(() => {
   function createOptions() {
     return {
       serverUrl: serverUrl,
       roomId: roomId
     };
   }

   const options = createOptions();
   const connection = createConnection(options);
   connection.connect();
   return () => connection.disconnect();
 }, [roomId]);

 return (
   <>
     <h1>Welcome to the {roomId} room!</h1>
     <input value={message} onChange={e => setMessage(e.target.value)} />
   </>
 );
}

export default function App() {
 const [roomId, setRoomId] = useState('general');
 return (
   <>
     <label>
       Choose the chat room:{' '}
Show more
Now that you define the createOptions function inside the Effect, the Effect itself only depends on the roomId string. With this fix, typing into the input doesn’t reconnect the chat. Unlike a function which gets re-created, a string like roomId doesn’t change unless you set it to another value. Read more about removing dependencies.

Reading the latest props and state from an Effect 
Under Construction
This section describes an experimental API that has not yet been released in a stable version of React.
By default, when you read a reactive value from an Effect, you have to add it as a dependency. This ensures that your Effect “reacts” to every change of that value. For most dependencies, that’s the behavior you want.
However, sometimes you’ll want to read the latest props and state from an Effect without “reacting” to them. For example, imagine you want to log the number of the items in the shopping cart for every page visit:
function Page({ url, shoppingCart }) {
 useEffect(() => {
   logVisit(url, shoppingCart.length);
 }, [url, shoppingCart]); // ✅ All dependencies declared
 // ...
}
What if you want to log a new page visit after every url change, but not if only the shoppingCart changes? You can’t exclude shoppingCart from dependencies without breaking the reactivity rules. However, you can express that you don’t want a piece of code to “react” to changes even though it is called from inside an Effect. Declare an Effect Event with the useEffectEvent Hook, and move the code reading shoppingCart inside of it:
function Page({ url, shoppingCart }) {
 const onVisit = useEffectEvent(visitedUrl => {
   logVisit(visitedUrl, shoppingCart.length)
 });

 useEffect(() => {
   onVisit(url);
 }, [url]); // ✅ All dependencies declared
 // ...
}
Effect Events are not reactive and must always be omitted from dependencies of your Effect. This is what lets you put non-reactive code (where you can read the latest value of some props and state) inside of them. By reading shoppingCart inside of onVisit, you ensure that shoppingCart won’t re-run your Effect.
Read more about how Effect Events let you separate reactive and non-reactive code.

Displaying different content on the server and the client 
If your app uses server rendering (either directly or via a framework), your component will render in two different environments. On the server, it will render to produce the initial HTML. On the client, React will run the rendering code again so that it can attach your event handlers to that HTML. This is why, for hydration to work, your initial render output must be identical on the client and the server.
In rare cases, you might need to display different content on the client. For example, if your app reads some data from localStorage, it can’t possibly do that on the server. Here is how you could implement this:
function MyComponent() {
 const [didMount, setDidMount] = useState(false);

 useEffect(() => {
   setDidMount(true);
 }, []);

 if (didMount) {
   // ... return client-only JSX ...
 }  else {
   // ... return initial JSX ...
 }
}
While the app is loading, the user will see the initial render output. Then, when it’s loaded and hydrated, your Effect will run and set didMount to true, triggering a re-render. This will switch to the client-only render output. Effects don’t run on the server, so this is why didMount was false during the initial server render.
Use this pattern sparingly. Keep in mind that users with a slow connection will see the initial content for quite a bit of time—potentially, many seconds—so you don’t want to make jarring changes to your component’s appearance. In many cases, you can avoid the need for this by conditionally showing different things with CSS.

Troubleshooting 
My Effect runs twice when the component mounts 
When Strict Mode is on, in development, React runs setup and cleanup one extra time before the actual setup.
This is a stress-test that verifies your Effect’s logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn’t be able to distinguish between the setup being called once (as in production) and a setup → cleanup → setup sequence (as in development).
Read more about how this helps find bugs and how to fix your logic.

My Effect runs after every re-render 
First, check that you haven’t forgotten to specify the dependency array:
useEffect(() => {
 // ...
}); // 🚩 No dependency array: re-runs after every render!
If you’ve specified the dependency array but your Effect still re-runs in a loop, it’s because one of your dependencies is different on every re-render.
You can debug this problem by manually logging your dependencies to the console:
 useEffect(() => {
   // ..
 }, [serverUrl, roomId]);

 console.log([serverUrl, roomId]);
You can then right-click on the arrays from different re-renders in the console and select “Store as a global variable” for both of them. Assuming the first one got saved as temp1 and the second one got saved as temp2, you can then use the browser console to check whether each dependency in both arrays is the same:
Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?
Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?
Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ...
When you find the dependency that is different on every re-render, you can usually fix it in one of these ways:
Updating state based on previous state from an Effect
Removing unnecessary object dependencies
Removing unnecessary function dependencies
Reading the latest props and state from an Effect
As a last resort (if these methods didn’t help), wrap its creation with useMemo or useCallback (for functions).

My Effect keeps re-running in an infinite cycle 
If your Effect runs in an infinite cycle, these two things must be true:
Your Effect is updating some state.
That state leads to a re-render, which causes the Effect’s dependencies to change.
Before you start fixing the problem, ask yourself whether your Effect is connecting to some external system (like DOM, network, a third-party widget, and so on). Why does your Effect need to set state? Does it synchronize with that external system? Or are you trying to manage your application’s data flow with it?
If there is no external system, consider whether removing the Effect altogether would simplify your logic.
If you’re genuinely synchronizing with some external system, think about why and under what conditions your Effect should update the state. Has something changed that affects your component’s visual output? If you need to keep track of some data that isn’t used by rendering, a ref (which doesn’t trigger re-renders) might be more appropriate. Verify your Effect doesn’t update the state (and trigger re-renders) more than needed.
Finally, if your Effect is updating the state at the right time, but there is still a loop, it’s because that state update leads to one of the Effect’s dependencies changing. Read how to debug dependency changes.

My cleanup logic runs even though my component didn’t unmount 
The cleanup function runs not only during unmount, but before every re-render with changed dependencies. Additionally, in development, React runs setup+cleanup one extra time immediately after component mounts.
If you have cleanup code without corresponding setup code, it’s usually a code smell:
useEffect(() => {
 // 🔴 Avoid: Cleanup logic without corresponding setup logic
 return () => {
   doSomething();
 };
}, []);
Your cleanup logic should be “symmetrical” to the setup logic, and should stop or undo whatever setup did:
 useEffect(() => {
   const connection = createConnection(serverUrl, roomId);
   connection.connect();
   return () => {
     connection.disconnect();
   };
 }, [serverUrl, roomId]);
Learn how the Effect lifecycle is different from the component’s lifecycle.

My Effect does something visual, and I see a flicker before it runs 
If your Effect must block the browser from painting the screen, replace useEffect with useLayoutEffect. Note that this shouldn’t be needed for the vast majority of Effects. You’ll only need this if it’s crucial to run your Effect before the browser paint: for example, to measure and position a tooltip before the user sees it.
useId
useId is a React Hook for generating unique IDs that can be passed to accessibility attributes.
const id = useId()
Reference
useId()
Usage
Generating unique IDs for accessibility attributes
Generating IDs for several related elements
Specifying a shared prefix for all generated IDs
Using the same ID prefix on the client and the server

Reference 
useId() 
Call useId at the top level of your component to generate a unique ID:
import { useId } from 'react';

function PasswordField() {
 const passwordHintId = useId();
 // ...
See more examples below.
Parameters 
useId does not take any parameters.
Returns 
useId returns a unique ID string associated with this particular useId call in this particular component.
Caveats 
useId is a Hook, so you can only call it at the top level of your component or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.
useId should not be used to generate keys in a list. Keys should be generated from your data.
useId currently cannot be used in async Server Components.

Usage 
Pitfall
Do not call useId to generate keys in a list. Keys should be generated from your data.
Generating unique IDs for accessibility attributes 
Call useId at the top level of your component to generate a unique ID:
import { useId } from 'react';

function PasswordField() {
 const passwordHintId = useId();
 // ...
You can then pass the generated ID to different attributes:
<>
 <input type="password" aria-describedby={passwordHintId} />
 <p id={passwordHintId}>
</>
Let’s walk through an example to see when this is useful.
HTML accessibility attributes like aria-describedby let you specify that two tags are related to each other. For example, you can specify that an element (like an input) is described by another element (like a paragraph).
In regular HTML, you would write it like this:
<label>
 Password:
 <input
   type="password"
   aria-describedby="password-hint"
 />
</label>
<p id="password-hint">
 The password should contain at least 18 characters
</p>
However, hardcoding IDs like this is not a good practice in React. A component may be rendered more than once on the page—but IDs have to be unique! Instead of hardcoding an ID, generate a unique ID with useId:
import { useId } from 'react';

function PasswordField() {
 const passwordHintId = useId();
 return (
   <>
     <label>
       Password:
       <input
         type="password"
         aria-describedby={passwordHintId}
       />
     </label>
     <p id={passwordHintId}>
       The password should contain at least 18 characters
     </p>
   </>
 );
}
Now, even if PasswordField appears multiple times on the screen, the generated IDs won’t clash.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
import { useId } from 'react';

function PasswordField() {
 const passwordHintId = useId();
 return (
   <>
     <label>
       Password:
       <input
         type="password"
         aria-describedby={passwordHintId}
       />
     </label>
     <p id={passwordHintId}>
       The password should contain at least 18 characters
     </p>
   </>
 );
}

export default function App() {
 return (
   <>
     <h2>Choose password</h2>
     <PasswordField />
     <h2>Confirm password</h2>
     <PasswordField />
   </>
 );
}

Show more
Watch this video to see the difference in the user experience with assistive technologies.
Pitfall
With server rendering, useId requires an identical component tree on the server and the client. If the trees you render on the server and the client don’t match exactly, the generated IDs won’t match.
Deep Dive
Why is useId better than an incrementing counter? 
Hide Details
You might be wondering why useId is better than incrementing a global variable like nextId++.
The primary benefit of useId is that React ensures that it works with server rendering. During server rendering, your components generate HTML output. Later, on the client, hydration attaches your event handlers to the generated HTML. For hydration to work, the client output must match the server HTML.
This is very difficult to guarantee with an incrementing counter because the order in which the Client Components are hydrated may not match the order in which the server HTML was emitted. By calling useId, you ensure that hydration will work, and the output will match between the server and the client.
Inside React, useId is generated from the “parent path” of the calling component. This is why, if the client and the server tree are the same, the “parent path” will match up regardless of rendering order.

Generating IDs for several related elements 
If you need to give IDs to multiple related elements, you can call useId to generate a shared prefix for them:
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
import { useId } from 'react';

export default function Form() {
 const id = useId();
 return (
   <form>
     <label htmlFor={id + '-firstName'}>First Name:</label>
     <input id={id + '-firstName'} type="text" />
     <hr />
     <label htmlFor={id + '-lastName'}>Last Name:</label>
     <input id={id + '-lastName'} type="text" />
   </form>
 );
}

This lets you avoid calling useId for every single element that needs a unique ID.

Specifying a shared prefix for all generated IDs 
If you render multiple independent React applications on a single page, pass identifierPrefix as an option to your createRoot or hydrateRoot calls. This ensures that the IDs generated by the two different apps never clash because every identifier generated with useId will start with the distinct prefix you’ve specified.
index.jsindex.htmlApp.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
import { createRoot } from 'react-dom/client';
import App from './App.js';
import './styles.css';

const root1 = createRoot(document.getElementById('root1'), {
 identifierPrefix: 'my-first-app-'
});
root1.render(<App />);

const root2 = createRoot(document.getElementById('root2'), {
 identifierPrefix: 'my-second-app-'
});
root2.render(<App />);

Console (2)
Generated identifier: «my-first-app-r0»
Generated identifier: «my-second-app-r1»

Using the same ID prefix on the client and the server 
If you render multiple independent React apps on the same page, and some of these apps are server-rendered, make sure that the identifierPrefix you pass to the hydrateRoot call on the client side is the same as the identifierPrefix you pass to the server APIs such as renderToPipeableStream.
// Server
import { renderToPipeableStream } from 'react-dom/server';

const { pipe } = renderToPipeableStream(
 <App />,
 { identifierPrefix: 'react-app1' }
);
// Client
import { hydrateRoot } from 'react-dom/client';

const domNode = document.getElementById('root');
const root = hydrateRoot(
 domNode,
 reactNode,
 { identifierPrefix: 'react-app1' }
);
You do not need to pass identifierPrefix if you only have one React app on the page.
useImperativeHandle
useImperativeHandle is a React Hook that lets you customize the handle exposed as a ref.
useImperativeHandle(ref, createHandle, dependencies?)
Reference
useImperativeHandle(ref, createHandle, dependencies?)
Usage
Exposing a custom ref handle to the parent component
Exposing your own imperative methods

Reference 
useImperativeHandle(ref, createHandle, dependencies?) 
Call useImperativeHandle at the top level of your component to customize the ref handle it exposes:
import { useImperativeHandle } from 'react';

function MyInput({ ref }) {
 useImperativeHandle(ref, () => {
   return {
     // ... your methods ...
   };
 }, []);
 // ...
See more examples below.
Parameters 
ref: The ref you received as a prop to the MyInput component.
createHandle: A function that takes no arguments and returns the ref handle you want to expose. That ref handle can have any type. Usually, you will return an object with the methods you want to expose.
optional dependencies: The list of all reactive values referenced inside of the createHandle code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison. If a re-render resulted in a change to some dependency, or if you omitted this argument, your createHandle function will re-execute, and the newly created handle will be assigned to the ref.
Note
Starting with React 19, ref is available as a prop. In React 18 and earlier, it was necessary to get the ref from forwardRef.
Returns 
useImperativeHandle returns undefined.

Usage 
Exposing a custom ref handle to the parent component 
To expose a DOM node to the parent element, pass in the ref prop to the node.
function MyInput({ ref }) {
 return <input ref={ref} />;
};
With the code above, a ref to MyInput will receive the <input> DOM node. However, you can expose a custom value instead. To customize the exposed handle, call useImperativeHandle at the top level of your component:
import { useImperativeHandle } from 'react';

function MyInput({ ref }) {
 useImperativeHandle(ref, () => {
   return {
     // ... your methods ...
   };
 }, []);

 return <input />;
};
Note that in the code above, the ref is no longer passed to the <input>.
For example, suppose you don’t want to expose the entire <input> DOM node, but you want to expose two of its methods: focus and scrollIntoView. To do this, keep the real browser DOM in a separate ref. Then use useImperativeHandle to expose a handle with only the methods that you want the parent component to call:
import { useRef, useImperativeHandle } from 'react';

function MyInput({ ref }) {
 const inputRef = useRef(null);

 useImperativeHandle(ref, () => {
   return {
     focus() {
       inputRef.current.focus();
     },
     scrollIntoView() {
       inputRef.current.scrollIntoView();
     },
   };
 }, []);

 return <input ref={inputRef} />;
};
Now, if the parent component gets a ref to MyInput, it will be able to call the focus and scrollIntoView methods on it. However, it will not have full access to the underlying <input> DOM node.
App.jsMyInput.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
import { useRef } from 'react';
import MyInput from './MyInput.js';

export default function Form() {
 const ref = useRef(null);

 function handleClick() {
   ref.current.focus();
   // This won't work because the DOM node isn't exposed:
   // ref.current.style.opacity = 0.5;
 }

 return (
   <form>
     <MyInput placeholder="Enter your name" ref={ref} />
     <button type="button" onClick={handleClick}>
       Edit
     </button>
   </form>
 );
}

Show more

Exposing your own imperative methods 
The methods you expose via an imperative handle don’t have to match the DOM methods exactly. For example, this Post component exposes a scrollAndFocusAddComment method via an imperative handle. This lets the parent Page scroll the list of comments and focus the input field when you click the button:
App.jsPost.jsCommentList.jsAddComment.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
import { useRef } from 'react';
import Post from './Post.js';

export default function Page() {
 const postRef = useRef(null);

 function handleClick() {
   postRef.current.scrollAndFocusAddComment();
 }

 return (
   <>
     <button onClick={handleClick}>
       Write a comment
     </button>
     <Post ref={postRef} />
   </>
 );
}

Show more
Pitfall
Do not overuse refs. You should only use refs for imperative behaviors that you can’t express as props: for example, scrolling to a node, focusing a node, triggering an animation, selecting text, and so on.
If you can express something as a prop, you should not use a ref. For example, instead of exposing an imperative handle like { open, close } from a Modal component, it is better to take isOpen as a prop like <Modal isOpen={isOpen} />. Effects can help you expose imperative behaviors via props.
useInsertionEffect
Pitfall
useInsertionEffect is for CSS-in-JS library authors. Unless you are working on a CSS-in-JS library and need a place to inject the styles, you probably want useEffect or useLayoutEffect instead.
useInsertionEffect allows inserting elements into the DOM before any layout Effects fire.
useInsertionEffect(setup, dependencies?)
Reference
useInsertionEffect(setup, dependencies?)
Usage
Injecting dynamic styles from CSS-in-JS libraries

Reference 
useInsertionEffect(setup, dependencies?) 
Call useInsertionEffect to insert styles before any Effects fire that may need to read layout:
import { useInsertionEffect } from 'react';

// Inside your CSS-in-JS library
function useCSS(rule) {
 useInsertionEffect(() => {
   // ... inject <style> tags here ...
 });
 return rule;
}
See more examples below.
Parameters 
setup: The function with your Effect’s logic. Your setup function may also optionally return a cleanup function. When your component is added to the DOM, but before any layout Effects fire, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. When your component is removed from the DOM, React will run your cleanup function.
optional dependencies: The list of all reactive values referenced inside of the setup code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison algorithm. If you don’t specify the dependencies at all, your Effect will re-run after every re-render of the component.
Returns 
useInsertionEffect returns undefined.
Caveats 
Effects only run on the client. They don’t run during server rendering.
You can’t update state from inside useInsertionEffect.
By the time useInsertionEffect runs, refs are not attached yet.
useInsertionEffect may run either before or after the DOM has been updated. You shouldn’t rely on the DOM being updated at any particular time.
Unlike other types of Effects, which fire cleanup for every Effect and then setup for every Effect, useInsertionEffect will fire both cleanup and setup one component at a time. This results in an “interleaving” of the cleanup and setup functions.

Usage 
Injecting dynamic styles from CSS-in-JS libraries 
Traditionally, you would style React components using plain CSS.
// In your JS file:
<button className="success" />

// In your CSS file:
.success { color: green; }
Some teams prefer to author styles directly in JavaScript code instead of writing CSS files. This usually requires using a CSS-in-JS library or a tool. There are three common approaches to CSS-in-JS:
Static extraction to CSS files with a compiler
Inline styles, e.g. <div style={{ opacity: 1 }}>
Runtime injection of <style> tags
If you use CSS-in-JS, we recommend a combination of the first two approaches (CSS files for static styles, inline styles for dynamic styles). We don’t recommend runtime <style> tag injection for two reasons:
Runtime injection forces the browser to recalculate the styles a lot more often.
Runtime injection can be very slow if it happens at the wrong time in the React lifecycle.
The first problem is not solvable, but useInsertionEffect helps you solve the second problem.
Call useInsertionEffect to insert the styles before any layout Effects fire:
// Inside your CSS-in-JS library
let isInserted = new Set();
function useCSS(rule) {
 useInsertionEffect(() => {
   // As explained earlier, we don't recommend runtime injection of <style> tags.
   // But if you have to do it, then it's important to do in useInsertionEffect.
   if (!isInserted.has(rule)) {
     isInserted.add(rule);
     document.head.appendChild(getStyleForRule(rule));
   }
 });
 return rule;
}

function Button() {
 const className = useCSS('...');
 return <div className={className} />;
}
Similarly to useEffect, useInsertionEffect does not run on the server. If you need to collect which CSS rules have been used on the server, you can do it during rendering:
let collectedRulesSet = new Set();

function useCSS(rule) {
 if (typeof window === 'undefined') {
   collectedRulesSet.add(rule);
 }
 useInsertionEffect(() => {
   // ...
 });
 return rule;
}
Read more about upgrading CSS-in-JS libraries with runtime injection to useInsertionEffect.
Deep Dive
How is this better than injecting styles during rendering or useLayoutEffect? 
Hide Details
If you insert styles during rendering and React is processing a non-blocking update, the browser will recalculate the styles every single frame while rendering a component tree, which can be extremely slow.
useInsertionEffect is better than inserting styles during useLayoutEffect or useEffect because it ensures that by the time other Effects run in your components, the <style> tags have already been inserted. Otherwise, layout calculations in regular Effects would be wrong due to outdated styles.
PrevioususeImperativeHandle
useLayoutEffect
Pitfall
useLayoutEffect can hurt performance. Prefer useEffect when possible.
useLayoutEffect is a version of useEffect that fires before the browser repaints the screen.
useLayoutEffect(setup, dependencies?)
Reference
useLayoutEffect(setup, dependencies?)
Usage
Measuring layout before the browser repaints the screen
Troubleshooting
I’m getting an error: “useLayoutEffect does nothing on the server”

Reference 
useLayoutEffect(setup, dependencies?) 
Call useLayoutEffect to perform the layout measurements before the browser repaints the screen:
import { useState, useRef, useLayoutEffect } from 'react';

function Tooltip() {
 const ref = useRef(null);
 const [tooltipHeight, setTooltipHeight] = useState(0);

 useLayoutEffect(() => {
   const { height } = ref.current.getBoundingClientRect();
   setTooltipHeight(height);
 }, []);
 // ...
See more examples below.
Parameters 
setup: The function with your Effect’s logic. Your setup function may also optionally return a cleanup function. Before your component is added to the DOM, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. Before your component is removed from the DOM, React will run your cleanup function.
optional dependencies: The list of all reactive values referenced inside of the setup code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison. If you omit this argument, your Effect will re-run after every re-render of the component.
Returns 
useLayoutEffect returns undefined.
Caveats 
useLayoutEffect is a Hook, so you can only call it at the top level of your component or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a component and move the Effect there.
When Strict Mode is on, React will run one extra development-only setup+cleanup cycle before the first real setup. This is a stress-test that ensures that your cleanup logic “mirrors” your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, implement the cleanup function.
If some of your dependencies are objects or functions defined inside the component, there is a risk that they will cause the Effect to re-run more often than needed. To fix this, remove unnecessary object and function dependencies. You can also extract state updates and non-reactive logic outside of your Effect.
Effects only run on the client. They don’t run during server rendering.
The code inside useLayoutEffect and all state updates scheduled from it block the browser from repainting the screen. When used excessively, this makes your app slow. When possible, prefer useEffect.
If you trigger a state update inside useLayoutEffect, React will execute all remaining Effects immediately including useEffect.

Usage 
Measuring layout before the browser repaints the screen 
Most components don’t need to know their position and size on the screen to decide what to render. They only return some JSX. Then the browser calculates their layout (position and size) and repaints the screen.
Sometimes, that’s not enough. Imagine a tooltip that appears next to some element on hover. If there’s enough space, the tooltip should appear above the element, but if it doesn’t fit, it should appear below. In order to render the tooltip at the right final position, you need to know its height (i.e. whether it fits at the top).
To do this, you need to render in two passes:
Render the tooltip anywhere (even with a wrong position).
Measure its height and decide where to place the tooltip.
Render the tooltip again in the correct place.
All of this needs to happen before the browser repaints the screen. You don’t want the user to see the tooltip moving. Call useLayoutEffect to perform the layout measurements before the browser repaints the screen:
function Tooltip() {
 const ref = useRef(null);
 const [tooltipHeight, setTooltipHeight] = useState(0); // You don't know real height yet

 useLayoutEffect(() => {
   const { height } = ref.current.getBoundingClientRect();
   setTooltipHeight(height); // Re-render now that you know the real height
 }, []);

 // ...use tooltipHeight in the rendering logic below...
}
Here’s how this works step by step:
Tooltip renders with the initial tooltipHeight = 0 (so the tooltip may be wrongly positioned).
React places it in the DOM and runs the code in useLayoutEffect.
Your useLayoutEffect measures the height of the tooltip content and triggers an immediate re-render.
Tooltip renders again with the real tooltipHeight (so the tooltip is correctly positioned).
React updates it in the DOM, and the browser finally displays the tooltip.
Hover over the buttons below and see how the tooltip adjusts its position depending on whether it fits:
App.jsButtonWithTooltip.jsTooltip.jsTooltipContainer.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
import { useRef, useLayoutEffect, useState } from 'react';
import { createPortal } from 'react-dom';
import TooltipContainer from './TooltipContainer.js';

export default function Tooltip({ children, targetRect }) {
 const ref = useRef(null);
 const [tooltipHeight, setTooltipHeight] = useState(0);

 useLayoutEffect(() => {
   const { height } = ref.current.getBoundingClientRect();
   setTooltipHeight(height);
   console.log('Measured tooltip height: ' + height);
 }, []);

 let tooltipX = 0;
 let tooltipY = 0;
 if (targetRect !== null) {
   tooltipX = targetRect.left;
   tooltipY = targetRect.top - tooltipHeight;
   if (tooltipY < 0) {
     // It doesn't fit above, so place below.
     tooltipY = targetRect.bottom;
   }
 }

 return createPortal(
   <TooltipContainer x={tooltipX} y={tooltipY} contentRef={ref}>
     {children}
   </TooltipContainer>,
   document.body
 );
}

Show more
Notice that even though the Tooltip component has to render in two passes (first, with tooltipHeight initialized to 0 and then with the real measured height), you only see the final result. This is why you need useLayoutEffect instead of useEffect for this example. Let’s look at the difference in detail below.
useLayoutEffect vs useEffect
1. useLayoutEffect blocks the browser from repainting2. useEffect does not block the browser
Example 1 of 2: useLayoutEffect blocks the browser from repainting 
React guarantees that the code inside useLayoutEffect and any state updates scheduled inside it will be processed before the browser repaints the screen. This lets you render the tooltip, measure it, and re-render the tooltip again without the user noticing the first extra render. In other words, useLayoutEffect blocks the browser from painting.
App.jsButtonWithTooltip.jsTooltip.jsTooltipContainer.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
import { useRef, useLayoutEffect, useState } from 'react';
import { createPortal } from 'react-dom';
import TooltipContainer from './TooltipContainer.js';

export default function Tooltip({ children, targetRect }) {
 const ref = useRef(null);
 const [tooltipHeight, setTooltipHeight] = useState(0);

 useLayoutEffect(() => {
   const { height } = ref.current.getBoundingClientRect();
   setTooltipHeight(height);
 }, []);

 let tooltipX = 0;
 let tooltipY = 0;
 if (targetRect !== null) {
   tooltipX = targetRect.left;
   tooltipY = targetRect.top - tooltipHeight;
   if (tooltipY < 0) {
     // It doesn't fit above, so place below.
     tooltipY = targetRect.bottom;
   }
 }

 return createPortal(
   <TooltipContainer x={tooltipX} y={tooltipY} contentRef={ref}>
     {children}
   </TooltipContainer>,
   document.body
 );
}

Show more
Next Example
Note
Rendering in two passes and blocking the browser hurts performance. Try to avoid this when you can.

Troubleshooting 
I’m getting an error: “useLayoutEffect does nothing on the server” 
The purpose of useLayoutEffect is to let your component use layout information for rendering:
Render the initial content.
Measure the layout before the browser repaints the screen.
Render the final content using the layout information you’ve read.
When you or your framework uses server rendering, your React app renders to HTML on the server for the initial render. This lets you show the initial HTML before the JavaScript code loads.
The problem is that on the server, there is no layout information.
In the earlier example, the useLayoutEffect call in the Tooltip component lets it position itself correctly (either above or below content) depending on the content height. If you tried to render Tooltip as a part of the initial server HTML, this would be impossible to determine. On the server, there is no layout yet! So, even if you rendered it on the server, its position would “jump” on the client after the JavaScript loads and runs.
Usually, components that rely on layout information don’t need to render on the server anyway. For example, it probably doesn’t make sense to show a Tooltip during the initial render. It is triggered by a client interaction.
However, if you’re running into this problem, you have a few different options:
Replace useLayoutEffect with useEffect. This tells React that it’s okay to display the initial render result without blocking the paint (because the original HTML will become visible before your Effect runs).
Alternatively, mark your component as client-only. This tells React to replace its content up to the closest <Suspense> boundary with a loading fallback (for example, a spinner or a glimmer) during server rendering.
Alternatively, you can render a component with useLayoutEffect only after hydration. Keep a boolean isMounted state that’s initialized to false, and set it to true inside a useEffect call. Your rendering logic can then be like return isMounted ? <RealContent /> : <FallbackContent />. On the server and during the hydration, the user will see FallbackContent which should not call useLayoutEffect. Then React will replace it with RealContent which runs on the client only and can include useLayoutEffect calls.
If you synchronize your component with an external data store and rely on useLayoutEffect for different reasons than measuring layout, consider useSyncExternalStore instead which supports server rendering.

useMemo
useMemo is a React Hook that lets you cache the result of a calculation between re-renders.
const cachedValue = useMemo(calculateValue, dependencies)
Reference
useMemo(calculateValue, dependencies)
Usage
Skipping expensive recalculations
Skipping re-rendering of components
Preventing an Effect from firing too often
Memoizing a dependency of another Hook
Memoizing a function
Troubleshooting
My calculation runs twice on every re-render
My useMemo call is supposed to return an object, but returns undefined
Every time my component renders, the calculation in useMemo re-runs
I need to call useMemo for each list item in a loop, but it’s not allowed

Reference 
useMemo(calculateValue, dependencies) 
Call useMemo at the top level of your component to cache a calculation between re-renders:
import { useMemo } from 'react';

function TodoList({ todos, tab }) {
 const visibleTodos = useMemo(
   () => filterTodos(todos, tab),
   [todos, tab]
 );
 // ...
}
See more examples below.
Parameters 
calculateValue: The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type. React will call your function during the initial render. On next renders, React will return the same value again if the dependencies have not changed since the last render. Otherwise, it will call calculateValue, return its result, and store it so it can be reused later.
dependencies: The list of all reactive values referenced inside of the calculateValue code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison.
Returns 
On the initial render, useMemo returns the result of calling calculateValue with no arguments.
During next renders, it will either return an already stored value from the last render (if the dependencies haven’t changed), or call calculateValue again, and return the result that calculateValue has returned.
Caveats 
useMemo is a Hook, so you can only call it at the top level of your component or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.
In Strict Mode, React will call your calculation function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your calculation function is pure (as it should be), this should not affect your logic. The result from one of the calls will be ignored.
React will not throw away the cached value unless there is a specific reason to do that. For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cache—for example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should be fine if you rely on useMemo solely as a performance optimization. Otherwise, a state variable or a ref may be more appropriate.
Note
Caching return values like this is also known as memoization, which is why this Hook is called useMemo.

Usage 
Skipping expensive recalculations 
To cache a calculation between re-renders, wrap it in a useMemo call at the top level of your component:
import { useMemo } from 'react';

function TodoList({ todos, tab, theme }) {
 const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);
 // ...
}
You need to pass two things to useMemo:
A calculation function that takes no arguments, like () =>, and returns what you wanted to calculate.
A list of dependencies including every value within your component that’s used inside your calculation.
On the initial render, the value you’ll get from useMemo will be the result of calling your calculation.
On every subsequent render, React will compare the dependencies with the dependencies you passed during the last render. If none of the dependencies have changed (compared with Object.is), useMemo will return the value you already calculated before. Otherwise, React will re-run your calculation and return the new value.
In other words, useMemo caches a calculation result between re-renders until its dependencies change.
Let’s walk through an example to see when this is useful.
By default, React will re-run the entire body of your component every time that it re-renders. For example, if this TodoList updates its state or receives new props from its parent, the filterTodos function will re-run:
function TodoList({ todos, tab, theme }) {
 const visibleTodos = filterTodos(todos, tab);
 // ...
}
Usually, this isn’t a problem because most calculations are very fast. However, if you’re filtering or transforming a large array, or doing some expensive computation, you might want to skip doing it again if data hasn’t changed. If both todos and tab are the same as they were during the last render, wrapping the calculation in useMemo like earlier lets you reuse visibleTodos you’ve already calculated before.
This type of caching is called memoization.
Note
You should only rely on useMemo as a performance optimization. If your code doesn’t work without it, find the underlying problem and fix it first. Then you may add useMemo to improve performance.
Deep Dive
How to tell if a calculation is expensive? 
Hide Details
In general, unless you’re creating or looping over thousands of objects, it’s probably not expensive. If you want to get more confidence, you can add a console log to measure the time spent in a piece of code:
console.time('filter array');
const visibleTodos = filterTodos(todos, tab);
console.timeEnd('filter array');
Perform the interaction you’re measuring (for example, typing into the input). You will then see logs like filter array: 0.15ms in your console. If the overall logged time adds up to a significant amount (say, 1ms or more), it might make sense to memoize that calculation. As an experiment, you can then wrap the calculation in useMemo to verify whether the total logged time has decreased for that interaction or not:
console.time('filter array');
const visibleTodos = useMemo(() => {
 return filterTodos(todos, tab); // Skipped if todos and tab haven't changed
}, [todos, tab]);
console.timeEnd('filter array');
useMemo won’t make the first render faster. It only helps you skip unnecessary work on updates.
Keep in mind that your machine is probably faster than your users’ so it’s a good idea to test the performance with an artificial slowdown. For example, Chrome offers a CPU Throttling option for this.
Also note that measuring performance in development will not give you the most accurate results. (For example, when Strict Mode is on, you will see each component render twice rather than once.) To get the most accurate timings, build your app for production and test it on a device like your users have.
Deep Dive
Should you add useMemo everywhere? 
Hide Details
If your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.
Optimizing with useMemo  is only valuable in a few cases:
The calculation you’re putting in useMemo is noticeably slow, and its dependencies rarely change.
You pass it as a prop to a component wrapped in memo. You want to skip re-rendering if the value hasn’t changed. Memoization lets your component re-render only when dependencies aren’t the same.
The value you’re passing is later used as a dependency of some Hook. For example, maybe another useMemo calculation value depends on it. Or maybe you are depending on this value from useEffect.
There is no benefit to wrapping a calculation in useMemo in other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside of this approach is that code becomes less readable. Also, not all memoization is effective: a single value that’s “always new” is enough to break memoization for an entire component.
In practice, you can make a lot of memoization unnecessary by following a few principles:
When a component visually wraps other components, let it accept JSX as children. This way, when the wrapper component updates its own state, React knows that its children don’t need to re-render.
Prefer local state and don’t lift state up any further than necessary. For example, don’t keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library.
Keep your rendering logic pure. If re-rendering a component causes a problem or produces some noticeable visual artifact, it’s a bug in your component! Fix the bug instead of adding memoization.
Avoid unnecessary Effects that update state. Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over.
Try to remove unnecessary dependencies from your Effects. For example, instead of memoization, it’s often simpler to move some object or a function inside an Effect or outside the component.
If a specific interaction still feels laggy, use the React Developer Tools profiler to see which components would benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so it’s good to follow them in any case. In the long term, we’re researching doing granular memoization automatically to solve this once and for all.
The difference between useMemo and calculating a value directly
1. Skipping recalculation with useMemo2. Always recalculating a value
Example 1 of 2: Skipping recalculation with useMemo 
In this example, the filterTodos implementation is artificially slowed down so that you can see what happens when some JavaScript function you’re calling during rendering is genuinely slow. Try switching the tabs and toggling the theme.
Switching the tabs feels slow because it forces the slowed down filterTodos to re-execute. That’s expected because the tab has changed, and so the entire calculation needs to re-run. (If you’re curious why it runs twice, it’s explained here.)
Toggle the theme. Thanks to useMemo, it’s fast despite the artificial slowdown! The slow filterTodos call was skipped because both todos and tab (which you pass as dependencies to useMemo) haven’t changed since the last render.
App.jsTodoList.jsutils.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
import { useMemo } from 'react';
import { filterTodos } from './utils.js'

export default function TodoList({ todos, theme, tab }) {
 const visibleTodos = useMemo(
   () => filterTodos(todos, tab),
   [todos, tab]
 );
 return (
   <div className={theme}>
     <p><b>Note: <code>filterTodos</code> is artificially slowed down!</b></p>
     <ul>
       {visibleTodos.map(todo => (
         <li key={todo.id}>
           {todo.completed ?
             <s>{todo.text}</s> :
             todo.text
           }
         </li>
       ))}
     </ul>
   </div>
 );
}

Show more
Next Example

Skipping re-rendering of components 
In some cases, useMemo can also help you optimize performance of re-rendering child components. To illustrate this, let’s say this TodoList component passes the visibleTodos as a prop to the child List component:
export default function TodoList({ todos, tab, theme }) {
 // ...
 return (
   <div className={theme}>
     <List items={visibleTodos} />
   </div>
 );
}
You’ve noticed that toggling the theme prop freezes the app for a moment, but if you remove <List /> from your JSX, it feels fast. This tells you that it’s worth trying to optimize the List component.
By default, when a component re-renders, React re-renders all of its children recursively. This is why, when TodoList re-renders with a different theme, the List component also re-renders. This is fine for components that don’t require much calculation to re-render. But if you’ve verified that a re-render is slow, you can tell List to skip re-rendering when its props are the same as on last render by wrapping it in memo:
import { memo } from 'react';

const List = memo(function List({ items }) {
 // ...
});
With this change, List will skip re-rendering if all of its props are the same as on the last render. This is where caching the calculation becomes important! Imagine that you calculated visibleTodos without useMemo:
export default function TodoList({ todos, tab, theme }) {
 // Every time the theme changes, this will be a different array...
 const visibleTodos = filterTodos(todos, tab);
 return (
   <div className={theme}>
     {/* ... so List's props will never be the same, and it will re-render every time */}
     <List items={visibleTodos} />
   </div>
 );
}
In the above example, the filterTodos function always creates a different array, similar to how the {} object literal always creates a new object. Normally, this wouldn’t be a problem, but it means that List props will never be the same, and your memo optimization won’t work. This is where useMemo comes in handy:
export default function TodoList({ todos, tab, theme }) {
 // Tell React to cache your calculation between re-renders...
 const visibleTodos = useMemo(
   () => filterTodos(todos, tab),
   [todos, tab] // ...so as long as these dependencies don't change...
 );
 return (
   <div className={theme}>
     {/* ...List will receive the same props and can skip re-rendering */}
     <List items={visibleTodos} />
   </div>
 );
}
By wrapping the visibleTodos calculation in useMemo, you ensure that it has the same value between the re-renders (until dependencies change). You don’t have to wrap a calculation in useMemo unless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped in memo, and this lets it skip re-rendering. There are a few other reasons to add useMemo which are described further on this page.
Deep Dive
Memoizing individual JSX nodes 
Hide Details
Instead of wrapping List in memo, you could wrap the <List /> JSX node itself in useMemo:
export default function TodoList({ todos, tab, theme }) {
 const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);
 const children = useMemo(() => <List items={visibleTodos} />, [visibleTodos]);
 return (
   <div className={theme}>
     {children}
   </div>
 );
}
The behavior would be the same. If the visibleTodos haven’t changed, List won’t be re-rendered.
A JSX node like <List items={visibleTodos} /> is an object like { type: List, props: { items: visibleTodos } }. Creating this object is very cheap, but React doesn’t know whether its contents is the same as last time or not. This is why by default, React will re-render the List component.
However, if React sees the same exact JSX as during the previous render, it won’t try to re-render your component. This is because JSX nodes are immutable. A JSX node object could not have changed over time, so React knows it’s safe to skip a re-render. However, for this to work, the node has to actually be the same object, not merely look the same in code. This is what useMemo does in this example.
Manually wrapping JSX nodes into useMemo is not convenient. For example, you can’t do this conditionally. This is usually why you would wrap components with memo instead of wrapping JSX nodes.
The difference between skipping re-renders and always re-rendering
1. Skipping re-rendering with useMemo and memo2. Always re-rendering a component
Example 1 of 2: Skipping re-rendering with useMemo and memo 
In this example, the List component is artificially slowed down so that you can see what happens when a React component you’re rendering is genuinely slow. Try switching the tabs and toggling the theme.
Switching the tabs feels slow because it forces the slowed down List to re-render. That’s expected because the tab has changed, and so you need to reflect the user’s new choice on the screen.
Next, try toggling the theme. Thanks to useMemo together with memo, it’s fast despite the artificial slowdown! The List skipped re-rendering because the visibleTodos array has not changed since the last render. The visibleTodos array has not changed because both todos and tab (which you pass as dependencies to useMemo) haven’t changed since the last render.
App.jsTodoList.jsList.jsutils.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
import { useMemo } from 'react';
import List from './List.js';
import { filterTodos } from './utils.js'

export default function TodoList({ todos, theme, tab }) {
 const visibleTodos = useMemo(
   () => filterTodos(todos, tab),
   [todos, tab]
 );
 return (
   <div className={theme}>
     <p><b>Note: <code>List</code> is artificially slowed down!</b></p>
     <List items={visibleTodos} />
   </div>
 );
}

Console (2)
[ARTIFICIALLY SLOW] Rendering <List /> with 50 items
[ARTIFICIALLY SLOW] Rendering <List /> with 50 items
Show more
Next Example

Preventing an Effect from firing too often 
Sometimes, you might want to use a value inside an Effect:
function ChatRoom({ roomId }) {
 const [message, setMessage] = useState('');

 const options = {
   serverUrl: 'https://localhost:1234',
   roomId: roomId
 }

 useEffect(() => {
   const connection = createConnection(options);
   connection.connect();
   // ...
This creates a problem. Every reactive value must be declared as a dependency of your Effect. However, if you declare options as a dependency, it will cause your Effect to constantly reconnect to the chat room:
 useEffect(() => {
   const connection = createConnection(options);
   connection.connect();
   return () => connection.disconnect();
 }, [options]); // 🔴 Problem: This dependency changes on every render
 // ...
To solve this, you can wrap the object you need to call from an Effect in useMemo:
function ChatRoom({ roomId }) {
 const [message, setMessage] = useState('');

 const options = useMemo(() => {
   return {
     serverUrl: 'https://localhost:1234',
     roomId: roomId
   };
 }, [roomId]); // ✅ Only changes when roomId changes

 useEffect(() => {
   const connection = createConnection(options);
   connection.connect();
   return () => connection.disconnect();
 }, [options]); // ✅ Only changes when options changes
 // ...
This ensures that the options object is the same between re-renders if useMemo returns the cached object.
However, since useMemo is performance optimization, not a semantic guarantee, React may throw away the cached value if there is a specific reason to do that. This will also cause the effect to re-fire, so it’s even better to remove the need for a function dependency by moving your object inside the Effect:
function ChatRoom({ roomId }) {
 const [message, setMessage] = useState('');

 useEffect(() => {
   const options = { // ✅ No need for useMemo or object dependencies!
     serverUrl: 'https://localhost:1234',
     roomId: roomId
   }
  
   const connection = createConnection(options);
   connection.connect();
   return () => connection.disconnect();
 }, [roomId]); // ✅ Only changes when roomId changes
 // ...
Now your code is simpler and doesn’t need useMemo. Learn more about removing Effect dependencies.
Memoizing a dependency of another Hook 
Suppose you have a calculation that depends on an object created directly in the component body:
function Dropdown({ allItems, text }) {
 const searchOptions = { matchMode: 'whole-word', text };

 const visibleItems = useMemo(() => {
   return searchItems(allItems, searchOptions);
 }, [allItems, searchOptions]); // 🚩 Caution: Dependency on an object created in the component body
 // ...
Depending on an object like this defeats the point of memoization. When a component re-renders, all of the code directly inside the component body runs again. The lines of code creating the searchOptions object will also run on every re-render. Since searchOptions is a dependency of your useMemo call, and it’s different every time, React knows the dependencies are different, and recalculate searchItems every time.
To fix this, you could memoize the searchOptions object itself before passing it as a dependency:
function Dropdown({ allItems, text }) {
 const searchOptions = useMemo(() => {
   return { matchMode: 'whole-word', text };
 }, [text]); // ✅ Only changes when text changes

 const visibleItems = useMemo(() => {
   return searchItems(allItems, searchOptions);
 }, [allItems, searchOptions]); // ✅ Only changes when allItems or searchOptions changes
 // ...
In the example above, if the text did not change, the searchOptions object also won’t change. However, an even better fix is to move the searchOptions object declaration inside of the useMemo calculation function:
function Dropdown({ allItems, text }) {
 const visibleItems = useMemo(() => {
   const searchOptions = { matchMode: 'whole-word', text };
   return searchItems(allItems, searchOptions);
 }, [allItems, text]); // ✅ Only changes when allItems or text changes
 // ...
Now your calculation depends on text directly (which is a string and can’t “accidentally” become different).

Memoizing a function 
Suppose the Form component is wrapped in memo. You want to pass a function to it as a prop:
export default function ProductPage({ productId, referrer }) {
 function handleSubmit(orderDetails) {
   post('/product/' + productId + '/buy', {
     referrer,
     orderDetails
   });
 }

 return <Form onSubmit={handleSubmit} />;
}
Just as {} creates a different object, function declarations like function() {} and expressions like () => {} produce a different function on every re-render. By itself, creating a new function is not a problem. This is not something to avoid! However, if the Form component is memoized, presumably you want to skip re-rendering it when no props have changed. A prop that is always different would defeat the point of memoization.
To memoize a function with useMemo, your calculation function would have to return another function:
export default function Page({ productId, referrer }) {
 const handleSubmit = useMemo(() => {
   return (orderDetails) => {
     post('/product/' + productId + '/buy', {
       referrer,
       orderDetails
     });
   };
 }, [productId, referrer]);

 return <Form onSubmit={handleSubmit} />;
}
This looks clunky! Memoizing functions is common enough that React has a built-in Hook specifically for that. Wrap your functions into useCallback instead of useMemo to avoid having to write an extra nested function:
export default function Page({ productId, referrer }) {
 const handleSubmit = useCallback((orderDetails) => {
   post('/product/' + productId + '/buy', {
     referrer,
     orderDetails
   });
 }, [productId, referrer]);

 return <Form onSubmit={handleSubmit} />;
}
The two examples above are completely equivalent. The only benefit to useCallback is that it lets you avoid writing an extra nested function inside. It doesn’t do anything else. Read more about useCallback.

Troubleshooting 
My calculation runs twice on every re-render 
In Strict Mode, React will call some of your functions twice instead of once:
function TodoList({ todos, tab }) {
 // This component function will run twice for every render.

 const visibleTodos = useMemo(() => {
   // This calculation will run twice if any of the dependencies change.
   return filterTodos(todos, tab);
 }, [todos, tab]);

 // ...
This is expected and shouldn’t break your code.
This development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component and calculation functions are pure, this shouldn’t affect your logic. However, if they are accidentally impure, this helps you notice and fix the mistake.
For example, this impure calculation function mutates an array you received as a prop:
 const visibleTodos = useMemo(() => {
   // 🚩 Mistake: mutating a prop
   todos.push({ id: 'last', text: 'Go for a walk!' });
   const filtered = filterTodos(todos, tab);
   return filtered;
 }, [todos, tab]);
React calls your function twice, so you’d notice the todo is added twice. Your calculation shouldn’t change any existing objects, but it’s okay to change any new objects you created during the calculation. For example, if the filterTodos function always returns a different array, you can mutate that array instead:
 const visibleTodos = useMemo(() => {
   const filtered = filterTodos(todos, tab);
   // ✅ Correct: mutating an object you created during the calculation
   filtered.push({ id: 'last', text: 'Go for a walk!' });
   return filtered;
 }, [todos, tab]);
Read keeping components pure to learn more about purity.
Also, check out the guides on updating objects and updating arrays without mutation.

My useMemo call is supposed to return an object, but returns undefined 
This code doesn’t work:
 // 🔴 You can't return an object from an arrow function with () => {
 const searchOptions = useMemo(() => {
   matchMode: 'whole-word',
   text: text
 }, [text]);
In JavaScript, () => { starts the arrow function body, so the { brace is not a part of your object. This is why it doesn’t return an object, and leads to mistakes. You could fix it by adding parentheses like ({ and }):
 // This works, but is easy for someone to break again
 const searchOptions = useMemo(() => ({
   matchMode: 'whole-word',
   text: text
 }), [text]);
However, this is still confusing and too easy for someone to break by removing the parentheses.
To avoid this mistake, write a return statement explicitly:
 // ✅ This works and is explicit
 const searchOptions = useMemo(() => {
   return {
     matchMode: 'whole-word',
     text: text
   };
 }, [text]);

Every time my component renders, the calculation in useMemo re-runs 
Make sure you’ve specified the dependency array as a second argument!
If you forget the dependency array, useMemo will re-run the calculation every time:
function TodoList({ todos, tab }) {
 // 🔴 Recalculates every time: no dependency array
 const visibleTodos = useMemo(() => filterTodos(todos, tab));
 // ...
This is the corrected version passing the dependency array as a second argument:
function TodoList({ todos, tab }) {
 // ✅ Does not recalculate unnecessarily
 const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);
 // ...
If this doesn’t help, then the problem is that at least one of your dependencies is different from the previous render. You can debug this problem by manually logging your dependencies to the console:
 const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);
 console.log([todos, tab]);
You can then right-click on the arrays from different re-renders in the console and select “Store as a global variable” for both of them. Assuming the first one got saved as temp1 and the second one got saved as temp2, you can then use the browser console to check whether each dependency in both arrays is the same:
Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?
Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?
Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ...
When you find which dependency breaks memoization, either find a way to remove it, or memoize it as well.

I need to call useMemo for each list item in a loop, but it’s not allowed 
Suppose the Chart component is wrapped in memo. You want to skip re-rendering every Chart in the list when the ReportList component re-renders. However, you can’t call useMemo in a loop:
function ReportList({ items }) {
 return (
   <article>
     {items.map(item => {
       // 🔴 You can't call useMemo in a loop like this:
       const data = useMemo(() => calculateReport(item), [item]);
       return (
         <figure key={item.id}>
           <Chart data={data} />
         </figure>
       );
     })}
   </article>
 );
}
Instead, extract a component for each item and memoize data for individual items:
function ReportList({ items }) {
 return (
   <article>
     {items.map(item =>
       <Report key={item.id} item={item} />
     )}
   </article>
 );
}

function Report({ item }) {
 // ✅ Call useMemo at the top level:
 const data = useMemo(() => calculateReport(item), [item]);
 return (
   <figure>
     <Chart data={data} />
   </figure>
 );
}
Alternatively, you could remove useMemo and instead wrap Report itself in memo. If the item prop does not change, Report will skip re-rendering, so Chart will skip re-rendering too:
function ReportList({ items }) {
 // ...
}

const Report = memo(function Report({ item }) {
 const data = calculateReport(item);
 return (
   <figure>
     <Chart data={data} />
   </figure>
 );
});

 
useReducer
useReducer is a React Hook that lets you add a reducer to your component.
const [state, dispatch] = useReducer(reducer, initialArg, init?)
Reference
useReducer(reducer, initialArg, init?)
dispatch function
Usage
Adding a reducer to a component
Writing the reducer function
Avoiding recreating the initial state
Troubleshooting
I’ve dispatched an action, but logging gives me the old state value
I’ve dispatched an action, but the screen doesn’t update
A part of my reducer state becomes undefined after dispatching
My entire reducer state becomes undefined after dispatching
I’m getting an error: “Too many re-renders”
My reducer or initializer function runs twice

Reference 
useReducer(reducer, initialArg, init?) 
Call useReducer at the top level of your component to manage its state with a reducer.
import { useReducer } from 'react';

function reducer(state, action) {
 // ...
}

function MyComponent() {
 const [state, dispatch] = useReducer(reducer, { age: 42 });
 // ...
See more examples below.
Parameters 
reducer: The reducer function that specifies how the state gets updated. It must be pure, should take the state and action as arguments, and should return the next state. State and action can be of any types.
initialArg: The value from which the initial state is calculated. It can be a value of any type. How the initial state is calculated from it depends on the next init argument.
optional init: The initializer function that should return the initial state. If it’s not specified, the initial state is set to initialArg. Otherwise, the initial state is set to the result of calling init(initialArg).
Returns 
useReducer returns an array with exactly two values:
The current state. During the first render, it’s set to init(initialArg) or initialArg (if there’s no init).
The dispatch function that lets you update the state to a different value and trigger a re-render.
Caveats 
useReducer is a Hook, so you can only call it at the top level of your component or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.
The dispatch function has a stable identity, so you will often see it omitted from Effect dependencies, but including it will not cause the Effect to fire. If the linter lets you omit a dependency without errors, it is safe to do. Learn more about removing Effect dependencies.
In Strict Mode, React will call your reducer and initializer twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your reducer and initializer are pure (as they should be), this should not affect your logic. The result from one of the calls is ignored.

dispatch function 
The dispatch function returned by useReducer lets you update the state to a different value and trigger a re-render. You need to pass the action as the only argument to the dispatch function:
const [state, dispatch] = useReducer(reducer, { age: 42 });

function handleClick() {
 dispatch({ type: 'incremented_age' });
 // ...
React will set the next state to the result of calling the reducer function you’ve provided with the current state and the action you’ve passed to dispatch.
Parameters 
action: The action performed by the user. It can be a value of any type. By convention, an action is usually an object with a type property identifying it and, optionally, other properties with additional information.
Returns 
dispatch functions do not have a return value.
Caveats 
The dispatch function only updates the state variable for the next render. If you read the state variable after calling the dispatch function, you will still get the old value that was on the screen before your call.
If the new value you provide is identical to the current state, as determined by an Object.is comparison, React will skip re-rendering the component and its children. This is an optimization. React may still need to call your component before ignoring the result, but it shouldn’t affect your code.
React batches state updates. It updates the screen after all the event handlers have run and have called their set functions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can use flushSync.

Usage 
Adding a reducer to a component 
Call useReducer at the top level of your component to manage state with a reducer.
import { useReducer } from 'react';

function reducer(state, action) {
 // ...
}

function MyComponent() {
 const [state, dispatch] = useReducer(reducer, { age: 42 });
 // ...
useReducer returns an array with exactly two items:
The current state of this state variable, initially set to the initial state you provided.
The dispatch function that lets you change it in response to interaction.
To update what’s on the screen, call dispatch with an object representing what the user did, called an action:
function handleClick() {
 dispatch({ type: 'incremented_age' });
}
React will pass the current state and the action to your reducer function. Your reducer will calculate and return the next state. React will store that next state, render your component with it, and update the UI.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
import { useReducer } from 'react';

function reducer(state, action) {
 if (action.type === 'incremented_age') {
   return {
     age: state.age + 1
   };
 }
 throw Error('Unknown action.');
}

export default function Counter() {
 const [state, dispatch] = useReducer(reducer, { age: 42 });

 return (
   <>
     <button onClick={() => {
       dispatch({ type: 'incremented_age' })
     }}>
       Increment age
     </button>
     <p>Hello! You are {state.age}.</p>
   </>
 );
}

Show more
useReducer is very similar to useState, but it lets you move the state update logic from event handlers into a single function outside of your component. Read more about choosing between useState and useReducer.

Writing the reducer function 
A reducer function is declared like this:
function reducer(state, action) {
 // ...
}
Then you need to fill in the code that will calculate and return the next state. By convention, it is common to write it as a switch statement. For each case in the switch, calculate and return some next state.
function reducer(state, action) {
 switch (action.type) {
   case 'incremented_age': {
     return {
       name: state.name,
       age: state.age + 1
     };
   }
   case 'changed_name': {
     return {
       name: action.nextName,
       age: state.age
     };
   }
 }
 throw Error('Unknown action: ' + action.type);
}
Actions can have any shape. By convention, it’s common to pass objects with a type property identifying the action. It should include the minimal necessary information that the reducer needs to compute the next state.
function Form() {
 const [state, dispatch] = useReducer(reducer, { name: 'Taylor', age: 42 });

 function handleButtonClick() {
   dispatch({ type: 'incremented_age' });
 }

 function handleInputChange(e) {
   dispatch({
     type: 'changed_name',
     nextName: e.target.value
   });
 }
 // ...
The action type names are local to your component. Each action describes a single interaction, even if that leads to multiple changes in data. The shape of the state is arbitrary, but usually it’ll be an object or an array.
Read extracting state logic into a reducer to learn more.
Pitfall
State is read-only. Don’t modify any objects or arrays in state:
function reducer(state, action) {
 switch (action.type) {
   case 'incremented_age': {
     // 🚩 Don't mutate an object in state like this:
     state.age = state.age + 1;
     return state;
   }
Instead, always return new objects from your reducer:
function reducer(state, action) {
 switch (action.type) {
   case 'incremented_age': {
     // ✅ Instead, return a new object
     return {
       ...state,
       age: state.age + 1
     };
   }
Read updating objects in state and updating arrays in state to learn more.
Basic useReducer examples
1. Form (object)2. Todo list (array)3. Writing concise update logic with Immer
Example 1 of 3: Form (object) 
In this example, the reducer manages a state object with two fields: name and age.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
import { useReducer } from 'react';

function reducer(state, action) {
 switch (action.type) {
   case 'incremented_age': {
     return {
       name: state.name,
       age: state.age + 1
     };
   }
   case 'changed_name': {
     return {
       name: action.nextName,
       age: state.age
     };
   }
 }
 throw Error('Unknown action: ' + action.type);
}

const initialState = { name: 'Taylor', age: 42 };

export default function Form() {
 const [state, dispatch] = useReducer(reducer, initialState);

 function handleButtonClick() {
   dispatch({ type: 'incremented_age' });
 }

 function handleInputChange(e) {
   dispatch({
     type: 'changed_name',
     nextName: e.target.value
   });
 }

Show more
Next Example

Avoiding recreating the initial state 
React saves the initial state once and ignores it on the next renders.
function createInitialState(username) {
 // ...
}

function TodoList({ username }) {
 const [state, dispatch] = useReducer(reducer, createInitialState(username));
 // ...
Although the result of createInitialState(username) is only used for the initial render, you’re still calling this function on every render. This can be wasteful if it’s creating large arrays or performing expensive calculations.
To solve this, you may pass it as an initializer function to useReducer as the third argument instead:
function createInitialState(username) {
 // ...
}

function TodoList({ username }) {
 const [state, dispatch] = useReducer(reducer, username, createInitialState);
 // ...
Notice that you’re passing createInitialState, which is the function itself, and not createInitialState(), which is the result of calling it. This way, the initial state does not get re-created after initialization.
In the above example, createInitialState takes a username argument. If your initializer doesn’t need any information to compute the initial state, you may pass null as the second argument to useReducer.
The difference between passing an initializer and passing the initial state directly
1. Passing the initializer function2. Passing the initial state directly
Example 1 of 2: Passing the initializer function 
This example passes the initializer function, so the createInitialState function only runs during initialization. It does not run when component re-renders, such as when you type into the input.
TodoList.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
import { useReducer } from 'react';

function createInitialState(username) {
 const initialTodos = [];
 for (let i = 0; i < 50; i++) {
   initialTodos.push({
     id: i,
     text: username + "'s task #" + (i + 1)
   });
 }
 return {
   draft: '',
   todos: initialTodos,
 };
}

function reducer(state, action) {
 switch (action.type) {
   case 'changed_draft': {
     return {
       draft: action.nextDraft,
       todos: state.todos,
     };
   };
   case 'added_todo': {
     return {
       draft: '',
       todos: [{
         id: state.todos.length,
         text: state.draft
       }, ...state.todos]
     }
   }
 }
 throw Error('Unknown action: ' + action.type);
}
Show more
Next Example

Troubleshooting 
I’ve dispatched an action, but logging gives me the old state value 
Calling the dispatch function does not change state in the running code:
function handleClick() {
 console.log(state.age);  // 42

 dispatch({ type: 'incremented_age' }); // Request a re-render with 43
 console.log(state.age);  // Still 42!

 setTimeout(() => {
   console.log(state.age); // Also 42!
 }, 5000);
}
This is because states behaves like a snapshot. Updating state requests another render with the new state value, but does not affect the state JavaScript variable in your already-running event handler.
If you need to guess the next state value, you can calculate it manually by calling the reducer yourself:
const action = { type: 'incremented_age' };
dispatch(action);

const nextState = reducer(state, action);
console.log(state);     // { age: 42 }
console.log(nextState); // { age: 43 }

I’ve dispatched an action, but the screen doesn’t update 
React will ignore your update if the next state is equal to the previous state, as determined by an Object.is comparison. This usually happens when you change an object or an array in state directly:
function reducer(state, action) {
 switch (action.type) {
   case 'incremented_age': {
     // 🚩 Wrong: mutating existing object
     state.age++;
     return state;
   }
   case 'changed_name': {
     // 🚩 Wrong: mutating existing object
     state.name = action.nextName;
     return state;
   }
   // ...
 }
}
You mutated an existing state object and returned it, so React ignored the update. To fix this, you need to ensure that you’re always updating objects in state and updating arrays in state instead of mutating them:
function reducer(state, action) {
 switch (action.type) {
   case 'incremented_age': {
     // ✅ Correct: creating a new object
     return {
       ...state,
       age: state.age + 1
     };
   }
   case 'changed_name': {
     // ✅ Correct: creating a new object
     return {
       ...state,
       name: action.nextName
     };
   }
   // ...
 }
}

A part of my reducer state becomes undefined after dispatching 
Make sure that every case branch copies all of the existing fields when returning the new state:
function reducer(state, action) {
 switch (action.type) {
   case 'incremented_age': {
     return {
       ...state, // Don't forget this!
       age: state.age + 1
     };
   }
   // ...
Without ...state above, the returned next state would only contain the age field and nothing else.

My entire reducer state becomes undefined after dispatching 
If your state unexpectedly becomes undefined, you’re likely forgetting to return state in one of the cases, or your action type doesn’t match any of the case statements. To find why, throw an error outside the switch:
function reducer(state, action) {
 switch (action.type) {
   case 'incremented_age': {
     // ...
   }
   case 'edited_name': {
     // ...
   }
 }
 throw Error('Unknown action: ' + action.type);
}
You can also use a static type checker like TypeScript to catch such mistakes.

I’m getting an error: “Too many re-renders” 
You might get an error that says: Too many re-renders. React limits the number of renders to prevent an infinite loop. Typically, this means that you’re unconditionally dispatching an action during render, so your component enters a loop: render, dispatch (which causes a render), render, dispatch (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler:
// 🚩 Wrong: calls the handler during render
return <button onClick={handleClick()}>Click me</button>

// ✅ Correct: passes down the event handler
return <button onClick={handleClick}>Click me</button>

// ✅ Correct: passes down an inline function
return <button onClick={(e) => handleClick(e)}>Click me</button>
If you can’t find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specific dispatch function call responsible for the error.

My reducer or initializer function runs twice 
In Strict Mode, React will call your reducer and initializer functions twice. This shouldn’t break your code.
This development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and reducer functions are pure, this shouldn’t affect your logic. However, if they are accidentally impure, this helps you notice the mistakes.
For example, this impure reducer function mutates an array in state:
function reducer(state, action) {
 switch (action.type) {
   case 'added_todo': {
     // 🚩 Mistake: mutating state
     state.todos.push({ id: nextId++, text: action.text });
     return state;
   }
   // ...
 }
}
Because React calls your reducer function twice, you’ll see the todo was added twice, so you’ll know that there is a mistake. In this example, you can fix the mistake by replacing the array instead of mutating it:
function reducer(state, action) {
 switch (action.type) {
   case 'added_todo': {
     // ✅ Correct: replacing with new state
     return {
       ...state,
       todos: [
         ...state.todos,
         { id: nextId++, text: action.text }
       ]
     };
   }
   // ...
 }
}
Now that this reducer function is pure, calling it an extra time doesn’t make a difference in behavior. This is why React calling it twice helps you find mistakes. Only component, initializer, and reducer functions need to be pure. Event handlers don’t need to be pure, so React will never call your event handlers twice.
Read keeping components pure to learn more.
useRef
useRef is a React Hook that lets you reference a value that’s not needed for rendering.
const ref = useRef(initialValue)
Reference
useRef(initialValue)
Usage
Referencing a value with a ref
Manipulating the DOM with a ref
Avoiding recreating the ref contents
Troubleshooting
I can’t get a ref to a custom component

Reference 
useRef(initialValue) 
Call useRef at the top level of your component to declare a ref.
import { useRef } from 'react';

function MyComponent() {
 const intervalRef = useRef(0);
 const inputRef = useRef(null);
 // ...
See more examples below.
Parameters 
initialValue: The value you want the ref object’s current property to be initially. It can be a value of any type. This argument is ignored after the initial render.
Returns 
useRef returns an object with a single property:
current: Initially, it’s set to the initialValue you have passed. You can later set it to something else. If you pass the ref object to React as a ref attribute to a JSX node, React will set its current property.
On the next renders, useRef will return the same object.
Caveats 
You can mutate the ref.current property. Unlike state, it is mutable. However, if it holds an object that is used for rendering (for example, a piece of your state), then you shouldn’t mutate that object.
When you change the ref.current property, React does not re-render your component. React is not aware of when you change it because a ref is a plain JavaScript object.
Do not write or read ref.current during rendering, except for initialization. This makes your component’s behavior unpredictable.
In Strict Mode, React will call your component function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. Each ref object will be created twice, but one of the versions will be discarded. If your component function is pure (as it should be), this should not affect the behavior.

Usage 
Referencing a value with a ref 
Call useRef at the top level of your component to declare one or more refs.
import { useRef } from 'react';

function Stopwatch() {
 const intervalRef = useRef(0);
 // ...
useRef returns a ref object with a single current property initially set to the initial value you provided.
On the next renders, useRef will return the same object. You can change its current property to store information and read it later. This might remind you of state, but there is an important difference.
Changing a ref does not trigger a re-render. This means refs are perfect for storing information that doesn’t affect the visual output of your component. For example, if you need to store an interval ID and retrieve it later, you can put it in a ref. To update the value inside the ref, you need to manually change its current property:
function handleStartClick() {
 const intervalId = setInterval(() => {
   // ...
 }, 1000);
 intervalRef.current = intervalId;
}
Later, you can read that interval ID from the ref so that you can call clear that interval:
function handleStopClick() {
 const intervalId = intervalRef.current;
 clearInterval(intervalId);
}
By using a ref, you ensure that:
You can store information between re-renders (unlike regular variables, which reset on every render).
Changing it does not trigger a re-render (unlike state variables, which trigger a re-render).
The information is local to each copy of your component (unlike the variables outside, which are shared).
Changing a ref does not trigger a re-render, so refs are not appropriate for storing information you want to display on the screen. Use state for that instead. Read more about choosing between useRef and useState.
Examples of referencing a value with useRef
1. Click counter2. A stopwatch
Example 1 of 2: Click counter 
This component uses a ref to keep track of how many times the button was clicked. Note that it’s okay to use a ref instead of state here because the click count is only read and written in an event handler.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
import { useRef } from 'react';

export default function Counter() {
 let ref = useRef(0);

 function handleClick() {
   ref.current = ref.current + 1;
   alert('You clicked ' + ref.current + ' times!');
 }

 return (
   <button onClick={handleClick}>
     Click me!
   </button>
 );
}

Show more
If you show {ref.current} in the JSX, the number won’t update on click. This is because setting ref.current does not trigger a re-render. Information that’s used for rendering should be state instead.
Next Example
Pitfall
Do not write or read ref.current during rendering.
React expects that the body of your component behaves like a pure function:
If the inputs (props, state, and context) are the same, it should return exactly the same JSX.
Calling it in a different order or with different arguments should not affect the results of other calls.
Reading or writing a ref during rendering breaks these expectations.
function MyComponent() {
 // ...
 // 🚩 Don't write a ref during rendering
 myRef.current = 123;
 // ...
 // 🚩 Don't read a ref during rendering
 return <h1>{myOtherRef.current}</h1>;
}
You can read or write refs from event handlers or effects instead.
function MyComponent() {
 // ...
 useEffect(() => {
   // ✅ You can read or write refs in effects
   myRef.current = 123;
 });
 // ...
 function handleClick() {
   // ✅ You can read or write refs in event handlers
   doSomething(myOtherRef.current);
 }
 // ...
}
If you have to read or write something during rendering, use state instead.
When you break these rules, your component might still work, but most of the newer features we’re adding to React will rely on these expectations. Read more about keeping your components pure.

Manipulating the DOM with a ref 
It’s particularly common to use a ref to manipulate the DOM. React has built-in support for this.
First, declare a ref object with an initial value of null:
import { useRef } from 'react';

function MyComponent() {
 const inputRef = useRef(null);
 // ...
Then pass your ref object as the ref attribute to the JSX of the DOM node you want to manipulate:
 // ...
 return <input ref={inputRef} />;
After React creates the DOM node and puts it on the screen, React will set the current property of your ref object to that DOM node. Now you can access the <input>’s DOM node and call methods like focus():
 function handleClick() {
   inputRef.current.focus();
 }
React will set the current property back to null when the node is removed from the screen.
Read more about manipulating the DOM with refs.
Examples of manipulating the DOM with useRef
1. Focusing a text input2. Scrolling an image into view3. Playing and pausing a video4. Exposing a ref to your own component
Example 1 of 4: Focusing a text input 
In this example, clicking the button will focus the input:
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
import { useRef } from 'react';

export default function Form() {
 const inputRef = useRef(null);

 function handleClick() {
   inputRef.current.focus();
 }

 return (
   <>
     <input ref={inputRef} />
     <button onClick={handleClick}>
       Focus the input
     </button>
   </>
 );
}

Show more
Next Example

Avoiding recreating the ref contents 
React saves the initial ref value once and ignores it on the next renders.
function Video() {
 const playerRef = useRef(new VideoPlayer());
 // ...
Although the result of new VideoPlayer() is only used for the initial render, you’re still calling this function on every render. This can be wasteful if it’s creating expensive objects.
To solve it, you may initialize the ref like this instead:
function Video() {
 const playerRef = useRef(null);
 if (playerRef.current === null) {
   playerRef.current = new VideoPlayer();
 }
 // ...
Normally, writing or reading ref.current during render is not allowed. However, it’s fine in this case because the result is always the same, and the condition only executes during initialization so it’s fully predictable.
Deep Dive
How to avoid null checks when initializing useRef later 
Hide Details
If you use a type checker and don’t want to always check for null, you can try a pattern like this instead:
function Video() {
 const playerRef = useRef(null);

 function getPlayer() {
   if (playerRef.current !== null) {
     return playerRef.current;
   }
   const player = new VideoPlayer();
   playerRef.current = player;
   return player;
 }

 // ...
Here, the playerRef itself is nullable. However, you should be able to convince your type checker that there is no case in which getPlayer() returns null. Then use getPlayer() in your event handlers.

Troubleshooting 
I can’t get a ref to a custom component 
If you try to pass a ref to your own component like this:
const inputRef = useRef(null);

return <MyInput ref={inputRef} />;
You might get an error in the console:
Console
TypeError: Cannot read properties of null
By default, your own components don’t expose refs to the DOM nodes inside them.
To fix this, find the component that you want to get a ref to:
export default function MyInput({ value, onChange }) {
 return (
   <input
     value={value}
     onChange={onChange}
   />
 );
}
And then add ref to the list of props your component accepts and pass ref as a prop to the relevent child built-in component like this:
function MyInput({ value, onChange, ref }) {
 return (
   <input
     value={value}
     onChange={onChange}
     ref={ref}
   />
 );
};

export default MyInput;
Then the parent component can get a ref to it.
Read more about accessing another component’s DOM nodes.
Example 2 of 2: A stopwatch 
This example uses a combination of state and refs. Both startTime and now are state variables because they are used for rendering. But we also need to hold an interval ID so that we can stop the interval on button press. Since the interval ID is not used for rendering, it’s appropriate to keep it in a ref, and manually update it.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
import { useState, useRef } from 'react';

export default function Stopwatch() {
 const [startTime, setStartTime] = useState(null);
 const [now, setNow] = useState(null);
 const intervalRef = useRef(null);

 function handleStart() {
   setStartTime(Date.now());
   setNow(Date.now());

   clearInterval(intervalRef.current);
   intervalRef.current = setInterval(() => {
     setNow(Date.now());
   }, 10);
 }

 function handleStop() {
   clearInterval(intervalRef.current);
 }

 let secondsPassed = 0;
 if (startTime != null && now != null) {
   secondsPassed = (now - startTime) / 1000;
 }

 return (
   <>
     <h1>Time passed: {secondsPassed.toFixed(3)}</h1>
     <button onClick={handleStart}>
       Start
     </button>
     <button onClick={handleStop}>
       Stop
     </button>
   </>
 );
}

Show more
useState
useState is a React Hook that lets you add a state variable to your component.
const [state, setState] = useState(initialState)
Reference
useState(initialState)
set functions, like setSomething(nextState)
Usage
Adding state to a component
Updating state based on the previous state
Updating objects and arrays in state
Avoiding recreating the initial state
Resetting state with a key
Storing information from previous renders
Troubleshooting
I’ve updated the state, but logging gives me the old value
I’ve updated the state, but the screen doesn’t update
I’m getting an error: “Too many re-renders”
My initializer or updater function runs twice
I’m trying to set state to a function, but it gets called instead

Reference 
useState(initialState) 
Call useState at the top level of your component to declare a state variable.
import { useState } from 'react';

function MyComponent() {
 const [age, setAge] = useState(28);
 const [name, setName] = useState('Taylor');
 const [todos, setTodos] = useState(() => createTodos());
 // ...
The convention is to name state variables like [something, setSomething] using array destructuring.
See more examples below.
Parameters 
initialState: The value you want the state to be initially. It can be a value of any type, but there is a special behavior for functions. This argument is ignored after the initial render.
If you pass a function as initialState, it will be treated as an initializer function. It should be pure, should take no arguments, and should return a value of any type. React will call your initializer function when initializing the component, and store its return value as the initial state. See an example below.
Returns 
useState returns an array with exactly two values:
The current state. During the first render, it will match the initialState you have passed.
The set function that lets you update the state to a different value and trigger a re-render.
Caveats 
useState is a Hook, so you can only call it at the top level of your component or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.
In Strict Mode, React will call your initializer function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your initializer function is pure (as it should be), this should not affect the behavior. The result from one of the calls will be ignored.

set functions, like setSomething(nextState) 
The set function returned by useState lets you update the state to a different value and trigger a re-render. You can pass the next state directly, or a function that calculates it from the previous state:
const [name, setName] = useState('Edward');

function handleClick() {
 setName('Taylor');
 setAge(a => a + 1);
 // ...
Parameters 
nextState: The value that you want the state to be. It can be a value of any type, but there is a special behavior for functions.
If you pass a function as nextState, it will be treated as an updater function. It must be pure, should take the pending state as its only argument, and should return the next state. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state. See an example below.
Returns 
set functions do not have a return value.
Caveats 
The set function only updates the state variable for the next render. If you read the state variable after calling the set function, you will still get the old value that was on the screen before your call.
If the new value you provide is identical to the current state, as determined by an Object.is comparison, React will skip re-rendering the component and its children. This is an optimization. Although in some cases React may still need to call your component before skipping the children, it shouldn’t affect your code.
React batches state updates. It updates the screen after all the event handlers have run and have called their set functions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can use flushSync.
The set function has a stable identity, so you will often see it omitted from Effect dependencies, but including it will not cause the Effect to fire. If the linter lets you omit a dependency without errors, it is safe to do. Learn more about removing Effect dependencies.
Calling the set function during rendering is only allowed from within the currently rendering component. React will discard its output and immediately attempt to render it again with the new state. This pattern is rarely needed, but you can use it to store information from the previous renders. See an example below.
In Strict Mode, React will call your updater function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your updater function is pure (as it should be), this should not affect the behavior. The result from one of the calls will be ignored.

Usage 
Adding state to a component 
Call useState at the top level of your component to declare one or more state variables.
import { useState } from 'react';

function MyComponent() {
 const [age, setAge] = useState(42);
 const [name, setName] = useState('Taylor');
 // ...
The convention is to name state variables like [something, setSomething] using array destructuring.
useState returns an array with exactly two items:
The current state of this state variable, initially set to the initial state you provided.
The set function that lets you change it to any other value in response to interaction.
To update what’s on the screen, call the set function with some next state:
function handleClick() {
 setName('Robin');
}
React will store the next state, render your component again with the new values, and update the UI.
Pitfall
Calling the set function does not change the current state in the already executing code:
function handleClick() {
 setName('Robin');
 console.log(name); // Still "Taylor"!
}
It only affects what useState will return starting from the next render.
Basic useState examples
1. Counter (number)2. Text field (string)3. Checkbox (boolean)4. Form (two variables)
Example 1 of 4: Counter (number) 
In this example, the count state variable holds a number. Clicking the button increments it.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
import { useState } from 'react';

export default function Counter() {
 const [count, setCount] = useState(0);

 function handleClick() {
   setCount(count + 1);
 }

 return (
   <button onClick={handleClick}>
     You pressed me {count} times
   </button>
 );
}

Next Example

Updating state based on the previous state 
Suppose the age is 42. This handler calls setAge(age + 1) three times:
function handleClick() {
 setAge(age + 1); // setAge(42 + 1)
 setAge(age + 1); // setAge(42 + 1)
 setAge(age + 1); // setAge(42 + 1)
}
However, after one click, age will only be 43 rather than 45! This is because calling the set function does not update the age state variable in the already running code. So each setAge(age + 1) call becomes setAge(43).
To solve this problem, you may pass an updater function to setAge instead of the next state:
function handleClick() {
 setAge(a => a + 1); // setAge(42 => 43)
 setAge(a => a + 1); // setAge(43 => 44)
 setAge(a => a + 1); // setAge(44 => 45)
}
Here, a => a + 1 is your updater function. It takes the pending state and calculates the next state from it.
React puts your updater functions in a queue. Then, during the next render, it will call them in the same order:
a => a + 1 will receive 42 as the pending state and return 43 as the next state.
a => a + 1 will receive 43 as the pending state and return 44 as the next state.
a => a + 1 will receive 44 as the pending state and return 45 as the next state.
There are no other queued updates, so React will store 45 as the current state in the end.
By convention, it’s common to name the pending state argument for the first letter of the state variable name, like a for age. However, you may also call it like prevAge or something else that you find clearer.
React may call your updaters twice in development to verify that they are pure.
Deep Dive
Is using an updater always preferred? 
Hide Details
You might hear a recommendation to always write code like setAge(a => a + 1) if the state you’re setting is calculated from the previous state. There is no harm in it, but it is also not always necessary.
In most cases, there is no difference between these two approaches. React always makes sure that for intentional user actions, like clicks, the age state variable would be updated before the next click. This means there is no risk of a click handler seeing a “stale” age at the beginning of the event handler.
However, if you do multiple updates within the same event, updaters can be helpful. They’re also helpful if accessing the state variable itself is inconvenient (you might run into this when optimizing re-renders).
If you prefer consistency over slightly more verbose syntax, it’s reasonable to always write an updater if the state you’re setting is calculated from the previous state. If it’s calculated from the previous state of some other state variable, you might want to combine them into one object and use a reducer.
The difference between passing an updater and passing the next state directly
1. Passing the updater function2. Passing the next state directly
Example 1 of 2: Passing the updater function 
This example passes the updater function, so the “+3” button works.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
import { useState } from 'react';

export default function Counter() {
 const [age, setAge] = useState(42);

 function increment() {
   setAge(a => a + 1);
 }

 return (
   <>
     <h1>Your age: {age}</h1>
     <button onClick={() => {
       increment();
       increment();
       increment();
     }}>+3</button>
     <button onClick={() => {
       increment();
     }}>+1</button>
   </>
 );
}

Show more
Next Example

Updating objects and arrays in state 
You can put objects and arrays into state. In React, state is considered read-only, so you should replace it rather than mutate your existing objects. For example, if you have a form object in state, don’t mutate it:
// 🚩 Don't mutate an object in state like this:
form.firstName = 'Taylor';
Instead, replace the whole object by creating a new one:
// ✅ Replace state with a new object
setForm({
 ...form,
 firstName: 'Taylor'
});
Read updating objects in state and updating arrays in state to learn more.
Examples of objects and arrays in state
1. Form (object)2. Form (nested object)3. List (array)4. Writing concise update logic with Immer
Example 1 of 4: Form (object) 
In this example, the form state variable holds an object. Each input has a change handler that calls setForm with the next state of the entire form. The { ...form } spread syntax ensures that the state object is replaced rather than mutated.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
import { useState } from 'react';

export default function Form() {
 const [form, setForm] = useState({
   firstName: 'Barbara',
   lastName: 'Hepworth',
   email: 'bhepworth@sculpture.com',
 });

 return (
   <>
     <label>
       First name:
       <input
         value={form.firstName}
         onChange={e => {
           setForm({
             ...form,
             firstName: e.target.value
           });
         }}
       />
     </label>
     <label>
       Last name:
       <input
         value={form.lastName}
         onChange={e => {
           setForm({
             ...form,
             lastName: e.target.value
           });
         }}
       />
     </label>
     <label>
Show more
Next Example

Avoiding recreating the initial state 
React saves the initial state once and ignores it on the next renders.
function TodoList() {
 const [todos, setTodos] = useState(createInitialTodos());
 // ...
Although the result of createInitialTodos() is only used for the initial render, you’re still calling this function on every render. This can be wasteful if it’s creating large arrays or performing expensive calculations.
To solve this, you may pass it as an initializer function to useState instead:
function TodoList() {
 const [todos, setTodos] = useState(createInitialTodos);
 // ...
Notice that you’re passing createInitialTodos, which is the function itself, and not createInitialTodos(), which is the result of calling it. If you pass a function to useState, React will only call it during initialization.
React may call your initializers twice in development to verify that they are pure.
The difference between passing an initializer and passing the initial state directly
1. Passing the initializer function2. Passing the initial state directly
Example 1 of 2: Passing the initializer function 
This example passes the initializer function, so the createInitialTodos function only runs during initialization. It does not run when component re-renders, such as when you type into the input.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
import { useState } from 'react';

function createInitialTodos() {
 const initialTodos = [];
 for (let i = 0; i < 50; i++) {
   initialTodos.push({
     id: i,
     text: 'Item ' + (i + 1)
   });
 }
 return initialTodos;
}

export default function TodoList() {
 const [todos, setTodos] = useState(createInitialTodos);
 const [text, setText] = useState('');

 return (
   <>
     <input
       value={text}
       onChange={e => setText(e.target.value)}
     />
     <button onClick={() => {
       setText('');
       setTodos([{
         id: todos.length,
         text: text
       }, ...todos]);
     }}>Add</button>
     <ul>
       {todos.map(item => (
         <li key={item.id}>
           {item.text}
         </li>
       ))}
Show more
Next Example

Resetting state with a key 
You’ll often encounter the key attribute when rendering lists. However, it also serves another purpose.
You can reset a component’s state by passing a different key to a component. In this example, the Reset button changes the version state variable, which we pass as a key to the Form. When the key changes, React re-creates the Form component (and all of its children) from scratch, so its state gets reset.
Read preserving and resetting state to learn more.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
import { useState } from 'react';

export default function App() {
 const [version, setVersion] = useState(0);

 function handleReset() {
   setVersion(version + 1);
 }

 return (
   <>
     <button onClick={handleReset}>Reset</button>
     <Form key={version} />
   </>
 );
}

function Form() {
 const [name, setName] = useState('Taylor');

 return (
   <>
     <input
       value={name}
       onChange={e => setName(e.target.value)}
     />
     <p>Hello, {name}.</p>
   </>
 );
}

Show more

Storing information from previous renders 
Usually, you will update state in event handlers. However, in rare cases you might want to adjust state in response to rendering — for example, you might want to change a state variable when a prop changes.
In most cases, you don’t need this:
If the value you need can be computed entirely from the current props or other state, remove that redundant state altogether. If you’re worried about recomputing too often, the useMemo Hook can help.
If you want to reset the entire component tree’s state, pass a different key to your component.
If you can, update all the relevant state in the event handlers.
In the rare case that none of these apply, there is a pattern you can use to update state based on the values that have been rendered so far, by calling a set function while your component is rendering.
Here’s an example. This CountLabel component displays the count prop passed to it:
export default function CountLabel({ count }) {
 return <h1>{count}</h1>
}
Say you want to show whether the counter has increased or decreased since the last change. The count prop doesn’t tell you this — you need to keep track of its previous value. Add the prevCount state variable to track it. Add another state variable called trend to hold whether the count has increased or decreased. Compare prevCount with count, and if they’re not equal, update both prevCount and trend. Now you can show both the current count prop and how it has changed since the last render.
App.jsCountLabel.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
import { useState } from 'react';

export default function CountLabel({ count }) {
 const [prevCount, setPrevCount] = useState(count);
 const [trend, setTrend] = useState(null);
 if (prevCount !== count) {
   setPrevCount(count);
   setTrend(count > prevCount ? 'increasing' : 'decreasing');
 }
 return (
   <>
     <h1>{count}</h1>
     {trend && <p>The count is {trend}</p>}
   </>
 );
}

Show more
Note that if you call a set function while rendering, it must be inside a condition like prevCount !== count, and there must be a call like setPrevCount(count) inside of the condition. Otherwise, your component would re-render in a loop until it crashes. Also, you can only update the state of the currently rendering component like this. Calling the set function of another component during rendering is an error. Finally, your set call should still update state without mutation — this doesn’t mean you can break other rules of pure functions.
This pattern can be hard to understand and is usually best avoided. However, it’s better than updating state in an effect. When you call the set function during render, React will re-render that component immediately after your component exits with a return statement, and before rendering the children. This way, children don’t need to render twice. The rest of your component function will still execute (and the result will be thrown away). If your condition is below all the Hook calls, you may add an early return; to restart rendering earlier.

Troubleshooting 
I’ve updated the state, but logging gives me the old value 
Calling the set function does not change state in the running code:
function handleClick() {
 console.log(count);  // 0

 setCount(count + 1); // Request a re-render with 1
 console.log(count);  // Still 0!

 setTimeout(() => {
   console.log(count); // Also 0!
 }, 5000);
}
This is because states behaves like a snapshot. Updating state requests another render with the new state value, but does not affect the count JavaScript variable in your already-running event handler.
If you need to use the next state, you can save it in a variable before passing it to the set function:
const nextCount = count + 1;
setCount(nextCount);

console.log(count);     // 0
console.log(nextCount); // 1

I’ve updated the state, but the screen doesn’t update 
React will ignore your update if the next state is equal to the previous state, as determined by an Object.is comparison. This usually happens when you change an object or an array in state directly:
obj.x = 10;  // 🚩 Wrong: mutating existing object
setObj(obj); // 🚩 Doesn't do anything
You mutated an existing obj object and passed it back to setObj, so React ignored the update. To fix this, you need to ensure that you’re always replacing objects and arrays in state instead of mutating them:
// ✅ Correct: creating a new object
setObj({
 ...obj,
 x: 10
});

I’m getting an error: “Too many re-renders” 
You might get an error that says: Too many re-renders. React limits the number of renders to prevent an infinite loop. Typically, this means that you’re unconditionally setting state during render, so your component enters a loop: render, set state (which causes a render), render, set state (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler:
// 🚩 Wrong: calls the handler during render
return <button onClick={handleClick()}>Click me</button>

// ✅ Correct: passes down the event handler
return <button onClick={handleClick}>Click me</button>

// ✅ Correct: passes down an inline function
return <button onClick={(e) => handleClick(e)}>Click me</button>
If you can’t find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specific set function call responsible for the error.

My initializer or updater function runs twice 
In Strict Mode, React will call some of your functions twice instead of once:
function TodoList() {
 // This component function will run twice for every render.

 const [todos, setTodos] = useState(() => {
   // This initializer function will run twice during initialization.
   return createTodos();
 });

 function handleClick() {
   setTodos(prevTodos => {
     // This updater function will run twice for every click.
     return [...prevTodos, createTodo()];
   });
 }
 // ...
This is expected and shouldn’t break your code.
This development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and updater functions are pure, this shouldn’t affect your logic. However, if they are accidentally impure, this helps you notice the mistakes.
For example, this impure updater function mutates an array in state:
setTodos(prevTodos => {
 // 🚩 Mistake: mutating state
 prevTodos.push(createTodo());
});
Because React calls your updater function twice, you’ll see the todo was added twice, so you’ll know that there is a mistake. In this example, you can fix the mistake by replacing the array instead of mutating it:
setTodos(prevTodos => {
 // ✅ Correct: replacing with new state
 return [...prevTodos, createTodo()];
});
Now that this updater function is pure, calling it an extra time doesn’t make a difference in behavior. This is why React calling it twice helps you find mistakes. Only component, initializer, and updater functions need to be pure. Event handlers don’t need to be pure, so React will never call your event handlers twice.
Read keeping components pure to learn more.

I’m trying to set state to a function, but it gets called instead 
You can’t put a function into state like this:
const [fn, setFn] = useState(someFunction);

function handleClick() {
 setFn(someOtherFunction);
}
Because you’re passing a function, React assumes that someFunction is an initializer function, and that someOtherFunction is an updater function, so it tries to call them and store the result. To actually store a function, you have to put () => before them in both cases. Then React will store the functions you pass.
const [fn, setFn] = useState(() => someFunction);

function handleClick() {
 setFn(() => someOtherFunction);
}

Example 2 of 4: Text field (string) 
In this example, the text state variable holds a string. When you type, handleChange reads the latest input value from the browser input DOM element, and calls setText to update the state. This allows you to display the current text below.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
Example 3 of 4: Checkbox (boolean) 
In this example, the liked state variable holds a boolean. When you click the input, setLiked updates the liked state variable with whether the browser checkbox input is checked. The liked variable is used to render the text below the checkbox.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
import { useState } from 'react';

export default function MyCheckbox() {
 const [liked, setLiked] = useState(true);

 function handleChange(e) {
   setLiked(e.target.checked);
 }

 return (
   <>
     <label>
       <input
         type="checkbox"
         checked={liked}
         onChange={handleChange}
       />
       I liked this
     </label>
    Example 4 of 4: Form (two variables) 
You can declare more than one state variable in the same component. Each state variable is completely independent.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
import { useState } from 'react';

export default function Form() {
 const [name, setName] = useState('Taylor');
 const [age, setAge] = useState(42);

 return (
   <>
     <input
       value={name}
       onChange={e => setName(e.target.value)}
     />
     <button onClick={() => setAge(age + 1)}>
       Increment age
     </button>
     <p>Hello, {name}. You are {age}.</p>
   </>
 );
}

Show more
 <p>You {liked ? 'liked' : 'did not like'} this.</p>
   </>
 );
}

Show more

useSyncExternalStore
useSyncExternalStore is a React Hook that lets you subscribe to an external store.
const snapshot = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)
Reference
useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)
Usage
Subscribing to an external store
Subscribing to a browser API
Extracting the logic to a custom Hook
Adding support for server rendering
Troubleshooting
I’m getting an error: “The result of getSnapshot should be cached”
My subscribe function gets called after every re-render

Reference 
useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?) 
Call useSyncExternalStore at the top level of your component to read a value from an external data store.
import { useSyncExternalStore } from 'react';
import { todosStore } from './todoStore.js';

function TodosApp() {
 const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);
 // ...
}
It returns the snapshot of the data in the store. You need to pass two functions as arguments:
The subscribe function should subscribe to the store and return a function that unsubscribes.
The getSnapshot function should read a snapshot of the data from the store.
See more examples below.
Parameters 
subscribe: A function that takes a single callback argument and subscribes it to the store. When the store changes, it should invoke the provided callback, which will cause React to re-call getSnapshot and (if needed) re-render the component. The subscribe function should return a function that cleans up the subscription.
getSnapshot: A function that returns a snapshot of the data in the store that’s needed by the component. While the store has not changed, repeated calls to getSnapshot must return the same value. If the store changes and the returned value is different (as compared by Object.is), React re-renders the component.
optional getServerSnapshot: A function that returns the initial snapshot of the data in the store. It will be used only during server rendering and during hydration of server-rendered content on the client. The server snapshot must be the same between the client and the server, and is usually serialized and passed from the server to the client. If you omit this argument, rendering the component on the server will throw an error.
Returns 
The current snapshot of the store which you can use in your rendering logic.
Caveats 
The store snapshot returned by getSnapshot must be immutable. If the underlying store has mutable data, return a new immutable snapshot if the data has changed. Otherwise, return a cached last snapshot.
If a different subscribe function is passed during a re-render, React will re-subscribe to the store using the newly passed subscribe function. You can prevent this by declaring subscribe outside the component.
If the store is mutated during a non-blocking Transition update, React will fall back to performing that update as blocking. Specifically, for every Transition update, React will call getSnapshot a second time just before applying changes to the DOM. If it returns a different value than when it was called originally, React will restart the update from scratch, this time applying it as a blocking update, to ensure that every component on screen is reflecting the same version of the store.
It’s not recommended to suspend a render based on a store value returned by useSyncExternalStore. The reason is that mutations to the external store cannot be marked as non-blocking Transition updates, so they will trigger the nearest Suspense fallback, replacing already-rendered content on screen with a loading spinner, which typically makes a poor UX.
For example, the following are discouraged:
const LazyProductDetailPage = lazy(() => import('./ProductDetailPage.js'));


function ShoppingApp() {
 const selectedProductId = useSyncExternalStore(...);


 // ❌ Calling `use` with a Promise dependent on `selectedProductId`

  const data = use(fetchItem(selectedProductId))


  // ❌ Conditionally rendering a lazy component based on `selectedProductId`

  return selectedProductId != null ? <LazyProductDetailPage /> : <FeaturedProducts />;

}

Usage 
Subscribing to an external store 
Most of your React components will only read data from their props, state, and context. However, sometimes a component needs to read some data from some store outside of React that changes over time. This includes:
Third-party state management libraries that hold state outside of React.
Browser APIs that expose a mutable value and events to subscribe to its changes.
Call useSyncExternalStore at the top level of your component to read a value from an external data store.
import { useSyncExternalStore } from 'react';
import { todosStore } from './todoStore.js';

function TodosApp() {
 const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);
 // ...
}
It returns the snapshot of the data in the store. You need to pass two functions as arguments:
The subscribe function should subscribe to the store and return a function that unsubscribes.
The getSnapshot function should read a snapshot of the data from the store.
React will use these functions to keep your component subscribed to the store and re-render it on changes.
For example, in the sandbox below, todosStore is implemented as an external store that stores data outside of React. The TodosApp component connects to that external store with the useSyncExternalStore Hook.
App.jstodoStore.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
import { useSyncExternalStore } from 'react';
import { todosStore } from './todoStore.js';

export default function TodosApp() {
 const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);
 return (
   <>
     <button onClick={() => todosStore.addTodo()}>Add todo</button>
     <hr />
     <ul>
       {todos.map(todo => (
         <li key={todo.id}>{todo.text}</li>
       ))}
     </ul>
   </>
 );
}

Show more
Note
When possible, we recommend using built-in React state with useState and useReducer instead. The useSyncExternalStore API is mostly useful if you need to integrate with existing non-React code.

Subscribing to a browser API 
Another reason to add useSyncExternalStore is when you want to subscribe to some value exposed by the browser that changes over time. For example, suppose that you want your component to display whether the network connection is active. The browser exposes this information via a property called navigator.onLine.
This value can change without React’s knowledge, so you should read it with useSyncExternalStore.
import { useSyncExternalStore } from 'react';

function ChatIndicator() {
 const isOnline = useSyncExternalStore(subscribe, getSnapshot);
 // ...
}
To implement the getSnapshot function, read the current value from the browser API:
function getSnapshot() {
 return navigator.onLine;
}
Next, you need to implement the subscribe function. For example, when navigator.onLine changes, the browser fires the online and offline events on the window object. You need to subscribe the callback argument to the corresponding events, and then return a function that cleans up the subscriptions:
function subscribe(callback) {
 window.addEventListener('online', callback);
 window.addEventListener('offline', callback);
 return () => {
   window.removeEventListener('online', callback);
   window.removeEventListener('offline', callback);
 };
}
Now React knows how to read the value from the external navigator.onLine API and how to subscribe to its changes. Disconnect your device from the network and notice that the component re-renders in response:
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
import { useSyncExternalStore } from 'react';

export default function ChatIndicator() {
 const isOnline = useSyncExternalStore(subscribe, getSnapshot);
 return <h1>{isOnline ? '✅ Online' : '❌ Disconnected'}</h1>;
}

function getSnapshot() {
 return navigator.onLine;
}

function subscribe(callback) {
 window.addEventListener('online', callback);
 window.addEventListener('offline', callback);
 return () => {
   window.removeEventListener('online', callback);
   window.removeEventListener('offline', callback);
 };
}

Show more

Extracting the logic to a custom Hook 
Usually you won’t write useSyncExternalStore directly in your components. Instead, you’ll typically call it from your own custom Hook. This lets you use the same external store from different components.
For example, this custom useOnlineStatus Hook tracks whether the network is online:
import { useSyncExternalStore } from 'react';

export function useOnlineStatus() {
 const isOnline = useSyncExternalStore(subscribe, getSnapshot);
 return isOnline;
}

function getSnapshot() {
 // ...
}

function subscribe(callback) {
 // ...
}
Now different components can call useOnlineStatus without repeating the underlying implementation:
App.jsuseOnlineStatus.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
import { useOnlineStatus } from './useOnlineStatus.js';

function StatusBar() {
 const isOnline = useOnlineStatus();
 return <h1>{isOnline ? '✅ Online' : '❌ Disconnected'}</h1>;
}

function SaveButton() {
 const isOnline = useOnlineStatus();

 function handleSaveClick() {
   console.log('✅ Progress saved');
 }

 return (
   <button disabled={!isOnline} onClick={handleSaveClick}>
     {isOnline ? 'Save progress' : 'Reconnecting...'}
   </button>
 );
}

export default function App() {
 return (
   <>
     <SaveButton />
     <StatusBar />
   </>
 );
}

Show more

Adding support for server rendering 
If your React app uses server rendering, your React components will also run outside the browser environment to generate the initial HTML. This creates a few challenges when connecting to an external store:
If you’re connecting to a browser-only API, it won’t work because it does not exist on the server.
If you’re connecting to a third-party data store, you’ll need its data to match between the server and client.
To solve these issues, pass a getServerSnapshot function as the third argument to useSyncExternalStore:
import { useSyncExternalStore } from 'react';

export function useOnlineStatus() {
 const isOnline = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
 return isOnline;
}

function getSnapshot() {
 return navigator.onLine;
}

function getServerSnapshot() {
 return true; // Always show "Online" for server-generated HTML
}

function subscribe(callback) {
 // ...
}
The getServerSnapshot function is similar to getSnapshot, but it runs only in two situations:
It runs on the server when generating the HTML.
It runs on the client during hydration, i.e. when React takes the server HTML and makes it interactive.
This lets you provide the initial snapshot value which will be used before the app becomes interactive. If there is no meaningful initial value for the server rendering, omit this argument to force rendering on the client.
Note
Make sure that getServerSnapshot returns the same exact data on the initial client render as it returned on the server. For example, if getServerSnapshot returned some prepopulated store content on the server, you need to transfer this content to the client. One way to do this is to emit a <script> tag during server rendering that sets a global like window.MY_STORE_DATA, and read from that global on the client in getServerSnapshot. Your external store should provide instructions on how to do that.

Troubleshooting 
I’m getting an error: “The result of getSnapshot should be cached” 
This error means your getSnapshot function returns a new object every time it’s called, for example:
function getSnapshot() {
 // 🔴 Do not return always different objects from getSnapshot
 return {
   todos: myStore.todos
 };
}
React will re-render the component if getSnapshot return value is different from the last time. This is why, if you always return a different value, you will enter an infinite loop and get this error.
Your getSnapshot object should only return a different object if something has actually changed. If your store contains immutable data, you can return that data directly:
function getSnapshot() {
 // ✅ You can return immutable data
 return myStore.todos;
}
If your store data is mutable, your getSnapshot function should return an immutable snapshot of it. This means it does need to create new objects, but it shouldn’t do this for every single call. Instead, it should store the last calculated snapshot, and return the same snapshot as the last time if the data in the store has not changed. How you determine whether mutable data has changed depends on your mutable store.

My subscribe function gets called after every re-render 
This subscribe function is defined inside a component so it is different on every re-render:
function ChatIndicator() {
 // 🚩 Always a different function, so React will resubscribe on every re-render
 function subscribe() {
   // ...
 }

 const isOnline = useSyncExternalStore(subscribe, getSnapshot);

 // ...
}
React will resubscribe to your store if you pass a different subscribe function between re-renders. If this causes performance issues and you’d like to avoid resubscribing, move the subscribe function outside:
// ✅ Always the same function, so React won't need to resubscribe
function subscribe() {
 // ...
}

function ChatIndicator() {
 const isOnline = useSyncExternalStore(subscribe, getSnapshot);
 // ...
}
Alternatively, wrap subscribe into useCallback to only resubscribe when some argument changes:
function ChatIndicator({ userId }) {
 // ✅ Same function as long as userId doesn't change
 const subscribe = useCallback(() => {
   // ...
 }, [userId]);

 const isOnline = useSyncExternalStore(subscribe, getSnapshot);

 // ...
}
useTransition
useTransition is a React Hook that lets you render a part of the UI in the background.
const [isPending, startTransition] = useTransition()
Reference
useTransition()
startTransition(action)
Usage
Perform non-blocking updates with Actions
Exposing action prop from components
Displaying a pending visual state
Preventing unwanted loading indicators
Building a Suspense-enabled router
Displaying an error to users with an error boundary
Troubleshooting
Updating an input in a Transition doesn’t work
React doesn’t treat my state update as a Transition
React doesn’t treat my state update after await as a Transition
I want to call useTransition from outside a component
The function I pass to startTransition executes immediately
My state updates in Transitions are out of order

Reference 
useTransition() 
Call useTransition at the top level of your component to mark some state updates as Transitions.
import { useTransition } from 'react';

function TabContainer() {
 const [isPending, startTransition] = useTransition();
 // ...
}
See more examples below.
Parameters 
useTransition does not take any parameters.
Returns 
useTransition returns an array with exactly two items:
The isPending flag that tells you whether there is a pending Transition.
The startTransition function that lets you mark updates as a Transition.

startTransition(action) 
The startTransition function returned by useTransition lets you mark an update as a Transition.
function TabContainer() {
 const [isPending, startTransition] = useTransition();
 const [tab, setTab] = useState('about');

 function selectTab(nextTab) {
   startTransition(() => {
     setTab(nextTab);
   });
 }
 // ...
}
Note
Functions called in startTransition are called “Actions”. 
The function passed to startTransition is called an “Action”. By convention, any callback called inside startTransition (such as a callback prop) should be named action or include the “Action” suffix:
function SubmitButton({ submitAction }) {
 const [isPending, startTransition] = useTransition();

 return (
   <button
     disabled={isPending}
     onClick={() => {
       startTransition(async () => {
         await submitAction();
       });
     }}
   >
     Submit
   </button>
 );
}
Parameters 
action: A function that updates some state by calling one or more set functions. React calls action immediately with no parameters and marks all state updates scheduled synchronously during the action function call as Transitions. Any async calls that are awaited in the action will be included in the Transition, but currently require wrapping any set functions after the await in an additional startTransition (see Troubleshooting). State updates marked as Transitions will be non-blocking and will not display unwanted loading indicators.
Returns 
startTransition does not return anything.
Caveats 
useTransition is a Hook, so it can only be called inside components or custom Hooks. If you need to start a Transition somewhere else (for example, from a data library), call the standalone startTransition instead.
You can wrap an update into a Transition only if you have access to the set function of that state. If you want to start a Transition in response to some prop or a custom Hook value, try useDeferredValue instead.
The function you pass to startTransition is called immediately, marking all state updates that happen while it executes as Transitions. If you try to perform state updates in a setTimeout, for example, they won’t be marked as Transitions.
You must wrap any state updates after any async requests in another startTransition to mark them as Transitions. This is a known limitation that we will fix in the future (see Troubleshooting).
The startTransition function has a stable identity, so you will often see it omitted from Effect dependencies, but including it will not cause the Effect to fire. If the linter lets you omit a dependency without errors, it is safe to do. Learn more about removing Effect dependencies.
A state update marked as a Transition will be interrupted by other state updates. For example, if you update a chart component inside a Transition, but then start typing into an input while the chart is in the middle of a re-render, React will restart the rendering work on the chart component after handling the input update.
Transition updates can’t be used to control text inputs.
If there are multiple ongoing Transitions, React currently batches them together. This is a limitation that may be removed in a future release.
Usage 
Perform non-blocking updates with Actions 
Call useTransition at the top of your component to create Actions, and access the pending state:
import {useState, useTransition} from 'react';

function CheckoutForm() {
 const [isPending, startTransition] = useTransition();
 // ...
}
useTransition returns an array with exactly two items:
The isPending flag that tells you whether there is a pending Transition.
The startTransition function that lets you create an Action.
To start a Transition, pass a function to startTransition like this:
import {useState, useTransition} from 'react';
import {updateQuantity} from './api';

function CheckoutForm() {
 const [isPending, startTransition] = useTransition();
 const [quantity, setQuantity] = useState(1);

 function onSubmit(newQuantity) {
   startTransition(async function () {
     const savedQuantity = await updateQuantity(newQuantity);
     startTransition(() => {
       setQuantity(savedQuantity);
     });
   });
 }
 // ...
}
The function passed to startTransition is called the “Action”. You can update state and (optionally) perform side effects within an Action, and the work will be done in the background without blocking user interactions on the page. A Transition can include multiple Actions, and while a Transition is in progress, your UI stays responsive. For example, if the user clicks a tab but then changes their mind and clicks another tab, the second click will be immediately handled without waiting for the first update to finish.
To give the user feedback about in-progress Transitions, the isPending state switches to true at the first call to startTransition, and stays true until all Actions complete and the final state is shown to the user. Transitions ensure side effects in Actions to complete in order to prevent unwanted loading indicators, and you can provide immediate feedback while the Transition is in progress with useOptimistic.
The difference between Actions and regular event handling
1. Updating the quantity in an Action2. Updating the quantity without an Action
Example 1 of 2: Updating the quantity in an Action 
In this example, the updateQuantity function simulates a request to the server to update the item’s quantity in the cart. This function is artificially slowed down so that it takes at least a second to complete the request.
Update the quantity multiple times quickly. Notice that the pending “Total” state is shown while any requests are in progress, and the “Total” updates only after the final request is complete. Because the update is in an Action, the “quantity” can continue to be updated while the request is in progress.
App.jsItem.jsTotal.jsapi.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
import { useState, useTransition } from "react";
import { updateQuantity } from "./api";
import Item from "./Item";
import Total from "./Total";

export default function App({}) {
 const [quantity, setQuantity] = useState(1);
 const [isPending, startTransition] = useTransition();

 const updateQuantityAction = async newQuantity => {
   // To access the pending state of a transition,
   // call startTransition again.
   startTransition(async () => {
     const savedQuantity = await updateQuantity(newQuantity);
     startTransition(() => {
       setQuantity(savedQuantity);
     });
   });
 };

 return (
   <div>
     <h1>Checkout</h1>
     <Item action={updateQuantityAction}/>
     <hr />
     <Total quantity={quantity} isPending={isPending} />
   </div>
 );
}

Show more
This is a basic example to demonstrate how Actions work, but this example does not handle requests completing out of order. When updating the quantity multiple times, it’s possible for the previous requests to finish after later requests causing the quantity to update out of order. This is a known limitation that we will fix in the future (see Troubleshooting below).
For common use cases, React provides built-in abstractions such as:
useActionState
<form> actions
Server Functions
These solutions handle request ordering for you. When using Transitions to build your own custom hooks or libraries that manage async state transitions, you have greater control over the request ordering, but you must handle it yourself.
Next Example

Exposing action prop from components 
You can expose an action prop from a component to allow a parent to call an Action.
For example, this TabButton component wraps its onClick logic in an action prop:
export default function TabButton({ action, children, isActive }) {
 const [isPending, startTransition] = useTransition();
 if (isActive) {
   return <b>{children}</b>
 }
 return (
   <button onClick={() => {
     startTransition(async () => {
       // await the action that's passed in.
       // This allows it to be either sync or async.
       await action();
     });
   }}>
     {children}
   </button>
 );
}
Because the parent component updates its state inside the action, that state update gets marked as a Transition. This means you can click on “Posts” and then immediately click “Contact” and it does not block user interactions:
App.jsTabButton.jsAboutTab.jsPostsTab.jsContactTab.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
import { useTransition } from 'react';

export default function TabButton({ action, children, isActive }) {
 const [isPending, startTransition] = useTransition();
 if (isActive) {
   return <b>{children}</b>
 }
 if (isPending) {
   return <b className="pending">{children}</b>;
 }
 return (
   <button onClick={async () => {
     startTransition(async () => {
       // await the action that's passed in.
       // This allows it to be either sync or async.
       await action();
     });
   }}>
     {children}
   </button>
 );
}

Show more
Note
When exposing an action prop from a component, you should await it inside the transition.
This allows the action callback to be either synchronous or asynchronous without requiring an additional startTransition to wrap the await in the action.

Displaying a pending visual state 
You can use the isPending boolean value returned by useTransition to indicate to the user that a Transition is in progress. For example, the tab button can have a special “pending” visual state:
function TabButton({ action, children, isActive }) {
 const [isPending, startTransition] = useTransition();
 // ...
 if (isPending) {
   return <b className="pending">{children}</b>;
 }
 // ...
Notice how clicking “Posts” now feels more responsive because the tab button itself updates right away:
App.jsTabButton.jsAboutTab.jsPostsTab.jsContactTab.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
import { useTransition } from 'react';

export default function TabButton({ action, children, isActive }) {
 const [isPending, startTransition] = useTransition();
 if (isActive) {
   return <b>{children}</b>
 }
 if (isPending) {
   return <b className="pending">{children}</b>;
 }
 return (
   <button onClick={() => {
     startTransition(async () => {
       await action();
     });
   }}>
     {children}
   </button>
 );
}

Show more

Preventing unwanted loading indicators 
In this example, the PostsTab component fetches some data using use. When you click the “Posts” tab, the PostsTab component suspends, causing the closest loading fallback to appear:
App.jsTabButton.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
import { Suspense, useState } from 'react';
import TabButton from './TabButton.js';
import AboutTab from './AboutTab.js';
import PostsTab from './PostsTab.js';
import ContactTab from './ContactTab.js';

export default function TabContainer() {
 const [tab, setTab] = useState('about');
 return (
   <Suspense fallback={<h1>🌀 Loading...</h1>}>
     <TabButton
       isActive={tab === 'about'}
       action={() => setTab('about')}
     >
       About
     </TabButton>
     <TabButton
       isActive={tab === 'posts'}
       action={() => setTab('posts')}
     >
       Posts
     </TabButton>
     <TabButton
       isActive={tab === 'contact'}
       action={() => setTab('contact')}
     >
       Contact
     </TabButton>
     <hr />
     {tab === 'about' && <AboutTab />}
     {tab === 'posts' && <PostsTab />}
     {tab === 'contact' && <ContactTab />}
   </Suspense>
 );
}

Show more
Hiding the entire tab container to show a loading indicator leads to a jarring user experience. If you add useTransition to TabButton, you can instead display the pending state in the tab button instead.
Notice that clicking “Posts” no longer replaces the entire tab container with a spinner:
App.jsTabButton.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
import { useTransition } from 'react';

export default function TabButton({ action, children, isActive }) {
 const [isPending, startTransition] = useTransition();
 if (isActive) {
   return <b>{children}</b>
 }
 if (isPending) {
   return <b className="pending">{children}</b>;
 }
 return (
   <button onClick={() => {
     startTransition(async () => {
       await action();
     });
   }}>
     {children}
   </button>
 );
}

Show more
Read more about using Transitions with Suspense.
Note
Transitions only “wait” long enough to avoid hiding already revealed content (like the tab container). If the Posts tab had a nested <Suspense> boundary, the Transition would not “wait” for it.

Building a Suspense-enabled router 
If you’re building a React framework or a router, we recommend marking page navigations as Transitions.
function Router() {
 const [page, setPage] = useState('/');
 const [isPending, startTransition] = useTransition();

 function navigate(url) {
   startTransition(() => {
     setPage(url);
   });
 }
 // ...
This is recommended for three reasons:
Transitions are interruptible, which lets the user click away without waiting for the re-render to complete.
Transitions prevent unwanted loading indicators, which lets the user avoid jarring jumps on navigation.
Transitions wait for all pending actions which lets the user wait for side effects to complete before the new page is shown.
Here is a simplified router example using Transitions for navigations.
App.jsLayout.jsIndexPage.jsArtistPage.jsAlbums.jsBiography.jsPanel.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
import { Suspense, useState, useTransition } from 'react';
import IndexPage from './IndexPage.js';
import ArtistPage from './ArtistPage.js';
import Layout from './Layout.js';

export default function App() {
 return (
   <Suspense fallback={<BigSpinner />}>
     <Router />
   </Suspense>
 );
}

function Router() {
 const [page, setPage] = useState('/');
 const [isPending, startTransition] = useTransition();

 function navigate(url) {
   startTransition(() => {
     setPage(url);
   });
 }

 let content;
 if (page === '/') {
   content = (
     <IndexPage navigate={navigate} />
   );
 } else if (page === '/the-beatles') {
   content = (
     <ArtistPage
       artist={{
         id: 'the-beatles',
         name: 'The Beatles',
       }}
     />
Show more
Note
Suspense-enabled routers are expected to wrap the navigation updates into Transitions by default.

Displaying an error to users with an error boundary 
If a function passed to startTransition throws an error, you can display an error to your user with an error boundary. To use an error boundary, wrap the component where you are calling the useTransition in an error boundary. Once the function passed to startTransition errors, the fallback for the error boundary will be displayed.
AddCommentContainer.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
import { useTransition } from "react";
import { ErrorBoundary } from "react-error-boundary";

export function AddCommentContainer() {
 return (
   <ErrorBoundary fallback={<p>⚠️Something went wrong</p>}>
     <AddCommentButton />
   </ErrorBoundary>
 );
}

function addComment(comment) {
 // For demonstration purposes to show Error Boundary
 if (comment == null) {
   throw new Error("Example Error: An error thrown to trigger error boundary");
 }
}

function AddCommentButton() {
 const [pending, startTransition] = useTransition();

 return (
   <button
     disabled={pending}
     onClick={() => {
       startTransition(() => {
         // Intentionally not passing a comment
         // so error gets thrown
         addComment();
       });
     }}
   >
     Add comment
   </button>
 );
}

Show more

Troubleshooting 
Updating an input in a Transition doesn’t work 
You can’t use a Transition for a state variable that controls an input:
const [text, setText] = useState('');
// ...
function handleChange(e) {
 // ❌ Can't use Transitions for controlled input state
 startTransition(() => {
   setText(e.target.value);
 });
}
// ...
return <input value={text} onChange={handleChange} />;
This is because Transitions are non-blocking, but updating an input in response to the change event should happen synchronously. If you want to run a Transition in response to typing, you have two options:
You can declare two separate state variables: one for the input state (which always updates synchronously), and one that you will update in a Transition. This lets you control the input using the synchronous state, and pass the Transition state variable (which will “lag behind” the input) to the rest of your rendering logic.
Alternatively, you can have one state variable, and add useDeferredValue which will “lag behind” the real value. It will trigger non-blocking re-renders to “catch up” with the new value automatically.

React doesn’t treat my state update as a Transition 
When you wrap a state update in a Transition, make sure that it happens during the startTransition call:
startTransition(() => {
 // ✅ Setting state *during* startTransition call
 setPage('/about');
});
The function you pass to startTransition must be synchronous. You can’t mark an update as a Transition like this:
startTransition(() => {
 // ❌ Setting state *after* startTransition call
 setTimeout(() => {
   setPage('/about');
 }, 1000);
});
Instead, you could do this:
setTimeout(() => {
 startTransition(() => {
   // ✅ Setting state *during* startTransition call
   setPage('/about');
 });
}, 1000);

React doesn’t treat my state update after await as a Transition 
When you use await inside a startTransition function, the state updates that happen after the await are not marked as Transitions. You must wrap state updates after each await in a startTransition call:
startTransition(async () => {
 await someAsyncFunction();
 // ❌ Not using startTransition after await
 setPage('/about');
});
However, this works instead:
startTransition(async () => {
 await someAsyncFunction();
 // ✅ Using startTransition *after* await
 startTransition(() => {
   setPage('/about');
 });
});
This is a JavaScript limitation due to React losing the scope of the async context. In the future, when AsyncContext is available, this limitation will be removed.

I want to call useTransition from outside a component 
You can’t call useTransition outside a component because it’s a Hook. In this case, use the standalone startTransition method instead. It works the same way, but it doesn’t provide the isPending indicator.

The function I pass to startTransition executes immediately 
If you run this code, it will print 1, 2, 3:
console.log(1);
startTransition(() => {
 console.log(2);
 setPage('/about');
});
console.log(3);
It is expected to print 1, 2, 3. The function you pass to startTransition does not get delayed. Unlike with the browser setTimeout, it does not run the callback later. React executes your function immediately, but any state updates scheduled while it is running are marked as Transitions. You can imagine that it works like this:
// A simplified version of how React works

let isInsideTransition = false;

function startTransition(scope) {
 isInsideTransition = true;
 scope();
 isInsideTransition = false;
}

function setState() {
 if (isInsideTransition) {
   // ... schedule a Transition state update ...
 } else {
   // ... schedule an urgent state update ...
 }
}
My state updates in Transitions are out of order 
If you await inside startTransition, you might see the updates happen out of order.
In this example, the updateQuantity function simulates a request to the server to update the item’s quantity in the cart. This function artificially returns the every other request after the previous to simulate race conditions for network requests.
Try updating the quantity once, then update it quickly multiple times. You might see the incorrect total:
App.jsItem.jsTotal.jsapi.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
import { useState, useTransition } from "react";
import { updateQuantity } from "./api";
import Item from "./Item";
import Total from "./Total";

export default function App({}) {
 const [quantity, setQuantity] = useState(1);
 const [isPending, startTransition] = useTransition();
 // Store the actual quantity in separate state to show the mismatch.
 const [clientQuantity, setClientQuantity] = useState(1);
  const updateQuantityAction = newQuantity => {
   setClientQuantity(newQuantity);

   // Access the pending state of the transition,
   // by wrapping in startTransition again.
   startTransition(async () => {
     const savedQuantity = await updateQuantity(newQuantity);
     startTransition(() => {
       setQuantity(savedQuantity);
     });
   });
 };

 return (
   <div>
     <h1>Checkout</h1>
     <Item action={updateQuantityAction}/>
     <hr />
     <Total clientQuantity={clientQuantity} savedQuantity={quantity} isPending={isPending} />
   </div>
 );
}


Show more
When clicking multiple times, it’s possible for previous requests to finish after later requests. When this happens, React currently has no way to know the intended order. This is because the updates are scheduled asynchronously, and React loses context of the order across the async boundary.
This is expected, because Actions within a Transition do not guarantee execution order. For common use cases, React provides higher-level abstractions like useActionState and <form> actions that handle ordering for you. For advanced use cases, you’ll need to implement your own queuing and abort logic to handle this.
Example of useActionState handling execution order:
App.jsItem.jsTotal.jsapi.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
import { useState, useActionState } from "react";
import { updateQuantity } from "./api";
import Item from "./Item";
import Total from "./Total";

export default function App({}) {
 // Store the actual quantity in separate state to show the mismatch.
 const [clientQuantity, setClientQuantity] = useState(1);
 const [quantity, updateQuantityAction, isPending] = useActionState(
   async (prevState, payload) => {
     setClientQuantity(payload);
     const savedQuantity = await updateQuantity(payload);
     return savedQuantity; // Return the new quantity to update the state
   },
   1 // Initial quantity
 );

 return (
   <div>
     <h1>Checkout</h1>
     <Item action={updateQuantityAction}/>
     <hr />
     <Total clientQuantity={clientQuantity} savedQuantity={quantity} isPending={isPending} />
   </div>
 );
}


Show more




<Fragment> (<>...</>)
<Fragment>, often used via <>...</> syntax, lets you group elements without a wrapper node.
<>
 <OneChild />
 <AnotherChild />
</>
Reference
<Fragment>
Usage
Returning multiple elements
Assigning multiple elements to a variable
Grouping elements with text
Rendering a list of Fragments

Reference 
<Fragment> 
Wrap elements in <Fragment> to group them together in situations where you need a single element. Grouping elements in Fragment has no effect on the resulting DOM; it is the same as if the elements were not grouped. The empty JSX tag <></> is shorthand for <Fragment></Fragment> in most cases.
Props 
optional key: Fragments declared with the explicit <Fragment> syntax may have keys.
Caveats 
If you want to pass key to a Fragment, you can’t use the <>...</> syntax. You have to explicitly import Fragment from 'react' and render <Fragment key={yourKey}>...</Fragment>.
React does not reset state when you go from rendering <><Child /></> to [<Child />] or back, or when you go from rendering <><Child /></> to <Child /> and back. This only works a single level deep: for example, going from <><><Child /></></> to <Child /> resets the state. See the precise semantics here.

Usage 
Returning multiple elements 
Use Fragment, or the equivalent <>...</> syntax, to group multiple elements together. You can use it to put multiple elements in any place where a single element can go. For example, a component can only return one element, but by using a Fragment you can group multiple elements together and then return them as a group:
function Post() {
 return (
   <>
     <PostTitle />
     <PostBody />
   </>
 );
}
Fragments are useful because grouping elements with a Fragment has no effect on layout or styles, unlike if you wrapped the elements in another container like a DOM element. If you inspect this example with the browser tools, you’ll see that all <h1> and <article> DOM nodes appear as siblings without wrappers around them:
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
export default function Blog() {
 return (
   <>
     <Post title="An update" body="It's been a while since I posted..." />
     <Post title="My new blog" body="I am starting a new blog!" />
   </>
 )
}

function Post({ title, body }) {
 return (
   <>
     <PostTitle title={title} />
     <PostBody body={body} />
   </>
 );
}

function PostTitle({ title }) {
 return <h1>{title}</h1>
}

function PostBody({ body }) {
 return (
   <article>
     <p>{body}</p>
   </article>
 );
}

Show more
Deep Dive
How to write a Fragment without the special syntax? 
Hide Details
The example above is equivalent to importing Fragment from React:
import { Fragment } from 'react';

function Post() {
 return (
   <Fragment>
     <PostTitle />
     <PostBody />
   </Fragment>
 );
}
Usually you won’t need this unless you need to pass a key to your Fragment.

Assigning multiple elements to a variable 
Like any other element, you can assign Fragment elements to variables, pass them as props, and so on:
function CloseDialog() {
 const buttons = (
   <>
     <OKButton />
     <CancelButton />
   </>
 );
 return (
   <AlertDialog buttons={buttons}>
     Are you sure you want to leave this page?
   </AlertDialog>
 );
}

Grouping elements with text 
You can use Fragment to group text together with components:
function DateRangePicker({ start, end }) {
 return (
   <>
     From
     <DatePicker date={start} />
     to
     <DatePicker date={end} />
   </>
 );
}

Rendering a list of Fragments 
Here’s a situation where you need to write Fragment explicitly instead of using the <></> syntax. When you render multiple elements in a loop, you need to assign a key to each element. If the elements within the loop are Fragments, you need to use the normal JSX element syntax in order to provide the key attribute:
function Blog() {
 return posts.map(post =>
   <Fragment key={post.id}>
     <PostTitle title={post.title} />
     <PostBody body={post.body} />
   </Fragment>
 );
}
You can inspect the DOM to verify that there are no wrapper elements around the Fragment children:
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
import { Fragment } from 'react';

const posts = [
 { id: 1, title: 'An update', body: "It's been a while since I posted..." },
 { id: 2, title: 'My new blog', body: 'I am starting a new blog!' }
];

export default function Blog() {
 return posts.map(post =>
   <Fragment key={post.id}>
     <PostTitle title={post.title} />
     <PostBody body={post.body} />
   </Fragment>
 );
}

function PostTitle({ title }) {
 return <h1>{title}</h1>
}

function PostBody({ body }) {
 return (
   <article>
     <p>{body}</p>
   </article>
 );
}

Show more

<Profiler>
<Profiler> lets you measure rendering performance of a React tree programmatically.
<Profiler id="App" onRender={onRender}>
 <App />
</Profiler>
Reference
<Profiler>
onRender callback
Usage
Measuring rendering performance programmatically
Measuring different parts of the application

Reference 
<Profiler> 
Wrap a component tree in a <Profiler> to measure its rendering performance.
<Profiler id="App" onRender={onRender}>
 <App />
</Profiler>
Props 
id: A string identifying the part of the UI you are measuring.
onRender: An onRender callback that React calls every time components within the profiled tree update. It receives information about what was rendered and how much time it took.
Caveats 
Profiling adds some additional overhead, so it is disabled in the production build by default. To opt into production profiling, you need to enable a special production build with profiling enabled.

onRender callback 
React will call your onRender callback with information about what was rendered.
function onRender(id, phase, actualDuration, baseDuration, startTime, commitTime) {
 // Aggregate or log render timings...
}
Parameters 
id: The string id prop of the <Profiler> tree that has just committed. This lets you identify which part of the tree was committed if you are using multiple profilers.
phase: "mount", "update" or "nested-update". This lets you know whether the tree has just been mounted for the first time or re-rendered due to a change in props, state, or Hooks.
actualDuration: The number of milliseconds spent rendering the <Profiler> and its descendants for the current update. This indicates how well the subtree makes use of memoization (e.g. memo and useMemo). Ideally this value should decrease significantly after the initial mount as many of the descendants will only need to re-render if their specific props change.
baseDuration: The number of milliseconds estimating how much time it would take to re-render the entire <Profiler> subtree without any optimizations. It is calculated by summing up the most recent render durations of each component in the tree. This value estimates a worst-case cost of rendering (e.g. the initial mount or a tree with no memoization). Compare actualDuration against it to see if memoization is working.
startTime: A numeric timestamp for when React began rendering the current update.
commitTime: A numeric timestamp for when React committed the current update. This value is shared between all profilers in a commit, enabling them to be grouped if desirable.

Usage 
Measuring rendering performance programmatically 
Wrap the <Profiler> component around a React tree to measure its rendering performance.
<App>
 <Profiler id="Sidebar" onRender={onRender}>
   <Sidebar />
 </Profiler>
 <PageContent />
</App>
It requires two props: an id (string) and an onRender callback (function) which React calls any time a component within the tree “commits” an update.
Pitfall
Profiling adds some additional overhead, so it is disabled in the production build by default. To opt into production profiling, you need to enable a special production build with profiling enabled.
Note
<Profiler> lets you gather measurements programmatically. If you’re looking for an interactive profiler, try the Profiler tab in React Developer Tools. It exposes similar functionality as a browser extension.

Measuring different parts of the application 
You can use multiple <Profiler> components to measure different parts of your application:
<App>
 <Profiler id="Sidebar" onRender={onRender}>
   <Sidebar />
 </Profiler>
 <Profiler id="Content" onRender={onRender}>
   <Content />
 </Profiler>
</App>
You can also nest <Profiler> components:
<App>
 <Profiler id="Sidebar" onRender={onRender}>
   <Sidebar />
 </Profiler>
 <Profiler id="Content" onRender={onRender}>
   <Content>
     <Profiler id="Editor" onRender={onRender}>
       <Editor />
     </Profiler>
     <Preview />
   </Content>
 </Profiler>
</App>
Although <Profiler> is a lightweight component, it should be used only when necessary. Each use adds some CPU and memory overhead to an application.
<StrictMode>
<StrictMode> lets you find common bugs in your components early during development.
<StrictMode>
 <App />
</StrictMode>
Reference
<StrictMode>
Usage
Enabling Strict Mode for entire app
Enabling Strict Mode for a part of the app
Fixing bugs found by double rendering in development
Fixing bugs found by re-running Effects in development
Fixing bugs found by re-running ref callbacks in development
Fixing deprecation warnings enabled by Strict Mode

Reference 
<StrictMode> 
Use StrictMode to enable additional development behaviors and warnings for the component tree inside:
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'));
root.render(
 <StrictMode>
   <App />
 </StrictMode>
);
See more examples below.
Strict Mode enables the following development-only behaviors:
Your components will re-render an extra time to find bugs caused by impure rendering.
Your components will re-run Effects an extra time to find bugs caused by missing Effect cleanup.
Your components will re-run refs callbacks an extra time to find bugs caused by missing ref cleanup.
Your components will be checked for usage of deprecated APIs.
Props 
StrictMode accepts no props.
Caveats 
There is no way to opt out of Strict Mode inside a tree wrapped in <StrictMode>. This gives you confidence that all components inside <StrictMode> are checked. If two teams working on a product disagree whether they find the checks valuable, they need to either reach consensus or move <StrictMode> down in the tree.

Usage 
Enabling Strict Mode for entire app 
Strict Mode enables extra development-only checks for the entire component tree inside the <StrictMode> component. These checks help you find common bugs in your components early in the development process.
To enable Strict Mode for your entire app, wrap your root component with <StrictMode> when you render it:
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'));
root.render(
 <StrictMode>
   <App />
 </StrictMode>
);
We recommend wrapping your entire app in Strict Mode, especially for newly created apps. If you use a framework that calls createRoot for you, check its documentation for how to enable Strict Mode.
Although the Strict Mode checks only run in development, they help you find bugs that already exist in your code but can be tricky to reliably reproduce in production. Strict Mode lets you fix bugs before your users report them.
Note
Strict Mode enables the following checks in development:
Your components will re-render an extra time to find bugs caused by impure rendering.
Your components will re-run Effects an extra time to find bugs caused by missing Effect cleanup.
Your components will re-run ref callbacks an extra time to find bugs caused by missing ref cleanup.
Your components will be checked for usage of deprecated APIs.
All of these checks are development-only and do not impact the production build.

Enabling Strict Mode for a part of the app 
You can also enable Strict Mode for any part of your application:
import { StrictMode } from 'react';

function App() {
 return (
   <>
     <Header />
     <StrictMode>
       <main>
         <Sidebar />
         <Content />
       </main>
     </StrictMode>
     <Footer />
   </>
 );
}
In this example, Strict Mode checks will not run against the Header and Footer components. However, they will run on Sidebar and Content, as well as all of the components inside them, no matter how deep.
Note
When StrictMode is enabled for a part of the app, React will only enable behaviors that are possible in production. For example, if <StrictMode> is not enabled at the root of the app, it will not re-run Effects an extra time on initial mount, since this would cause child effects to double fire without the parent effects, which cannot happen in production.

Fixing bugs found by double rendering in development 
React assumes that every component you write is a pure function. This means that React components you write must always return the same JSX given the same inputs (props, state, and context).
Components breaking this rule behave unpredictably and cause bugs. To help you find accidentally impure code, Strict Mode calls some of your functions (only the ones that should be pure) twice in development. This includes:
Your component function body (only top-level logic, so this doesn’t include code inside event handlers)
Functions that you pass to useState, set functions, useMemo, or useReducer
Some class component methods like constructor, render, shouldComponentUpdate (see the whole list)
If a function is pure, running it twice does not change its behavior because a pure function produces the same result every time. However, if a function is impure (for example, it mutates the data it receives), running it twice tends to be noticeable (that’s what makes it impure!) This helps you spot and fix the bug early.
Here is an example to illustrate how double rendering in Strict Mode helps you find bugs early.
This StoryTray component takes an array of stories and adds one last “Create Story” item at the end:
index.jsApp.jsStoryTray.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
export default function StoryTray({ stories }) {
 const items = stories;
 items.push({ id: 'create', label: 'Create Story' });
 return (
   <ul>
     {items.map(story => (
       <li key={story.id}>
         {story.label}
       </li>
     ))}
   </ul>
 );
}

There is a mistake in the code above. However, it is easy to miss because the initial output appears correct.
This mistake will become more noticeable if the StoryTray component re-renders multiple times. For example, let’s make the StoryTray re-render with a different background color whenever you hover over it:
index.jsApp.jsStoryTray.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
import { useState } from 'react';

export default function StoryTray({ stories }) {
 const [isHover, setIsHover] = useState(false);
 const items = stories;
 items.push({ id: 'create', label: 'Create Story' });
 return (
   <ul
     onPointerEnter={() => setIsHover(true)}
     onPointerLeave={() => setIsHover(false)}
     style={{
       backgroundColor: isHover ? '#ddd' : '#fff'
     }}
   >
     {items.map(story => (
       <li key={story.id}>
         {story.label}
       </li>
     ))}
   </ul>
 );
}

Show more
Notice how every time you hover over the StoryTray component, “Create Story” gets added to the list again. The intention of the code was to add it once at the end. But StoryTray directly modifies the stories array from the props. Every time StoryTray renders, it adds “Create Story” again at the end of the same array. In other words, StoryTray is not a pure function—running it multiple times produces different results.
To fix this problem, you can make a copy of the array, and modify that copy instead of the original one:
export default function StoryTray({ stories }) {
 const items = stories.slice(); // Clone the array
 // ✅ Good: Pushing into a new array
 items.push({ id: 'create', label: 'Create Story' });
This would make the StoryTray function pure. Each time it is called, it would only modify a new copy of the array, and would not affect any external objects or variables. This solves the bug, but you had to make the component re-render more often before it became obvious that something is wrong with its behavior.
In the original example, the bug wasn’t obvious. Now let’s wrap the original (buggy) code in <StrictMode>:
index.jsApp.jsStoryTray.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
export default function StoryTray({ stories }) {
 const items = stories;
 items.push({ id: 'create', label: 'Create Story' });
 return (
   <ul>
     {items.map(story => (
       <li key={story.id}>
         {story.label}
       </li>
     ))}
   </ul>
 );
}

Strict Mode always calls your rendering function twice, so you can see the mistake right away (“Create Story” appears twice). This lets you notice such mistakes early in the process. When you fix your component to render in Strict Mode, you also fix many possible future production bugs like the hover functionality from before:
index.jsApp.jsStoryTray.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
import { useState } from 'react';

export default function StoryTray({ stories }) {
 const [isHover, setIsHover] = useState(false);
 const items = stories.slice(); // Clone the array
 items.push({ id: 'create', label: 'Create Story' });
 return (
   <ul
     onPointerEnter={() => setIsHover(true)}
     onPointerLeave={() => setIsHover(false)}
     style={{
       backgroundColor: isHover ? '#ddd' : '#fff'
     }}
   >
     {items.map(story => (
       <li key={story.id}>
         {story.label}
       </li>
     ))}
   </ul>
 );
}

Show more
Without Strict Mode, it was easy to miss the bug until you added more re-renders. Strict Mode made the same bug appear right away. Strict Mode helps you find bugs before you push them to your team and to your users.
Read more about keeping components pure.
Note
If you have React DevTools installed, any console.log calls during the second render call will appear slightly dimmed. React DevTools also offers a setting (off by default) to suppress them completely.

Fixing bugs found by re-running Effects in development 
Strict Mode can also help find bugs in Effects.
Every Effect has some setup code and may have some cleanup code. Normally, React calls setup when the component mounts (is added to the screen) and calls cleanup when the component unmounts (is removed from the screen). React then calls cleanup and setup again if its dependencies changed since the last render.
When Strict Mode is on, React will also run one extra setup+cleanup cycle in development for every Effect. This may feel surprising, but it helps reveal subtle bugs that are hard to catch manually.
Here is an example to illustrate how re-running Effects in Strict Mode helps you find bugs early.
Consider this example that connects a component to a chat:
index.jsApp.jschat.js
Reset
Fork
1
2
3
4
5
6
7
8
import { createRoot } from 'react-dom/client';
import './styles.css';

import App from './App';

const root = createRoot(document.getElementById("root"));
root.render(<App />);

There is an issue with this code, but it might not be immediately clear.
To make the issue more obvious, let’s implement a feature. In the example below, roomId is not hardcoded. Instead, the user can select the roomId that they want to connect to from a dropdown. Click “Open chat” and then select different chat rooms one by one. Keep track of the number of active connections in the console:
index.jsApp.jschat.js
Reset
Fork
1
2
3
4
5
6
7
8
import { createRoot } from 'react-dom/client';
import './styles.css';

import App from './App';

const root = createRoot(document.getElementById("root"));
root.render(<App />);

You’ll notice that the number of open connections always keeps growing. In a real app, this would cause performance and network problems. The issue is that your Effect is missing a cleanup function:
 useEffect(() => {
   const connection = createConnection(serverUrl, roomId);
   connection.connect();
   return () => connection.disconnect();
 }, [roomId]);
Now that your Effect “cleans up” after itself and destroys the outdated connections, the leak is solved. However, notice that the problem did not become visible until you’ve added more features (the select box).
In the original example, the bug wasn’t obvious. Now let’s wrap the original (buggy) code in <StrictMode>:
index.jsApp.jschat.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import './styles.css';

import App from './App';

const root = createRoot(document.getElementById("root"));
root.render(
 <StrictMode>
   <App />
 </StrictMode>
);

With Strict Mode, you immediately see that there is a problem (the number of active connections jumps to 2). Strict Mode runs an extra setup+cleanup cycle for every Effect. This Effect has no cleanup logic, so it creates an extra connection but doesn’t destroy it. This is a hint that you’re missing a cleanup function.
Strict Mode lets you notice such mistakes early in the process. When you fix your Effect by adding a cleanup function in Strict Mode, you also fix many possible future production bugs like the select box from before:
index.jsApp.jschat.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import './styles.css';

import App from './App';

const root = createRoot(document.getElementById("root"));
root.render(
 <StrictMode>
   <App />
 </StrictMode>
);

Notice how the active connection count in the console doesn’t keep growing anymore.
Without Strict Mode, it was easy to miss that your Effect needed cleanup. By running setup → cleanup → setup instead of setup for your Effect in development, Strict Mode made the missing cleanup logic more noticeable.
Read more about implementing Effect cleanup.

Fixing bugs found by re-running ref callbacks in development 
Strict Mode can also help find bugs in callbacks refs.
Every callback ref has some setup code and may have some cleanup code. Normally, React calls setup when the element is created (is added to the DOM) and calls cleanup when the element is removed (is removed from the DOM).
When Strict Mode is on, React will also run one extra setup+cleanup cycle in development for every callback ref. This may feel surprising, but it helps reveal subtle bugs that are hard to catch manually.
Consider this example, which allows you to select an animal and then scroll to one of them. Notice when you switch from “Cats” to “Dogs”, the console logs show that the number of animals in the list keeps growing, and the “Scroll to” buttons stop working:
index.jsApp.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
import { useRef, useState } from "react";

export default function AnimalFriends() {
 const itemsRef = useRef([]);
 const [animalList, setAnimalList] = useState(setupAnimalList);
 const [animal, setAnimal] = useState('cat');

 function scrollToAnimal(index) {
   const list = itemsRef.current;
   const {node} = list[index];
   node.scrollIntoView({
     behavior: "smooth",
     block: "nearest",
     inline: "center",
   });
 }
  const animals = animalList.filter(a => a.type === animal)
  return (
   <>
     <nav>
       <button onClick={() => setAnimal('cat')}>Cats</button>
       <button onClick={() => setAnimal('dog')}>Dogs</button>
     </nav>
     <hr />
     <nav>
       <span>Scroll to:</span>{animals.map((animal, index) => (
         <button key={animal.src} onClick={() => scrollToAnimal(index)}>
           {index}
         </button>
       ))}
     </nav>
     <div>
       <ul>
         {animals.map((animal) => (
Show more
This is a production bug! Since the ref callback doesn’t remove animals from the list in the cleanup, the list of animals keeps growing. This is a memory leak that can cause performance problems in a real app, and breaks the behavior of the app.
The issue is the ref callback doesn’t cleanup after itself:
<li
 ref={node => {
   const list = itemsRef.current;
   const item = {animal, node};
   list.push(item);
   return () => {
     // 🚩 No cleanup, this is a bug!
   }
 }}
</li>
Now let’s wrap the original (buggy) code in <StrictMode>:
index.jsApp.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
import { useRef, useState } from "react";

export default function AnimalFriends() {
 const itemsRef = useRef([]);
 const [animalList, setAnimalList] = useState(setupAnimalList);
 const [animal, setAnimal] = useState('cat');

 function scrollToAnimal(index) {
   const list = itemsRef.current;
   const {node} = list[index];
   node.scrollIntoView({
     behavior: "smooth",
     block: "nearest",
     inline: "center",
   });
 }
  const animals = animalList.filter(a => a.type === animal)
  return (
   <>
     <nav>
       <button onClick={() => setAnimal('cat')}>Cats</button>
       <button onClick={() => setAnimal('dog')}>Dogs</button>
     </nav>
     <hr />
     <nav>
       <span>Scroll to:</span>{animals.map((animal, index) => (
         <button key={animal.src} onClick={() => scrollToAnimal(index)}>
           {index}
         </button>
       ))}
     </nav>
     <div>
       <ul>
         {animals.map((animal) => (
Console (30)
✅ Adding animal to the map. Total animals: 1
✅ Adding animal to the map. Total animals: 2
✅ Adding animal to the map. Total animals: 3
✅ Adding animal to the map. Total animals: 4
✅ Adding animal to the map. Total animals: 5
✅ Adding animal to the map. Total animals: 6
✅ Adding animal to the map. Total animals: 7
✅ Adding animal to the map. Total animals: 8
✅ Adding animal to the map. Total animals: 9
✅ Adding animal to the map. Total animals: 10
✅ Adding animal to the map. Total animals: 11
❌ Too many animals in the list!
✅ Adding animal to the map. Total animals: 12
❌ Too many animals in the list!
✅ Adding animal to the map. Total animals: 13
❌ Too many animals in the list!
✅ Adding animal to the map. Total animals: 14
❌ Too many animals in the list!
✅ Adding animal to the map. Total animals: 15
❌ Too many animals in the list!
✅ Adding animal to the map. Total animals: 16
❌ Too many animals in the list!
✅ Adding animal to the map. Total animals: 17
❌ Too many animals in the list!
✅ Adding animal to the map. Total animals: 18
❌ Too many animals in the list!
✅ Adding animal to the map. Total animals: 19
❌ Too many animals in the list!
✅ Adding animal to the map. Total animals: 20
❌ Too many animals in the list!
Show more
With Strict Mode, you immediately see that there is a problem. Strict Mode runs an extra setup+cleanup cycle for every callback ref. This callback ref has no cleanup logic, so it adds refs but doesn’t remove them. This is a hint that you’re missing a cleanup function.
Strict Mode lets you eagerly find mistakes in callback refs. When you fix your callback by adding a cleanup function in Strict Mode, you also fix many possible future production bugs like the “Scroll to” bug from before:
index.jsApp.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
import { useRef, useState } from "react";

export default function AnimalFriends() {
 const itemsRef = useRef([]);
 const [animalList, setAnimalList] = useState(setupAnimalList);
 const [animal, setAnimal] = useState('cat');

 function scrollToAnimal(index) {
   const list = itemsRef.current;
   const {node} = list[index];
   node.scrollIntoView({
     behavior: "smooth",
     block: "nearest",
     inline: "center",
   });
 }
  const animals = animalList.filter(a => a.type === animal)
  return (
   <>
     <nav>
       <button onClick={() => setAnimal('cat')}>Cats</button>
       <button onClick={() => setAnimal('dog')}>Dogs</button>
     </nav>
     <hr />
     <nav>
       <span>Scroll to:</span>{animals.map((animal, index) => (
         <button key={animal.src} onClick={() => scrollToAnimal(index)}>
           {index}
         </button>
       ))}
     </nav>
     <div>
       <ul>
         {animals.map((animal) => (
Console (30)
✅ Adding animal to the map. Total animals: 1
✅ Adding animal to the map. Total animals: 2
✅ Adding animal to the map. Total animals: 3
✅ Adding animal to the map. Total animals: 4
✅ Adding animal to the map. Total animals: 5
✅ Adding animal to the map. Total animals: 6
✅ Adding animal to the map. Total animals: 7
✅ Adding animal to the map. Total animals: 8
✅ Adding animal to the map. Total animals: 9
✅ Adding animal to the map. Total animals: 10
❌ Removing animal from the map. Total animals: 9
❌ Removing animal from the map. Total animals: 8
❌ Removing animal from the map. Total animals: 7
❌ Removing animal from the map. Total animals: 6
❌ Removing animal from the map. Total animals: 5
❌ Removing animal from the map. Total animals: 4
❌ Removing animal from the map. Total animals: 3
❌ Removing animal from the map. Total animals: 2
❌ Removing animal from the map. Total animals: 1
❌ Removing animal from the map. Total animals: 0
✅ Adding animal to the map. Total animals: 1
✅ Adding animal to the map. Total animals: 2
✅ Adding animal to the map. Total animals: 3
✅ Adding animal to the map. Total animals: 4
✅ Adding animal to the map. Total animals: 5
✅ Adding animal to the map. Total animals: 6
✅ Adding animal to the map. Total animals: 7
✅ Adding animal to the map. Total animals: 8
✅ Adding animal to the map. Total animals: 9
✅ Adding animal to the map. Total animals: 10
Show more
Now on inital mount in StrictMode, the ref callbacks are all setup, cleaned up, and setup again:
...
✅ Adding animal to the map. Total animals: 10
...
❌ Removing animal from the map. Total animals: 0
...
✅ Adding animal to the map. Total animals: 10
This is expected. Strict Mode confirms that the ref callbacks are cleaned up correctly, so the size never grows above the expected amount. After the fix, there are no memory leaks, and all the features work as expected.
Without Strict Mode, it was easy to miss the bug until you clicked around to app to notice broken features. Strict Mode made the bugs appear right away, before you push them to production.

Fixing deprecation warnings enabled by Strict Mode 
React warns if some component anywhere inside a <StrictMode> tree uses one of these deprecated APIs:
UNSAFE_ class lifecycle methods like UNSAFE_componentWillMount. See alternatives.
These APIs are primarily used in older class components so they rarely appear in modern apps.
<Suspense>
<Suspense> lets you display a fallback until its children have finished loading.
<Suspense fallback={<Loading />}>
 <SomeComponent />
</Suspense>
Reference
<Suspense>
Usage
Displaying a fallback while content is loading
Revealing content together at once
Revealing nested content as it loads
Showing stale content while fresh content is loading
Preventing already revealed content from hiding
Indicating that a Transition is happening
Resetting Suspense boundaries on navigation
Providing a fallback for server errors and client-only content
Troubleshooting
How do I prevent the UI from being replaced by a fallback during an update?

Reference 
<Suspense> 
Props 
children: The actual UI you intend to render. If children suspends while rendering, the Suspense boundary will switch to rendering fallback.
fallback: An alternate UI to render in place of the actual UI if it has not finished loading. Any valid React node is accepted, though in practice, a fallback is a lightweight placeholder view, such as a loading spinner or skeleton. Suspense will automatically switch to fallback when children suspends, and back to children when the data is ready. If fallback suspends while rendering, it will activate the closest parent Suspense boundary.
Caveats 
React does not preserve any state for renders that got suspended before they were able to mount for the first time. When the component has loaded, React will retry rendering the suspended tree from scratch.
If Suspense was displaying content for the tree, but then it suspended again, the fallback will be shown again unless the update causing it was caused by startTransition or useDeferredValue.
If React needs to hide the already visible content because it suspended again, it will clean up layout Effects in the content tree. When the content is ready to be shown again, React will fire the layout Effects again. This ensures that Effects measuring the DOM layout don’t try to do this while the content is hidden.
React includes under-the-hood optimizations like Streaming Server Rendering and Selective Hydration that are integrated with Suspense. Read an architectural overview and watch a technical talk to learn more.

Usage 
Displaying a fallback while content is loading 
You can wrap any part of your application with a Suspense boundary:
<Suspense fallback={<Loading />}>
 <Albums />
</Suspense>
React will display your loading fallback until all the code and data needed by the children has been loaded.
In the example below, the Albums component suspends while fetching the list of albums. Until it’s ready to render, React switches the closest Suspense boundary above to show the fallback—your Loading component. Then, when the data loads, React hides the Loading fallback and renders the Albums component with data.
ArtistPage.jsAlbums.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
import { Suspense } from 'react';
import Albums from './Albums.js';

export default function ArtistPage({ artist }) {
 return (
   <>
     <h1>{artist.name}</h1>
     <Suspense fallback={<Loading />}>
       <Albums artistId={artist.id} />
     </Suspense>
   </>
 );
}

function Loading() {
 return <h2>🌀 Loading...</h2>;
}

Show more
Note
Only Suspense-enabled data sources will activate the Suspense component. They include:
Data fetching with Suspense-enabled frameworks like Relay and Next.js
Lazy-loading component code with lazy
Reading the value of a cached Promise with use
Suspense does not detect when data is fetched inside an Effect or event handler.
The exact way you would load data in the Albums component above depends on your framework. If you use a Suspense-enabled framework, you’ll find the details in its data fetching documentation.
Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.

Revealing content together at once 
By default, the whole tree inside Suspense is treated as a single unit. For example, even if only one of these components suspends waiting for some data, all of them together will be replaced by the loading indicator:
<Suspense fallback={<Loading />}>
 <Biography />
 <Panel>
   <Albums />
 </Panel>
</Suspense>
Then, after all of them are ready to be displayed, they will all appear together at once.
In the example below, both Biography and Albums fetch some data. However, because they are grouped under a single Suspense boundary, these components always “pop in” together at the same time.
ArtistPage.jsPanel.jsBiography.jsAlbums.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
import { Suspense } from 'react';
import Albums from './Albums.js';
import Biography from './Biography.js';
import Panel from './Panel.js';

export default function ArtistPage({ artist }) {
 return (
   <>
     <h1>{artist.name}</h1>
     <Suspense fallback={<Loading />}>
       <Biography artistId={artist.id} />
       <Panel>
         <Albums artistId={artist.id} />
       </Panel>
     </Suspense>
   </>
 );
}

function Loading() {
 return <h2>🌀 Loading...</h2>;
}

Show more
Components that load data don’t have to be direct children of the Suspense boundary. For example, you can move Biography and Albums into a new Details component. This doesn’t change the behavior. Biography and Albums share the same closest parent Suspense boundary, so their reveal is coordinated together.
<Suspense fallback={<Loading />}>
 <Details artistId={artist.id} />
</Suspense>

function Details({ artistId }) {
 return (
   <>
     <Biography artistId={artistId} />
     <Panel>
       <Albums artistId={artistId} />
     </Panel>
   </>
 );
}

Revealing nested content as it loads 
When a component suspends, the closest parent Suspense component shows the fallback. This lets you nest multiple Suspense components to create a loading sequence. Each Suspense boundary’s fallback will be filled in as the next level of content becomes available. For example, you can give the album list its own fallback:
<Suspense fallback={<BigSpinner />}>
 <Biography />
 <Suspense fallback={<AlbumsGlimmer />}>
   <Panel>
     <Albums />
   </Panel>
 </Suspense>
</Suspense>
With this change, displaying the Biography doesn’t need to “wait” for the Albums to load.
The sequence will be:
If Biography hasn’t loaded yet, BigSpinner is shown in place of the entire content area.
Once Biography finishes loading, BigSpinner is replaced by the content.
If Albums hasn’t loaded yet, AlbumsGlimmer is shown in place of Albums and its parent Panel.
Finally, once Albums finishes loading, it replaces AlbumsGlimmer.
ArtistPage.jsPanel.jsBiography.jsAlbums.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
import { Suspense } from 'react';
import Albums from './Albums.js';
import Biography from './Biography.js';
import Panel from './Panel.js';

export default function ArtistPage({ artist }) {
 return (
   <>
     <h1>{artist.name}</h1>
     <Suspense fallback={<BigSpinner />}>
       <Biography artistId={artist.id} />
       <Suspense fallback={<AlbumsGlimmer />}>
         <Panel>
           <Albums artistId={artist.id} />
         </Panel>
       </Suspense>
     </Suspense>
   </>
 );
}

function BigSpinner() {
 return <h2>🌀 Loading...</h2>;
}

function AlbumsGlimmer() {
 return (
   <div className="glimmer-panel">
     <div className="glimmer-line" />
     <div className="glimmer-line" />
     <div className="glimmer-line" />
   </div>
 );
}

Show more
Suspense boundaries let you coordinate which parts of your UI should always “pop in” together at the same time, and which parts should progressively reveal more content in a sequence of loading states. You can add, move, or delete Suspense boundaries in any place in the tree without affecting the rest of your app’s behavior.
Don’t put a Suspense boundary around every component. Suspense boundaries should not be more granular than the loading sequence that you want the user to experience. If you work with a designer, ask them where the loading states should be placed—it’s likely that they’ve already included them in their design wireframes.

Showing stale content while fresh content is loading 
In this example, the SearchResults component suspends while fetching the search results. Type "a", wait for the results, and then edit it to "ab". The results for "a" will get replaced by the loading fallback.
App.jsSearchResults.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
import { Suspense, useState } from 'react';
import SearchResults from './SearchResults.js';

export default function App() {
 const [query, setQuery] = useState('');
 return (
   <>
     <label>
       Search albums:
       <input value={query} onChange={e => setQuery(e.target.value)} />
     </label>
     <Suspense fallback={<h2>Loading...</h2>}>
       <SearchResults query={query} />
     </Suspense>
   </>
 );
}

Show more
A common alternative UI pattern is to defer updating the list and to keep showing the previous results until the new results are ready. The useDeferredValue Hook lets you pass a deferred version of the query down:
export default function App() {
 const [query, setQuery] = useState('');
 const deferredQuery = useDeferredValue(query);
 return (
   <>
     <label>
       Search albums:
       <input value={query} onChange={e => setQuery(e.target.value)} />
     </label>
     <Suspense fallback={<h2>Loading...</h2>}>
       <SearchResults query={deferredQuery} />
     </Suspense>
   </>
 );
}
The query will update immediately, so the input will display the new value. However, the deferredQuery will keep its previous value until the data has loaded, so SearchResults will show the stale results for a bit.
To make it more obvious to the user, you can add a visual indication when the stale result list is displayed:
<div style={{
 opacity: query !== deferredQuery ? 0.5 : 1
}}>
 <SearchResults query={deferredQuery} />
</div>
Enter "a" in the example below, wait for the results to load, and then edit the input to "ab". Notice how instead of the Suspense fallback, you now see the dimmed stale result list until the new results have loaded:
App.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
import { Suspense, useState, useDeferredValue } from 'react';
import SearchResults from './SearchResults.js';

export default function App() {
 const [query, setQuery] = useState('');
 const deferredQuery = useDeferredValue(query);
 const isStale = query !== deferredQuery;
 return (
   <>
     <label>
       Search albums:
       <input value={query} onChange={e => setQuery(e.target.value)} />
     </label>
     <Suspense fallback={<h2>Loading...</h2>}>
       <div style={{ opacity: isStale ? 0.5 : 1 }}>
         <SearchResults query={deferredQuery} />
       </div>
     </Suspense>
   </>
 );
}

Show more
Note
Both deferred values and Transitions let you avoid showing Suspense fallback in favor of inline indicators. Transitions mark the whole update as non-urgent so they are typically used by frameworks and router libraries for navigation. Deferred values, on the other hand, are mostly useful in application code where you want to mark a part of UI as non-urgent and let it “lag behind” the rest of the UI.

Preventing already revealed content from hiding 
When a component suspends, the closest parent Suspense boundary switches to showing the fallback. This can lead to a jarring user experience if it was already displaying some content. Try pressing this button:
App.jsLayout.jsIndexPage.jsArtistPage.jsAlbums.jsBiography.jsPanel.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
import { Suspense, useState } from 'react';
import IndexPage from './IndexPage.js';
import ArtistPage from './ArtistPage.js';
import Layout from './Layout.js';

export default function App() {
 return (
   <Suspense fallback={<BigSpinner />}>
     <Router />
   </Suspense>
 );
}

function Router() {
 const [page, setPage] = useState('/');

 function navigate(url) {
   setPage(url);
 }

 let content;
 if (page === '/') {
   content = (
     <IndexPage navigate={navigate} />
   );
 } else if (page === '/the-beatles') {
   content = (
     <ArtistPage
       artist={{
         id: 'the-beatles',
         name: 'The Beatles',
       }}
     />
   );
 }
 return (
   <Layout>
     {content}
   </Layout>
 );
}

function BigSpinner() {
 return <h2>🌀 Loading...</h2>;
}

Show more
When you pressed the button, the Router component rendered ArtistPage instead of IndexPage. A component inside ArtistPage suspended, so the closest Suspense boundary started showing the fallback. The closest Suspense boundary was near the root, so the whole site layout got replaced by BigSpinner.
To prevent this, you can mark the navigation state update as a Transition with startTransition:
function Router() {
 const [page, setPage] = useState('/');

 function navigate(url) {
   startTransition(() => {
     setPage(url);     
   });
 }
 // ...
This tells React that the state transition is not urgent, and it’s better to keep showing the previous page instead of hiding any already revealed content. Now clicking the button “waits” for the Biography to load:
App.jsLayout.jsIndexPage.jsArtistPage.jsAlbums.jsBiography.jsPanel.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
import { Suspense, startTransition, useState } from 'react';
import IndexPage from './IndexPage.js';
import ArtistPage from './ArtistPage.js';
import Layout from './Layout.js';

export default function App() {
 return (
   <Suspense fallback={<BigSpinner />}>
     <Router />
   </Suspense>
 );
}

function Router() {
 const [page, setPage] = useState('/');

 function navigate(url) {
   startTransition(() => {
     setPage(url);
   });
 }

 let content;
 if (page === '/') {
   content = (
     <IndexPage navigate={navigate} />
   );
 } else if (page === '/the-beatles') {
   content = (
     <ArtistPage
       artist={{
         id: 'the-beatles',
         name: 'The Beatles',
       }}
     />
   );
 }
 return (
   <Layout>
     {content}
   </Layout>
 );
}

function BigSpinner() {
 return <h2>🌀 Loading...</h2>;
}

Show more
A Transition doesn’t wait for all content to load. It only waits long enough to avoid hiding already revealed content. For example, the website Layout was already revealed, so it would be bad to hide it behind a loading spinner. However, the nested Suspense boundary around Albums is new, so the Transition doesn’t wait for it.
Note
Suspense-enabled routers are expected to wrap the navigation updates into Transitions by default.

Indicating that a Transition is happening 
In the above example, once you click the button, there is no visual indication that a navigation is in progress. To add an indicator, you can replace startTransition with useTransition which gives you a boolean isPending value. In the example below, it’s used to change the website header styling while a Transition is happening:
App.jsLayout.jsIndexPage.jsArtistPage.jsAlbums.jsBiography.jsPanel.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
import { Suspense, useState, useTransition } from 'react';
import IndexPage from './IndexPage.js';
import ArtistPage from './ArtistPage.js';
import Layout from './Layout.js';

export default function App() {
 return (
   <Suspense fallback={<BigSpinner />}>
     <Router />
   </Suspense>
 );
}

function Router() {
 const [page, setPage] = useState('/');
 const [isPending, startTransition] = useTransition();

 function navigate(url) {
   startTransition(() => {
     setPage(url);
   });
 }

 let content;
 if (page === '/') {
   content = (
     <IndexPage navigate={navigate} />
   );
 } else if (page === '/the-beatles') {
   content = (
     <ArtistPage
       artist={{
         id: 'the-beatles',
         name: 'The Beatles',
       }}
     />
Show more

Resetting Suspense boundaries on navigation 
During a Transition, React will avoid hiding already revealed content. However, if you navigate to a route with different parameters, you might want to tell React it is different content. You can express this with a key:
<ProfilePage key={queryParams.id} />
Imagine you’re navigating within a user’s profile page, and something suspends. If that update is wrapped in a Transition, it will not trigger the fallback for already visible content. That’s the expected behavior.
However, now imagine you’re navigating between two different user profiles. In that case, it makes sense to show the fallback. For example, one user’s timeline is different content from another user’s timeline. By specifying a key, you ensure that React treats different users’ profiles as different components, and resets the Suspense boundaries during navigation. Suspense-integrated routers should do this automatically.

Providing a fallback for server errors and client-only content 
If you use one of the streaming server rendering APIs (or a framework that relies on them), React will also use your <Suspense> boundaries to handle errors on the server. If a component throws an error on the server, React will not abort the server render. Instead, it will find the closest <Suspense> component above it and include its fallback (such as a spinner) into the generated server HTML. The user will see a spinner at first.
On the client, React will attempt to render the same component again. If it errors on the client too, React will throw the error and display the closest error boundary. However, if it does not error on the client, React will not display the error to the user since the content was eventually displayed successfully.
You can use this to opt out some components from rendering on the server. To do this, throw an error in the server environment and then wrap them in a <Suspense> boundary to replace their HTML with fallbacks:
<Suspense fallback={<Loading />}>
 <Chat />
</Suspense>

function Chat() {
 if (typeof window === 'undefined') {
   throw Error('Chat should only render on the client.');
 }
 // ...
}
The server HTML will include the loading indicator. It will be replaced by the Chat component on the client.

Troubleshooting 
How do I prevent the UI from being replaced by a fallback during an update? 
Replacing visible UI with a fallback creates a jarring user experience. This can happen when an update causes a component to suspend, and the nearest Suspense boundary is already showing content to the user.
To prevent this from happening, mark the update as non-urgent using startTransition. During a Transition, React will wait until enough data has loaded to prevent an unwanted fallback from appearing:
function handleNextPageClick() {
 // If this update suspends, don't hide the already displayed content
 startTransition(() => {
   setCurrentPage(currentPage + 1);
 });
}
This will avoid hiding existing content. However, any newly rendered Suspense boundaries will still immediately display fallbacks to avoid blocking the UI and let the user see the content as it becomes available.
React will only prevent unwanted fallbacks during non-urgent updates. It will not delay a render if it’s the result of an urgent update. You must opt in with an API like startTransition or useDeferredValue.
If your router is integrated with Suspense, it should wrap its updates into startTransition automatically.
Previous<StrictMode>

<Activity>
Experimental Feature
This API is experimental and is not available in a stable version of React yet.
You can try it by upgrading React packages to the most recent experimental version:
react@experimental
react-dom@experimental
eslint-plugin-react-hooks@experimental
Experimental versions of React may contain bugs. Don’t use them in production.
<Activity> lets you hide and show part of the UI.
<Activity mode={mode}>
 <Page />
</Activity>
Reference
<Activity>
Usage
Pre-render part of the UI
Keeping state for part of the UI
Troubleshooting
Effects don’t mount when an Activity is hidden
My hidden Activity is not rendered in SSR

Reference 
<Activity> 
Wrap a part of the UI in <Activity> to manage its visibility state:
import {unstable_Activity as Activity} from 'react';

<Activity mode={isVisible ? 'visible' : 'hidden'}>
 <Page />
</Activity>
When “hidden”, the children of <Activity /> are not visible on the page. If a new <Activity> mounts as “hidden” then it pre-renders the content at lower priority without blocking the visible content on the page, but it does not mount by creating Effects. When a “visible” Activity switches to “hidden” it conceptually unmounts by destroying all the Effects, but saves its state. This allows fast switching between “visible” and “hidden” states without recreating the state for a “hidden” Activity.
In the future, “hidden” Activities may automatically destroy state based on resources like memory.
Props 
children: The actual UI you intend to render.
optional mode: Either “visible” or “hidden”. Defaults to “visible”. When “hidden”, updates to the children are deferred to lower priority. The component will not create Effects until the Activity is switched to “visible”. If a “visible” Activity switches to “hidden”, the Effects will be destroyed.
Caveats 
While hidden, the children of <Activity> are hidden on the page.
<Activity> will unmount all Effects when switching from “visible” to “hidden” without destroying React or DOM state. This means Effects that are expected to run only once on mount will run again when switching from “hidden” to “visible”. Conceptually, “hidden” Activities are unmounted, but they are not destroyed either. We recommend using <StrictMode> to catch any unexpected side-effects from this behavior.
When used with <ViewTransition>, hidden activities that reveal in a transition will activate an “enter” animation. Visible Activities hidden in a transition will activate an “exit” animation.
Parts of the UI wrapped in <Activity mode="hidden"> are not included in the SSR response.
Parts of the UI wrapped in <Activity mode="visible"> will hydrate at a lower priority than other content.

Usage 
Pre-render part of the UI 
You can pre-render part of the UI using <Activity mode="hidden">:
<Activity mode={tab === "posts" ? "visible" : "hidden"}>
 <PostsTab />
</Activity>
When an Activity is rendered with mode="hidden", the children are not visible on the page, but are rendered at lower priority than the visible content on the page.
When the mode later switches to “visible”, the pre-rendered children will mount and become visible. This can be used to prepare parts of the UI the user is likely to interact with next to reduce loading times.
In the following example from useTransition, the PostsTab component fetches some data using use. When you click the “Posts” tab, the PostsTab component suspends, causing the button loading state to appear:
App.jsTabButton.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
import { useTransition } from 'react';

export default function TabButton({ action, children, isActive }) {
 const [isPending, startTransition] = useTransition();
 if (isActive) {
   return <b>{children}</b>
 }
 if (isPending) {
   return <b className="pending">{children}</b>;
 }
 return (
   <button onClick={() => {
     startTransition(() => {
       action();
     });
   }}>
     {children}
   </button>
 );
}

Show more
In this example, the user needs to wait for the posts to load when clicking on the “Posts” tab.
We can reduce the delay for the “Posts” tab by pre-rendering the inactive Tabs with a hidden <Activity>:
App.jsTabButton.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
import { useTransition } from 'react';

export default function TabButton({ action, children, isActive }) {
 const [isPending, startTransition] = useTransition();
 if (isActive) {
   return <b>{children}</b>
 }
 if (isPending) {
   return <b className="pending">{children}</b>;
 }
 return (
   <button onClick={() => {
     startTransition(() => {
       action();
     });
   }}>
     {children}
   </button>
 );
}

Show more

Keeping state for part of the UI 
You can keep state for parts of the UI by switching <Activity> from “visible” to “hidden”:
<Activity mode={tab === "posts" ? "visible" : "hidden"}>
 <PostsTab />
</Activity>
When an Activity switches from mode="visible" to “hidden”, the children will become hidden on the page, and unmount by destroying all Effects, but will keep their React and DOM state.
When the mode later switches to “visible”, the saved state will be re-used when mounting the children by creating all the Effects. This can be used to keep state in parts of the UI the user is likely to interact with again to maintain DOM or React state.
In the following example from useTransition, the ContactTab includes a <textarea> with a draft message to send. If you enter some text and change to a different tab, then when you click the “Contact” tab again, the draft message is lost:
App.jsTabButton.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
import { useTransition } from 'react';

export default function TabButton({ action, children, isActive }) {
 const [isPending, startTransition] = useTransition();
 if (isActive) {
   return <b>{children}</b>
 }
 if (isPending) {
   return <b className="pending">{children}</b>;
 }
 return (
   <button onClick={() => {
     startTransition(() => {
       action();
     });
   }}>
     {children}
   </button>
 );
}

Show more
This results in losing DOM state the user has input. We can keep the state for the Contact tab by hiding the inactive Tabs with <Activity>:
App.jsTabButton.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
import { useTransition } from 'react';

export default function TabButton({ action, children, isActive }) {
 const [isPending, startTransition] = useTransition();
 if (isActive) {
   return <b>{children}</b>
 }
 if (isPending) {
   return <b className="pending">{children}</b>;
 }
 return (
   <button onClick={() => {
     startTransition(() => {
       action();
     });
   }}>
     {children}
   </button>
 );
}

Show more

Troubleshooting 
Effects don’t mount when an Activity is hidden 
When an <Activity> is “hidden”, all Effects are unmounted. Conceptually, the component is unmounted, but React saves the state for later.
This is a feature of Activity because it means subscriptions won’t be subscribed for hidden parts of the UI, reducing the amount of work for hidden content. It also means cleanup, such as pausing a video (which would be expected if you unmounted without Activity) will fire. When an Activity switches to “visible”, it will mount by creating the Effects, which will subscribe and play the video.
Consider the following example, where a different video is played for each button:
App.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
import { useState, useRef, useEffect } from 'react';
import './checker.js';

function VideoPlayer({ src, isPlaying }) {
 const ref = useRef(null);

 useEffect(() => {
   const videoRef = ref.current;
   videoRef.play();
  
   return () => {
     videoRef.pause();
   }
 }, []);

 return <video ref={ref} src={src} muted loop playsInline/>;
}

export default function App() {
 const [video, setVideo] = useState(1);
 return (
   <>
     <div>
       <button onClick={() => setVideo(1)}>Big Buck Bunny</button>
       <button onClick={() => setVideo(2)}>Elephants Dream</button>
     </div>
     {video === 1 &&
       <VideoPlayer key={1}
         // 'Big Buck Bunny' licensed under CC 3.0 by the Blender foundation. Hosted by archive.org
         src="https://archive.org/download/BigBuckBunny_124/Content/big_buck_bunny_720p_surround.mp4" />

     }
     {video === 2 &&
       <VideoPlayer key={2}
         // 'Elephants Dream' by Orange Open Movie Project Studio, licensed under CC-3.0, hosted by archive.org
         src="https://archive.org/download/ElephantsDream/ed_1024_512kb.mp4"
Show more
Whenever you change videos and come back, the video re-loads from the beginning. To maintain the state, you may try to render both videos, and hide the inactive video in display: none. However, this will cause both videos to play at the same time:
App.js
Reset
Fork
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
import { useState, useRef, useEffect } from 'react';
 useEffect(() => {
   const videoRef = ref.current;
   videoRef.play();
  
   return () => {
     videoRef.pause();
   }
 }, []);

 return <video ref={ref} src={src} muted loop playsInline/>;
}

export default function App() {
 const [video, setVideo] = useState(1);
 return (
   <>
     <div>
       <button onClick={() => setVideo(1)}>Big Buck Bunny</button>
       <button onClick={() => setVideo(2)}>Elephants Dream</button>
     </div>
     <div style={{display: video === 1 ? 'block' : 'none'}}>
       <VideoPlayer
         // 'Big Buck Bunny' licensed under CC 3.0 by the Blender foundation. Hosted by archive.org
         src="https://archive.org/download/BigBuckBunny_124/Content/big_buck_bunny_720p_surround.mp4" />

     </div>
     <div style={{display: video === 2 ? 'block' : 'none'}}>
       <VideoPlayer
         // 'Elephants Dream' by Orange Open Movie Project Studio, licensed under CC-3.0, hosted by archive.org
         src="https://archive.org/download/ElephantsDream/ed_1024_512kb.mp4"
       />
     </div>
     <VideoChecker />
   </>
 );
}

Console (1)
Multiple playing videos: 2
Show more
This is similar to what would happen if Activity mounted Effects when hidden. Similarly, if Activity didn’t unmount Effects when hiding, the videos would continue to play in the background.
Activity solves this by not creating Effects when first rendered as “hidden” and destroying all Effects when switching from “visible” to “hidden”:
App.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
import { useState, useRef, useEffect, unstable_Activity as Activity } from 'react';
import VideoChecker from './checker.js';

function VideoPlayer({ src, isPlaying }) {
 const ref = useRef(null);

 useEffect(() => {
   const videoRef = ref.current;
   videoRef.play();
  
   return () => {
     videoRef.pause();
   }
 }, []);

 return <video ref={ref} src={src} muted loop playsInline/>;
}

export default function App() {
 const [video, setVideo] = useState(1);
 return (
   <>
     <div>
       <button onClick={() => setVideo(1)}>Big Buck Bunny</button>
       <button onClick={() => setVideo(2)}>Elephants Dream</button>
     </div>
     <Activity mode={video === 1 ? 'visible' : 'hidden'}>
       <VideoPlayer
         // 'Big Buck Bunny' licensed under CC 3.0 by the Blender foundation. Hosted by archive.org
         src="https://archive.org/download/BigBuckBunny_124/Content/big_buck_bunny_720p_surround.mp4" />
     </Activity>
     <Activity mode={video === 2 ? 'visible' : 'hidden'}>
       <VideoPlayer
         // 'Elephants Dream' by Orange Open Movie Project Studio, licensed under CC-3.0, hosted by archive.org
         src="https://archive.org/download/ElephantsDream/ed_1024_512kb.mp4"
       />
Show more
For this reason, it’s best to think of Activity conceptually as “unmounting” and “remounting” the component, but saving the React or DOM state for later. In practice, this works as expected if you have followed the You Might Not Need an Effect guide. To eagerly find problematic Effects, we recommend adding <StrictMode> which will eagerly perform Activity unmounts and mounts to catch any unexpected side-effects.
My hidden Activity is not rendered in SSR 
When you use <Activity mode="hidden"> during server-side rendering, the content of the Activity will not be included in the SSR response. This is because the content is not visible on the page and is not needed for the initial render. If you need to include the content in the SSR response, you can use a different approach like useDeferredValue to defer rendering of the content.
Previous<Suspense>

<ViewTransition>
Experimental Feature
This API is experimental and is not available in a stable version of React yet.
You can try it by upgrading React packages to the most recent experimental version:
react@experimental
react-dom@experimental
eslint-plugin-react-hooks@experimental
Experimental versions of React may contain bugs. Don’t use them in production.
<ViewTransition> lets you animate elements that update inside a Transition.
import {unstable_ViewTransition as ViewTransition} from 'react';

<ViewTransition>
 <div>...</div>
</ViewTransition>
Reference
<ViewTransition>
View Transition Class
Styling View Transitions
Usage
Animating an element on enter/exit
Animating a shared element
Animating reorder of items in a list
Animating from Suspense content
Opting-out of an animation
Customizing animations
Customizing animations with types
Building View Transition enabled routers
Troubleshooting
My <ViewTransition> is not activating
I’m getting an error “There are two <ViewTransition name=%s> components with the same name mounted at the same time.”

Reference 
<ViewTransition> 
Wrap elements in <ViewTransition> to animate them when they update inside a Transition. React uses the following heuristics to determine if a View Transition activates for an animation:
enter: If a ViewTransition itself gets inserted in this Transition, then this will activate.
exit: If a ViewTransition itself gets deleted in this Transition, then this will activate.
update: If a ViewTransition has any DOM mutations inside it that React is doing (such as a prop changing) or if the ViewTransition boundary itself changes size or position due to an immediate sibling. If there are nested ViewTransition then the mutation applies to them and not the parent.
share: If a named ViewTransition is inside a deleted subtree and another named ViewTransition with the same name is part of an inserted subtree in the same Transition, they form a Shared Element Transition, and it animates from the deleted one to the inserted one.
By default, <ViewTransition> animates with a smooth cross-fade (the browser default view transition). You can customize the animation by providing a View Transition Class to the <ViewTransition> component. You can  customize animations for each kind of trigger (see Styling View Transitions).
Deep Dive
How does <ViewTransition> work? 
Show Details










Props 
By default, <ViewTransition> animates with a smooth cross-fade. You can customize the animation, or specify a shared element transition, with these props:
optional enter: A string or object. The View Transition Class to apply when enter is activated.
optional exit: A string or object. The View Transition Class to apply when exit is activated.
optional update: A string or object. The View Transition Class to apply when an update is activated.
optional share: A string or object. The View Transition Class to apply when a shared element is activated.
optional default: A string or object. The View Transition Class used when no other matching activation prop is found.
optional name: A string or object. The name of the View Transition used for shared element transitions. If not provided, React will use a unique name for each View Transition to prevent unexpected animations.
Callback 
These callbacks allow you to adjust the animation imperatively using the animate APIs:
optional onEnter: A function. React calls onEnter after an “enter” animation.
optional onExit: A function. React calls onExit after an “exit” animation.
optional onShare: A function. React calls onShare after a “share” animation.
optional onUpdate: A function. React calls onUpdate after an “update” animation.
Each callback receives as arguments:
element: The DOM element that was animated.
types: The Transition Types included in the animation.
View Transition Class 
The View Transition Class is the CSS class name(s) applied by React during the transition when the ViewTransition activates. It can be a string or an object.
string: the class added on the child elements when activated. If 'none' is provided, no class will be added.
object: the class added on the child elements will be the key matching View Transition type added with addTransitionType. The object can also specify a default to use if no matching type is found.
The value 'none' can be used to prevent a View Transition from activating for a specific trigger.
Styling View Transitions 
Note
In many early examples of View Transitions around the web, you’ll have seen using a view-transition-name and then style it using ::view-transition-...(my-name) selectors. We don’t recommend that for styling. Instead, we normally recommend using a View Transition Class instead.
To customize the animation for a <ViewTransition> you can provide a View Transition Class to one of the activation props. The View Transition Class is a CSS class name that React applies to the child elements when the ViewTransition activates.
For example, to customize an “enter” animation, provide a class name to the enter prop:
<ViewTransition enter="slide-in">
When the <ViewTransition> activates an “enter” animation, React will add the class name slide-in. Then you can refer to this class using view transition pseudo selectors to build reusable animations:
::view-transition-group(.slide-in) {

}
::view-transition-old(.slide-in) {

}
::view-transition-new(.slide-in) {

}
In the future, CSS libraries may add built-in animations using View Transition Classes to make this easier to use.
Caveats 
By default, setState updates immediately and does not activate <ViewTransition>, only updates wrapped in a Transition. You can also use <Suspense> to opt-in to a Transition to reveal content.
<ViewTransition> creates an image that can be moved around, scaled and cross-faded. Unlike Layout Animations you may have seen in React Native or Motion, this means that not every individual Element inside of it animates its position. This can lead to better performance and a more continuous feeling, smooth animation compared to animating every individual piece. However, it can also lose continuity in things that should be moving by themselves. So you might have to add more <ViewTransition> boundaries manually as a result.
Many users may prefer not having animations on the page. React doesn’t automatically disable animations for this case. We recommend that using the @media (prefers-reduced-motion) media query to disable animations or tone them down based on user preference. In the future, CSS libraries may have this built-in to their presets.
Currently, <ViewTransition> only works in the DOM. We’re working on adding support for React Native and other platforms.

Usage 
Animating an element on enter/exit 
Enter/Exit Transitions trigger when a <ViewTransition> is added or removed by a component in a transition:
function Child() {
 return <ViewTransition>Hi</ViewTransition>
}

function Parent() {
 const [show, setShow] = useState();
 if (show) {
   return <Child />;
 }
 return null;
}
When setShow is called, show switches to true and the Child component is rendered. When setShow is called inside startTransition, and Child renders a ViewTransition before any other DOM nodes, an enter animation is triggered.
When show switches back to false, an exit animation is triggered.
App.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
import {
 unstable_ViewTransition as ViewTransition,
 useState,
 startTransition
} from 'react';
import {Video} from "./Video";
import videos from "./data"

function Item() {
 return (
   <ViewTransition>
     <Video video={videos[0]}/>
   </ViewTransition>
 );
}

export default function Component() {
 const [showItem, setShowItem] = useState(false);
 return (
   <>
     <button
       onClick={() => {
         startTransition(() => {
           setShowItem((prev) => !prev);
         });
       }}
     >{showItem ? '➖' : '➕'}</button>

     {showItem ? <Item /> : null}
   </>
 );
}

Show more
Pitfall
<ViewTransition> only activates if it is placed before any DOM node. If Child instead looked like this, no animation would trigger:
function Component() {
 return (
   <div>
     <ViewTransition>Hi</ViewTransition>
   </div>
 );
}

Animating a shared element 
Normally, we don’t recommend assigning a name to a <ViewTransition> and instead let React assign it an automatic name. The reason you might want to assign a name is to animate between completely different components when one tree unmounts and another tree mounts at the same time. To preserve continuity.
<ViewTransition name={UNIQUE_NAME}>
 <Child />
</ViewTransition>
When one tree unmounts and another mounts, if there’s a pair where the same name exists in the unmounting tree and the mounting tree, they trigger the “share” animation on both. It animates from the unmounting side to the mounting side.
Unlike an exit/enter animation this can be deeply inside the deleted/mounted tree. If a <ViewTransition> would also be eligible for exit/enter, then the “share” animation takes precedence.
If Transition first unmounts one side and then leads to a <Suspense> fallback being shown before eventually the new name being mounted, then no shared element transition happens.
App.jsVideo.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
import {
 unstable_ViewTransition as ViewTransition,
 useState,
 startTransition
} from "react";
import {Video, Thumbnail, FullscreenVideo} from "./Video";
import videos from "./data";

export default function Component() {
 const [fullscreen, setFullscreen] = useState(false);
 if (fullscreen) {
   return <FullscreenVideo
     video={videos[0]}
     onExit={() => startTransition(() => setFullscreen(false))}
   />
 }
 return <Video
   video={videos[0]}
   onClick={() => startTransition(() => setFullscreen(true))}
 />
}


Show more
Note
If either the mounted or unmounted side of a pair is outside the viewport, then no pair is formed. This ensures that it doesn’t fly in or out of the viewport when something is scrolled. Instead it’s treated as a regular enter/exit by itself.
This does not happen if the same Component instance changes position, which triggers an “update”. Those animate regardless if one position is outside the viewport.
There’s currently a quirk where if a deeply nested unmounted <ViewTransition> is inside the viewport but the mounted side is not within the viewport, then the unmounted side animates as its own “exit” animation even if it’s deeply nested instead of as part of the parent animation.
Pitfall
It’s important that there’s only one thing with the same name mounted at a time in the entire app. Therefore it’s important to use unique namespaces for the name to avoid conflicts. To ensure you can do this you might want to add a constant in a separate module that you import.
export const MY_NAME = "my-globally-unique-name";
import {MY_NAME} from './shared-name';
...
<ViewTransition name={MY_NAME}>

Animating reorder of items in a list 
items.map(item => <Component key={item.id} item={item} />)
When reordering a list, without updating the content, the “update” animation triggers on each <ViewTransition> in the list if they’re outside a DOM node. Similar to enter/exit animations.
This means that this will trigger the animation on this <ViewTransition>:
function Component() {
 return <ViewTransition><div>...</div></ViewTransition>;
}
App.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
import {
 unstable_ViewTransition as ViewTransition,
 useState,
 startTransition
} from "react";
import {Video} from "./Video";
import videos from "./data";

export default function Component() {
 const [orderedVideos, setOrderedVideos] = useState(videos);
 const reorder = () => {
   startTransition(() => {
     setOrderedVideos((prev) => {
       return [...prev.sort(() => Math.random() - 0.5)];
     });
   });
 };
 return (
   <>
     <button onClick={reorder}>🎲</button>
     <div className="listContainer">
       {orderedVideos.map((video, i) => {
         return (
           <ViewTransition key={video.title}>
             <Video video={video} />
           </ViewTransition>
         );
       })}
     </div>
   </>
 );
}


Show more
However, this wouldn’t animate each individual item:
function Component() {
 return <div><ViewTransition>...</ViewTransition></div>;
}
Instead, any parent <ViewTransition> would cross-fade. If there is no parent <ViewTransition> then there’s no animation in that case.
App.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
import {
 unstable_ViewTransition as ViewTransition,
 useState,
 startTransition
} from "react";
import {Video} from "./Video";
import videos from "./data";

export default function Component() {
 const [orderedVideos, setOrderedVideos] = useState(videos);
 const reorder = () => {
   startTransition(() => {
     setOrderedVideos((prev) => {
       return [...prev.sort(() => Math.random() - 0.5)];
     });
   });
 };
 return (
   <>
     <button onClick={reorder}>🎲</button>
     <ViewTransition>
       <div className="listContainer">
         {orderedVideos.map((video, i) => {
           return <Video video={video} key={video.title} />;
         })}
       </div>
     </ViewTransition>
   </>
 );
}


Show more
This means you might want to avoid wrapper elements in lists where you want to allow the Component to control its own reorder animation:
items.map(item => <div><Component key={item.id} item={item} /></div>)
The above rule also applies if one of the items updates to resize, which then causes the siblings to resize, it’ll also animate its sibling <ViewTransition> but only if they’re immediate siblings.
This means that during an update, which causes a lot of re-layout, it doesn’t individually animate every <ViewTransition> on the page. That would lead to a lot of noisy animations which distracts from the actual change. Therefore React is more conservative about when an individual animation triggers.
Pitfall
It’s important to properly use keys to preserve identity when reordering lists. It might seem like you could use “name”, shared element transitions, to animate reorders but that would not trigger if one side was outside the viewport. To animate a reorder you often want to show that it went to a position outside the viewport.

Animating from Suspense content 
Just like any Transition, React waits for data and new CSS (<link rel="stylesheet" precedence="...">) before running the animation. In addition to this, ViewTransitions also wait up to 500ms for new fonts to load before starting the animation to avoid them flickering in later. For the same reason, an image wrapped in ViewTransition will wait for the image to load.
If it’s inside a new Suspense boundary instance, then the fallback is shown first. After the Suspense boundary fully loads, it triggers the <ViewTransition> to animate the reveal to the content.
Currently, this only happens for client-side Transition. In the future, this will also animate Suspense boundary for streaming SSR when content from the server suspends during the initial load.
There are two ways to animate Suspense boundaries depending on where you place the <ViewTransition>:
Update:
<ViewTransition>
 <Suspense fallback={<A />}>
   <B />
 </Suspense>
</ViewTransition>
In this scenario when the content goes from A to B, it’ll be treated as an “update” and apply that class if appropriate. Both A and B will get the same view-transition-name and therefore they’re acting as a cross-fade by default.
App.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
import {
 unstable_ViewTransition as ViewTransition,
 useState,
 startTransition,
 Suspense
} from 'react';
import {Video, VideoPlaceholder} from "./Video";
import {useLazyVideoData} from "./data"

function LazyVideo() {
 const video = useLazyVideoData();
 return (
   <Video video={video}/>
 );
}

export default function Component() {
 const [showItem, setShowItem] = useState(false);
 return (
   <>
     <button
       onClick={() => {
         startTransition(() => {
           setShowItem((prev) => !prev);
         });
       }}
     >{showItem ? '➖' : '➕'}</button>
     {showItem ? (
       <ViewTransition>
         <Suspense fallback={<VideoPlaceholder />}>
           <LazyVideo />
         </Suspense>
       </ViewTransition>
     ) : null}
   </>
 );
Show more
Enter/Exit:
<Suspense fallback={<ViewTransition><A /></ViewTransition>}>
 <ViewTransition><B /></ViewTransition>
</Suspense>
In this scenario, these are two separate ViewTransition instances each with their own view-transition-name. This will be treated as an “exit” of the <A> and an “enter” of the <B>.
You can achieve different effects depending on where you choose to place the <ViewTransition> boundary.

Opting-out of an animation 
Sometimes you’re wrapping a large existing component, like a whole page, and you want to animate some updates, such as changing the theme. However, you don’t want it to opt-in all updates inside the whole page to cross-fade when they’re updating. Especially if you’re incrementally adding more animations.
You can use the class “none” to opt-out of an animation. By wrapping your children in a “none” you can disable animations for updates to them while the parent still triggers.
<ViewTransition>
 <div className={theme}>
   <ViewTransition update="none">
     {children}
   </ViewTransition>
 </div>
</ViewTransition>
This will only animate if the theme changes and not if only the children update. The children can still opt-in again with their own <ViewTransition> but at least it’s manual again.

Customizing animations 
By default, <ViewTransition> includes the default cross-fade from the browser.
To customize animations, you can provide props to the <ViewTransition> component to specify which animations to use, based on how the <ViewTransition> activates.
For example, we can slow down the default cross fade animation:
<ViewTransition default="slow-fade">
 <Video />
</ViewTransition>
And define slow-fade in CSS using view transition classes:
::view-transition-old(.slow-fade) {
   animation-duration: 500ms;
}

::view-transition-new(.slow-fade) {
   animation-duration: 500ms;
}
App.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
import {
 unstable_ViewTransition as ViewTransition,
 useState,
 startTransition
} from 'react';
import {Video} from "./Video";
import videos from "./data"

function Item() {
 return (
   <ViewTransition default="slow-fade">
     <Video video={videos[0]}/>
   </ViewTransition>
 );
}

export default function Component() {
 const [showItem, setShowItem] = useState(false);
 return (
   <>
     <button
       onClick={() => {
         startTransition(() => {
           setShowItem((prev) => !prev);
         });
       }}
     >{showItem ? '➖' : '➕'}</button>

     {showItem ? <Item /> : null}
   </>
 );
}

Show more
In addition to setting the default, you can also provide configurations for enter, exit, update, and share animations.
App.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
import {
 unstable_ViewTransition as ViewTransition,
 useState,
 startTransition
} from 'react';
import {Video} from "./Video";
import videos from "./data"

function Item() {
 return (
   <ViewTransition enter="slide-in" exit="slide-out">
     <Video video={videos[0]}/>
   </ViewTransition>
 );
}

export default function Component() {
 const [showItem, setShowItem] = useState(false);
 return (
   <>
     <button
       onClick={() => {
         startTransition(() => {
           setShowItem((prev) => !prev);
         });
       }}
     >{showItem ? '➖' : '➕'}</button>

     {showItem ? <Item /> : null}
   </>
 );
}

Show more
Customizing animations with types 
You can use the addTransitionType API to add a class name to the child elements when a specific transition type is activated for a specific activation trigger. This allows you to customize the animation for each type of transition.
For example, to customize the animation for all forward and backward navigations:
<ViewTransition default={{
 'navigation-back': 'slide-right',
 'navigation-forward': 'slide-left',
}}>
 <div>...</div>
</ViewTransition>

// in your router:
startTransition(() => {
 addTransitionType('navigation-' + navigationType);
});
When the ViewTransition activates a “navigation-back” animation, React will add the class name “slide-right”. When the ViewTransition activates a “navigation-forward” animation, React will add the class name “slide-left”.
In the future, routers and other libraries may add support for standard view-transition types and styles.
App.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
import {
 unstable_ViewTransition as ViewTransition,
 unstable_addTransitionType as addTransitionType,
 useState,
 startTransition,
} from "react";
import {Video} from "./Video";
import videos from "./data"

function Item() {
 return (
   <ViewTransition enter={
       {
         "add-video-back": "slide-in-back",
         "add-video-forward": "slide-in-forward"
       }
     }
     exit={
       {
         "remove-video-back": "slide-in-forward",
         "remove-video-forward": "slide-in-back"
       }
     }>
     <Video video={videos[0]}/>
   </ViewTransition>
 );
}

export default function Component() {
 const [showItem, setShowItem] = useState(false);
 return (
   <>
     <div className="button-container">
       <button
         onClick={() => {
           startTransition(() => {
Show more
Building View Transition enabled routers 
React waits for any pending Navigation to finish to ensure that scroll restoration happens within the animation. If the Navigation is blocked on React, your router must unblock in useLayoutEffect since useEffect would lead to a deadlock.
If a startTransition is started from the legacy popstate event, such as during a “back”-navigation then it must finish synchronously to ensure scroll and form restoration works correctly. This is in conflict with running a View Transition animation. Therefore, React will skip animations from popstate. Therefore animations won’t run for the back button. You can fix this by upgrading your router to use the Navigation API.

Troubleshooting 
My <ViewTransition> is not activating 
<ViewTransition> only activates if it is placed is before any DOM node:
function Component() {
 return (
   <div>
     <ViewTransition>Hi</ViewTransition>
   </div>
 );
}
To fix, ensure that the <ViewTransition> comes before any other DOM nodes:
function Component() {
 return (
   <ViewTransition>
     <div>Hi</div>
   </ViewTransition>
 );
}
I’m getting an error “There are two <ViewTransition name=%s> components with the same name mounted at the same time.” 
This error occurs when two <ViewTransition> components with the same name are mounted at the same time:
function Item() {
 // 🚩 All items will get the same "name".
 return <ViewTransition name="item">...</ViewTransition>;
}

function ItemList({items}) {
 return (
   <>
     {item.map(item => <Item key={item.id} />)}
   </>
 );
}
This will cause the View Transition to error. In development, React detects this issue to surface it and logs two errors:
Console
There are two <ViewTransition name=%s> components with the same name mounted at the same time. This is not supported and will cause View Transitions to error. Try to use a more unique name e.g. by using a namespace prefix and adding the id of an item to the name. at Item at ItemList
The existing <ViewTransition name=%s> duplicate has this stack trace. at Item at ItemList
To fix, ensure that there’s only one <ViewTransition> with the same name mounted at a time in the entire app by ensuring the name is unique, or adding an id to the name:
function Item({id}) {
 // ✅ All items will get the same "name".
 return <ViewTransition name={`item-${id}`}>...</ViewTransition>;
}

function ItemList({items}) {
 return (
   <>
     {item.map(item => <Item key={item.id} item={item} />)}
   </>
 );
}

Built-in React APIs
In addition to Hooks and Components, the react package exports a few other APIs that are useful for defining components. This page lists all the remaining modern React APIs.

createContext lets you define and provide context to the child components. Used with useContext.
lazy lets you defer loading a component’s code until it’s rendered for the first time.
memo lets your component skip re-renders with same props. Used with useMemo and useCallback.
startTransition lets you mark a state update as non-urgent. Similar to useTransition.
act lets you wrap renders and interactions in tests to ensure updates have processed before making assertions.

Resource APIs 
Resources can be accessed by a component without having them as part of their state. For example, a component can read a message from a Promise or read styling information from a context.
To read a value from a resource, use this API:
use lets you read the value of a resource like a Promise or context.
function MessageComponent({ messagePromise }) {
 const message = use(messagePromise);
 const theme = use(ThemeContext);
 // ...
}
act
act is a test helper to apply pending React updates before making assertions.
await act(async actFn)
To prepare a component for assertions, wrap the code rendering it and performing updates inside an await act() call. This makes your test run closer to how React works in the browser.
Note
You might find using act() directly a bit too verbose. To avoid some of the boilerplate, you could use a library like React Testing Library, whose helpers are wrapped with act().
Reference
await act(async actFn)
Usage
Rendering components in tests
Dispatching events in tests
Troubleshooting
I’m getting an error: “The current testing environment is not configured to support act”(…)”

Reference 
await act(async actFn) 
When writing UI tests, tasks like rendering, user events, or data fetching can be considered as “units” of interaction with a user interface. React provides a helper called act() that makes sure all updates related to these “units” have been processed and applied to the DOM before you make any assertions.
The name act comes from the Arrange-Act-Assert pattern.
it ('renders with button disabled', async () => {
 await act(async () => {
   root.render(<TestComponent />)
 });
 expect(container.querySelector('button')).toBeDisabled();
});
Note
We recommend using act with await and an async function. Although the sync version works in many cases, it doesn’t work in all cases and due to the way React schedules updates internally, it’s difficult to predict when you can use the sync version.
We will deprecate and remove the sync version in the future.
Parameters 
async actFn: An async function wrapping renders or interactions for components being tested. Any updates triggered within the actFn, are added to an internal act queue, which are then flushed together to process and apply any changes to the DOM. Since it is async, React will also run any code that crosses an async boundary, and flush any updates scheduled.
Returns 
act does not return anything.
Usage 
When testing a component, you can use act to make assertions about its output.
For example, let’s say we have this Counter component, the usage examples below show how to test it:
function Counter() {
 const [count, setCount] = useState(0);
 const handleClick = () => {
   setCount(prev => prev + 1);
 }

 useEffect(() => {
   document.title = `You clicked ${count} times`;
 }, [count]);

 return (
   <div>
     <p>You clicked {count} times</p>
     <button onClick={handleClick}>
       Click me
     </button>
   </div>
 )
}
Rendering components in tests 
To test the render output of a component, wrap the render inside act():
import {act} from 'react';
import ReactDOMClient from 'react-dom/client';
import Counter from './Counter';

it('can render and update a counter', async () => {
 container = document.createElement('div');
 document.body.appendChild(container);

 // ✅ Render the component inside act().
 await act(() => {
   ReactDOMClient.createRoot(container).render(<Counter />);
 });

 const button = container.querySelector('button');
 const label = container.querySelector('p');
 expect(label.textContent).toBe('You clicked 0 times');
 expect(document.title).toBe('You clicked 0 times');
});
Here, we create a container, append it to the document, and render the Counter component inside act(). This ensures that the component is rendered and its effects are applied before making assertions.
Using act ensures that all updates have been applied before we make assertions.
Dispatching events in tests 
To test events, wrap the event dispatch inside act():
import {act} from 'react';
import ReactDOMClient from 'react-dom/client';
import Counter from './Counter';

it.only('can render and update a counter', async () => {
 const container = document.createElement('div');
 document.body.appendChild(container);

 await act( async () => {
   ReactDOMClient.createRoot(container).render(<Counter />);
 });

 // ✅ Dispatch the event inside act().
 await act(async () => {
   button.dispatchEvent(new MouseEvent('click', { bubbles: true }));
 });

 const button = container.querySelector('button');
 const label = container.querySelector('p');
 expect(label.textContent).toBe('You clicked 1 times');
 expect(document.title).toBe('You clicked 1 times');
});
Here, we render the component with act, and then dispatch the event inside another act(). This ensures that all updates from the event are applied before making assertions.
Pitfall
Don’t forget that dispatching DOM events only works when the DOM container is added to the document. You can use a library like React Testing Library to reduce the boilerplate code.
Troubleshooting 
I’m getting an error: “The current testing environment is not configured to support act”(…)” 
Using act requires setting global.IS_REACT_ACT_ENVIRONMENT=true in your test environment. This is to ensure that act is only used in the correct environment.
If you don’t set the global, you will see an error like this:
Console
Warning: The current testing environment is not configured to support act(…)
To fix, add this to your global setup file for React tests:
global.IS_REACT_ACT_ENVIRONMENT=true
Note
In testing frameworks like React Testing Library, IS_REACT_ACT_ENVIRONMENT is already set for you.

cache
React Server Components
cache is only for use with React Server Components.
cache lets you cache the result of a data fetch or computation.
const cachedFn = cache(fn);
Reference
cache(fn)
Usage
Cache an expensive computation
Share a snapshot of data
Preload data
Troubleshooting
My memoized function still runs even though I’ve called it with the same arguments

Reference 
cache(fn) 
Call cache outside of any components to create a version of the function with caching.
import {cache} from 'react';
import calculateMetrics from 'lib/metrics';

const getMetrics = cache(calculateMetrics);

function Chart({data}) {
 const report = getMetrics(data);
 // ...
}
When getMetrics is first called with data, getMetrics will call calculateMetrics(data) and store the result in cache. If getMetrics is called again with the same data, it will return the cached result instead of calling calculateMetrics(data) again.
See more examples below.
Parameters 
fn: The function you want to cache results for. fn can take any arguments and return any value.
Returns 
cache returns a cached version of fn with the same type signature. It does not call fn in the process.
When calling cachedFn with given arguments, it first checks if a cached result exists in the cache. If a cached result exists, it returns the result. If not, it calls fn with the arguments, stores the result in the cache, and returns the result. The only time fn is called is when there is a cache miss.
Note
The optimization of caching return values based on inputs is known as memoization. We refer to the function returned from cache as a memoized function.
Caveats 
React will invalidate the cache for all memoized functions for each server request.
Each call to cache creates a new function. This means that calling cache with the same function multiple times will return different memoized functions that do not share the same cache.
cachedFn will also cache errors. If fn throws an error for certain arguments, it will be cached, and the same error is re-thrown when cachedFn is called with those same arguments.
cache is for use in Server Components only.

Usage 
Cache an expensive computation 
Use cache to skip duplicate work.
import {cache} from 'react';
import calculateUserMetrics from 'lib/user';

const getUserMetrics = cache(calculateUserMetrics);

function Profile({user}) {
 const metrics = getUserMetrics(user);
 // ...
}

function TeamReport({users}) {
 for (let user in users) {
   const metrics = getUserMetrics(user);
   // ...
 }
 // ...
}
If the same user object is rendered in both Profile and TeamReport, the two components can share work and only call calculateUserMetrics once for that user.
Assume Profile is rendered first. It will call getUserMetrics, and check if there is a cached result. Since it is the first time getUserMetrics is called with that user, there will be a cache miss. getUserMetrics will then call calculateUserMetrics with that user and write the result to cache.
When TeamReport renders its list of users and reaches the same user object, it will call getUserMetrics and read the result from cache.
Pitfall
Calling different memoized functions will read from different caches. 
To access the same cache, components must call the same memoized function.
// Temperature.js
import {cache} from 'react';
import {calculateWeekReport} from './report';

export function Temperature({cityData}) {
 // 🚩 Wrong: Calling `cache` in component creates new `getWeekReport` for each render
 const getWeekReport = cache(calculateWeekReport);
 const report = getWeekReport(cityData);
 // ...
}
// Precipitation.js
import {cache} from 'react';
import {calculateWeekReport} from './report';

// 🚩 Wrong: `getWeekReport` is only accessible for `Precipitation` component.
const getWeekReport = cache(calculateWeekReport);

export function Precipitation({cityData}) {
 const report = getWeekReport(cityData);
 // ...
}
In the above example, Precipitation and Temperature each call cache to create a new memoized function with their own cache look-up. If both components render for the same cityData, they will do duplicate work to call calculateWeekReport.
In addition, Temperature creates a new memoized function each time the component is rendered which doesn’t allow for any cache sharing.
To maximize cache hits and reduce work, the two components should call the same memoized function to access the same cache. Instead, define the memoized function in a dedicated module that can be import-ed across components.
// getWeekReport.js
import {cache} from 'react';
import {calculateWeekReport} from './report';

export default cache(calculateWeekReport);
// Temperature.js
import getWeekReport from './getWeekReport';

export default function Temperature({cityData}) {
	const report = getWeekReport(cityData);
 // ...
}
// Precipitation.js
import getWeekReport from './getWeekReport';

export default function Precipitation({cityData}) {
 const report = getWeekReport(cityData);
 // ...
}
Here, both components call the same memoized function exported from ./getWeekReport.js to read and write to the same cache.
Share a snapshot of data 
To share a snapshot of data between components, call cache with a data-fetching function like fetch. When multiple components make the same data fetch, only one request is made and the data returned is cached and shared across components. All components refer to the same snapshot of data across the server render.
import {cache} from 'react';
import {fetchTemperature} from './api.js';

const getTemperature = cache(async (city) => {
	return await fetchTemperature(city);
});

async function AnimatedWeatherCard({city}) {
	const temperature = await getTemperature(city);
	// ...
}

async function MinimalWeatherCard({city}) {
	const temperature = await getTemperature(city);
	// ...
}
If AnimatedWeatherCard and MinimalWeatherCard both render for the same city, they will receive the same snapshot of data from the memoized function.
If AnimatedWeatherCard and MinimalWeatherCard supply different city arguments to getTemperature, then fetchTemperature will be called twice and each call site will receive different data.
The city acts as a cache key.
Note
Asynchronous rendering is only supported for Server Components.
async function AnimatedWeatherCard({city}) {
	const temperature = await getTemperature(city);
	// ...
}
Preload data 
By caching a long-running data fetch, you can kick off asynchronous work prior to rendering the component.
const getUser = cache(async (id) => {
 return await db.user.query(id);
});

async function Profile({id}) {
 const user = await getUser(id);
 return (
   <section>
     <img src={user.profilePic} />
     <h2>{user.name}</h2>
   </section>
 );
}

function Page({id}) {
 // ✅ Good: start fetching the user data
 getUser(id);
 // ... some computational work
 return (
   <>
     <Profile id={id} />
   </>
 );
}
When rendering Page, the component calls getUser but note that it doesn’t use the returned data. This early getUser call kicks off the asynchronous database query that occurs while Page is doing other computational work and rendering children.
When rendering Profile, we call getUser again. If the initial getUser call has already returned and cached the user data, when Profile asks and waits for this data, it can simply read from the cache without requiring another remote procedure call. If the initial data request hasn’t been completed, preloading data in this pattern reduces delay in data-fetching.
Deep Dive
Caching asynchronous work 
Hide Details
When evaluating an asynchronous function, you will receive a Promise for that work. The promise holds the state of that work (pending, fulfilled, failed) and its eventual settled result.
In this example, the asynchronous function fetchData returns a promise that is awaiting the fetch.
async function fetchData() {
 return await fetch(`https://...`);
}

const getData = cache(fetchData);

async function MyComponent() {
 getData();
 // ... some computational work 
 await getData();
 // ...
}
In calling getData the first time, the promise returned from fetchData is cached. Subsequent look-ups will then return the same promise.
Notice that the first getData call does not await whereas the second does. await is a JavaScript operator that will wait and return the settled result of the promise. The first getData call simply initiates the fetch to cache the promise for the second getData to look-up.
If by the second call the promise is still pending, then await will pause for the result. The optimization is that while we wait on the fetch, React can continue with computational work, thus reducing the wait time for the second call.
If the promise is already settled, either to an error or the fulfilled result, await will return that value immediately. In both outcomes, there is a performance benefit.
Pitfall
Calling a memoized function outside of a component will not use the cache. 
import {cache} from 'react';

const getUser = cache(async (userId) => {
 return await db.user.query(userId);
});

// 🚩 Wrong: Calling memoized function outside of component will not memoize.
getUser('demo-id');

async function DemoProfile() {
 // ✅ Good: `getUser` will memoize.
 const user = await getUser('demo-id');
 return <Profile user={user} />;
}
React only provides cache access to the memoized function in a component. When calling getUser outside of a component, it will still evaluate the function but not read or update the cache.
This is because cache access is provided through a context which is only accessible from a component.
Deep Dive
When should I use cache, memo, or useMemo? 
Hide Details
All mentioned APIs offer memoization but the difference is what they’re intended to memoize, who can access the cache, and when their cache is invalidated.
useMemo 
In general, you should use useMemo for caching a expensive computation in a Client Component across renders. As an example, to memoize a transformation of data within a component.
'use client';

function WeatherReport({record}) {
 const avgTemp = useMemo(() => calculateAvg(record), record);
 // ...
}

function App() {
 const record = getRecord();
 return (
   <>
     <WeatherReport record={record} />
     <WeatherReport record={record} />
   </>
 );
}
In this example, App renders two WeatherReports with the same record. Even though both components do the same work, they cannot share work. useMemo’s cache is only local to the component.
However, useMemo does ensure that if App re-renders and the record object doesn’t change, each component instance would skip work and use the memoized value of avgTemp. useMemo will only cache the last computation of avgTemp with the given dependencies.
cache 
In general, you should use cache in Server Components to memoize work that can be shared across components.
const cachedFetchReport = cache(fetchReport);

function WeatherReport({city}) {
 const report = cachedFetchReport(city);
 // ...
}

function App() {
 const city = "Los Angeles";
 return (
   <>
     <WeatherReport city={city} />
     <WeatherReport city={city} />
   </>
 );
}
Re-writing the previous example to use cache, in this case the second instance of WeatherReport will be able to skip duplicate work and read from the same cache as the first WeatherReport. Another difference from the previous example is that cache is also recommended for memoizing data fetches, unlike useMemo which should only be used for computations.
At this time, cache should only be used in Server Components and the cache will be invalidated across server requests.
memo 
You should use memo to prevent a component re-rendering if its props are unchanged.
'use client';

function WeatherReport({record}) {
 const avgTemp = calculateAvg(record);
 // ...
}

const MemoWeatherReport = memo(WeatherReport);

function App() {
 const record = getRecord();
 return (
   <>
     <MemoWeatherReport record={record} />
     <MemoWeatherReport record={record} />
   </>
 );
}
In this example, both MemoWeatherReport components will call calculateAvg when first rendered. However, if App re-renders, with no changes to record, none of the props have changed and MemoWeatherReport will not re-render.
Compared to useMemo, memo memoizes the component render based on props vs. specific computations. Similar to useMemo, the memoized component only caches the last render with the last prop values. Once the props change, the cache invalidates and the component re-renders.

Troubleshooting 
My memoized function still runs even though I’ve called it with the same arguments 
See prior mentioned pitfalls
Calling different memoized functions will read from different caches.
Calling a memoized function outside of a component will not use the cache.
If none of the above apply, it may be a problem with how React checks if something exists in cache.
If your arguments are not primitives (ex. objects, functions, arrays), ensure you’re passing the same object reference.
When calling a memoized function, React will look up the input arguments to see if a result is already cached. React will use shallow equality of the arguments to determine if there is a cache hit.
import {cache} from 'react';

const calculateNorm = cache((vector) => {
 // ...
});

function MapMarker(props) {
 // 🚩 Wrong: props is an object that changes every render.
 const length = calculateNorm(props);
 // ...
}

function App() {
 return (
   <>
     <MapMarker x={10} y={10} z={10} />
     <MapMarker x={10} y={10} z={10} />
   </>
 );
}
In this case the two MapMarkers look like they’re doing the same work and calling calculateNorm with the same value of {x: 10, y: 10, z:10}. Even though the objects contain the same values, they are not the same object reference as each component creates its own props object.
React will call Object.is on the input to verify if there is a cache hit.
import {cache} from 'react';

const calculateNorm = cache((x, y, z) => {
 // ...
});

function MapMarker(props) {
 // ✅ Good: Pass primitives to memoized function
 const length = calculateNorm(props.x, props.y, props.z);
 // ...
}

function App() {
 return (
   <>
     <MapMarker x={10} y={10} z={10} />
     <MapMarker x={10} y={10} z={10} />
   </>
 );
}
One way to address this could be to pass the vector dimensions to calculateNorm. This works because the dimensions themselves are primitives.
Another solution may be to pass the vector object itself as a prop to the component. We’ll need to pass the same object to both component instances.
import {cache} from 'react';

const calculateNorm = cache((vector) => {
 // ...
});

function MapMarker(props) {
 // ✅ Good: Pass the same `vector` object
 const length = calculateNorm(props.vector);
 // ...
}

function App() {
 const vector = [10, 10, 10];
 return (
   <>
     <MapMarker vector={vector} />
     <MapMarker vector={vector} />
   </>
 );
}

captureOwnerStack
captureOwnerStack reads the current Owner Stack in development and returns it as a string if available.
const stack = captureOwnerStack();
Reference
captureOwnerStack()
Usage
Enhance a custom error overlay
Troubleshooting
The Owner Stack is null
captureOwnerStack is not available

Reference 
captureOwnerStack() 
Call captureOwnerStack to get the current Owner Stack.
import * as React from 'react';

function Component() {
 if (process.env.NODE_ENV !== 'production') {
   const ownerStack = React.captureOwnerStack();
   console.log(ownerStack);
 }
}
Parameters 
captureOwnerStack does not take any parameters.
Returns 
captureOwnerStack returns string | null.
Owner Stacks are available in
Component render
Effects (e.g. useEffect)
React’s event handlers (e.g. <button onClick={...} />)
React error handlers (React Root options onCaughtError, onRecoverableError, and onUncaughtError)
If no Owner Stack is available, null is returned (see Troubleshooting: The Owner Stack is null).
Caveats 
Owner Stacks are only available in development. captureOwnerStack will always return null outside of development.
Deep Dive
Owner Stack vs Component Stack 
Hide Details
The Owner Stack is different from the Component Stack available in React error handlers like errorInfo.componentStack in onUncaughtError.
For example, consider the following code:
index.jsApp.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
import {captureOwnerStack} from 'react';
import {createRoot} from 'react-dom/client';
import App, {Component} from './App.js';
import './styles.css';

createRoot(document.createElement('div'), {
 onUncaughtError: (error, errorInfo) => {
   // The stacks are logged instead of showing them in the UI directly to
   // highlight that browsers will apply sourcemaps to the logged stacks.
   // Note that sourcemapping is only applied in the real browser console not
   // in the fake one displayed on this page.
   // Press "fork" to be able to view the sourcemapped stack in a real console.
   console.log(errorInfo.componentStack);
   console.log(captureOwnerStack());
 },
}).render(
 <App>
   <Component label="disabled" />
 </App>
);

Console (2)

    at SubComponent (https://786946de.sandpack-bundler-4bw.pages.dev/src/App.js:15:5)
    at fieldset (<anonymous>)
    at Component (https://786946de.sandpack-bundler-4bw.pages.dev/src/App.js:27:5)
    at main (<anonymous>)
    at Suspense (<anonymous>)
    at App (https://786946de.sandpack-bundler-4bw.pages.dev/src/App.js:48:5)

    at Component (https://786946de.sandpack-bundler-4bw.pages.dev/src/App.js:32:42)
Show more
SubComponent would throw an error.
The Component Stack of that error would be
at SubComponent
at fieldset
at Component
at main
at React.Suspense
at App
However, the Owner Stack would only read
at Component
Neither App nor the DOM components (e.g. fieldset) are considered Owners in this Stack since they didn’t contribute to “creating” the node containing SubComponent. App and DOM components only forwarded the node. App just rendered the children node as opposed to Component which created a node containing SubComponent via <SubComponent />.
Neither Navigation nor legend are in the stack at all since it’s only a sibling to a node containing <SubComponent />.
SubComponent is omitted because it’s already part of the callstack.
Usage 
Enhance a custom error overlay 
import { captureOwnerStack } from "react";
import { instrumentedConsoleError } from "./errorOverlay";

const originalConsoleError = console.error;
console.error = function patchedConsoleError(...args) {
 originalConsoleError.apply(console, args);
 const ownerStack = captureOwnerStack();
 onConsoleError({
   // Keep in mind that in a real application, console.error can be
   // called with multiple arguments which you should account for.
   consoleMessage: args[0],
   ownerStack,
 });
};
If you intercept console.error calls to highlight them in an error overlay, you can call captureOwnerStack to include the Owner Stack.
index.jserrorOverlay.jsApp.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
import { captureOwnerStack } from "react";
import { createRoot } from "react-dom/client";
import App from './App';
import { onConsoleError } from "./errorOverlay";
import './styles.css';

const originalConsoleError = console.error;
console.error = function patchedConsoleError(...args) {
 originalConsoleError.apply(console, args);
 const ownerStack = captureOwnerStack();
 onConsoleError({
   // Keep in mind that in a real application, console.error can be
   // called with multiple arguments which you should account for.
   consoleMessage: args[0],
   ownerStack,
 });
};

const container = document.getElementById("root");
createRoot(container).render(<App />);

Show more
Troubleshooting 
The Owner Stack is null 
The call of captureOwnerStack happened outside of a React controlled function e.g. in a setTimeout callback, after a fetch call or in a custom DOM event handler. During render, Effects, React event handlers, and React error handlers (e.g. hydrateRoot#options.onCaughtError) Owner Stacks should be available.
In the example below, clicking the button will log an empty Owner Stack because captureOwnerStack was called during a custom DOM event handler. The Owner Stack must be captured earlier e.g. by moving the call of captureOwnerStack into the Effect body.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
import {captureOwnerStack, useEffect} from 'react';

export default function App() {
 useEffect(() => {
   // Should call `captureOwnerStack` here.
   function handleEvent() {
     // Calling it in a custom DOM event handler is too late.
     // The Owner Stack will be `null` at this point.
     console.log('Owner Stack: ', captureOwnerStack());
   }

   document.addEventListener('click', handleEvent);

   return () => {
     document.removeEventListener('click', handleEvent);
   }
 })

 return <button>Click me to see that Owner Stacks are not available in custom DOM event handlers</button>;
}

Show more
captureOwnerStack is not available 
captureOwnerStack is only exported in development builds. It will be undefined in production builds. If captureOwnerStack is used in files that are bundled for production and development, you should conditionally access it from a namespace import.
// Don't use named imports of `captureOwnerStack` in files that are bundled for development and production.
import {captureOwnerStack} from 'react';
// Use a namespace import instead and access `captureOwnerStack` conditionally.
import * as React from 'react';

if (process.env.NODE_ENV !== 'production') {
 const ownerStack = React.captureOwnerStack();
 console.log('Owner Stack', ownerStack);
}

createContext
createContext lets you create a context that components can provide or read.
const SomeContext = createContext(defaultValue)
Reference
createContext(defaultValue)
SomeContext Provider
SomeContext.Consumer
Usage
Creating context
Importing and exporting context from a file
Troubleshooting
I can’t find a way to change the context value

Reference 
createContext(defaultValue) 
Call createContext outside of any components to create a context.
import { createContext } from 'react';

const ThemeContext = createContext('light');
See more examples below.
Parameters 
defaultValue: The value that you want the context to have when there is no matching context provider in the tree above the component that reads context. If you don’t have any meaningful default value, specify null. The default value is meant as a “last resort” fallback. It is static and never changes over time.
Returns 
createContext returns a context object.
The context object itself does not hold any information. It represents which context other components read or provide. Typically, you will use SomeContext in components above to specify the context value, and call useContext(SomeContext) in components below to read it. The context object has a few properties:
SomeContext lets you provide the context value to components.
SomeContext.Consumer is an alternative and rarely used way to read the context value.
SomeContext.Provider is a legacy way to provide the context value before React 19.

SomeContext Provider 
Wrap your components into a context provider to specify the value of this context for all components inside:
function App() {
 const [theme, setTheme] = useState('light');
 // ...
 return (
   <ThemeContext value={theme}>
     <Page />
   </ThemeContext>
 );
}
Note
Starting in React 19, you can render <SomeContext> as a provider.
In older versions of React, use <SomeContext.Provider>.
Props 
value: The value that you want to pass to all the components reading this context inside this provider, no matter how deep. The context value can be of any type. A component calling useContext(SomeContext) inside of the provider receives the value of the innermost corresponding context provider above it.

SomeContext.Consumer 
Before useContext existed, there was an older way to read context:
function Button() {
 // 🟡 Legacy way (not recommended)
 return (
   <ThemeContext.Consumer>
     {theme => (
       <button className={theme} />
     )}
   </ThemeContext.Consumer>
 );
}
Although this older way still works, newly written code should read context with useContext() instead:
function Button() {
 // ✅ Recommended way
 const theme = useContext(ThemeContext);
 return <button className={theme} />;
}
Props 
children: A function. React will call the function you pass with the current context value determined by the same algorithm as useContext() does, and render the result you return from this function. React will also re-run this function and update the UI whenever the context from the parent components changes.

Usage 
Creating context 
Context lets components pass information deep down without explicitly passing props.
Call createContext outside any components to create one or more contexts.
import { createContext } from 'react';

const ThemeContext = createContext('light');
const AuthContext = createContext(null);
createContext returns a context object. Components can read context by passing it to useContext():
function Button() {
 const theme = useContext(ThemeContext);
 // ...
}

function Profile() {
 const currentUser = useContext(AuthContext);
 // ...
}
By default, the values they receive will be the default values you have specified when creating the contexts. However, by itself this isn’t useful because the default values never change.
Context is useful because you can provide other, dynamic values from your components:
function App() {
 const [theme, setTheme] = useState('dark');
 const [currentUser, setCurrentUser] = useState({ name: 'Taylor' });

 // ...

 return (
   <ThemeContext value={theme}>
     <AuthContext value={currentUser}>
       <Page />
     </AuthContext>
   </ThemeContext>
 );
}
Now the Page component and any components inside it, no matter how deep, will “see” the passed context values. If the passed context values change, React will re-render the components reading the context as well.
Read more about reading and providing context and see examples.

Importing and exporting context from a file 
Often, components in different files will need access to the same context. This is why it’s common to declare contexts in a separate file. Then you can use the export statement to make context available for other files:
// Contexts.js
import { createContext } from 'react';

export const ThemeContext = createContext('light');
export const AuthContext = createContext(null);
Components declared in other files can then use the import statement to read or provide this context:
// Button.js
import { ThemeContext } from './Contexts.js';

function Button() {
 const theme = useContext(ThemeContext);
 // ...
}
// App.js
import { ThemeContext, AuthContext } from './Contexts.js';

function App() {
 // ...
 return (
   <ThemeContext value={theme}>
     <AuthContext value={currentUser}>
       <Page />
     </AuthContext>
   </ThemeContext>
 );
}
This works similar to importing and exporting components.

Troubleshooting 
I can’t find a way to change the context value 
Code like this specifies the default context value:
const ThemeContext = createContext('light');
This value never changes. React only uses this value as a fallback if it can’t find a matching provider above.
To make context change over time, add state and wrap components in a context provider.
lazy
lazy lets you defer loading component’s code until it is rendered for the first time.
const SomeComponent = lazy(load)
Reference
lazy(load)
load function
Usage
Lazy-loading components with Suspense
Troubleshooting
My lazy component’s state gets reset unexpectedly

Reference 
lazy(load) 
Call lazy outside your components to declare a lazy-loaded React component:
import { lazy } from 'react';

const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));
See more examples below.
Parameters 
load: A function that returns a Promise or another thenable (a Promise-like object with a then method). React will not call load until the first time you attempt to render the returned component. After React first calls load, it will wait for it to resolve, and then render the resolved value’s .default as a React component. Both the returned Promise and the Promise’s resolved value will be cached, so React will not call load more than once. If the Promise rejects, React will throw the rejection reason for the nearest Error Boundary to handle.
Returns 
lazy returns a React component you can render in your tree. While the code for the lazy component is still loading, attempting to render it will suspend. Use <Suspense> to display a loading indicator while it’s loading.

load function 
Parameters 
load receives no parameters.
Returns 
You need to return a Promise or some other thenable (a Promise-like object with a then method). It needs to eventually resolve to an object whose .default property is a valid React component type, such as a function, memo, or a forwardRef component.

Usage 
Lazy-loading components with Suspense 
Usually, you import components with the static import declaration:
import MarkdownPreview from './MarkdownPreview.js';
To defer loading this component’s code until it’s rendered for the first time, replace this import with:
import { lazy } from 'react';

const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));
This code relies on dynamic import(), which might require support from your bundler or framework. Using this pattern requires that the lazy component you’re importing was exported as the default export.
Now that your component’s code loads on demand, you also need to specify what should be displayed while it is loading. You can do this by wrapping the lazy component or any of its parents into a <Suspense> boundary:
<Suspense fallback={<Loading />}>
 <h2>Preview</h2>
 <MarkdownPreview />
</Suspense>
In this example, the code for MarkdownPreview won’t be loaded until you attempt to render it. If MarkdownPreview hasn’t loaded yet, Loading will be shown in its place. Try ticking the checkbox:
App.jsLoading.jsMarkdownPreview.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
import { useState, Suspense, lazy } from 'react';
import Loading from './Loading.js';

const MarkdownPreview = lazy(() => delayForDemo(import('./MarkdownPreview.js')));

export default function MarkdownEditor() {
 const [showPreview, setShowPreview] = useState(false);
 const [markdown, setMarkdown] = useState('Hello, **world**!');
 return (
   <>
     <textarea value={markdown} onChange={e => setMarkdown(e.target.value)} />
     <label>
       <input type="checkbox" checked={showPreview} onChange={e => setShowPreview(e.target.checked)} />
       Show preview
     </label>
     <hr />
     {showPreview && (
       <Suspense fallback={<Loading />}>
         <h2>Preview</h2>
         <MarkdownPreview markdown={markdown} />
       </Suspense>
     )}
   </>
 );
}

// Add a fixed delay so you can see the loading state
function delayForDemo(promise) {
 return new Promise(resolve => {
   setTimeout(resolve, 2000);
 }).then(() => promise);
}

Show more
This demo loads with an artificial delay. The next time you untick and tick the checkbox, Preview will be cached, so there will be no loading state. To see the loading state again, click “Reset” on the sandbox.
Learn more about managing loading states with Suspense.

Troubleshooting 
My lazy component’s state gets reset unexpectedly 
Do not declare lazy components inside other components:
import { lazy } from 'react';

function Editor() {
 // 🔴 Bad: This will cause all state to be reset on re-renders
 const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));
 // ...
}
Instead, always declare them at the top level of your module:
import { lazy } from 'react';

// ✅ Good: Declare lazy components outside of your components
const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));

function Editor() {
 // ...
}


memo
memo lets you skip re-rendering a component when its props are unchanged.
const MemoizedComponent = memo(SomeComponent, arePropsEqual?)
Reference
memo(Component, arePropsEqual?)
Usage
Skipping re-rendering when props are unchanged
Updating a memoized component using state
Updating a memoized component using a context
Minimizing props changes
Specifying a custom comparison function
Troubleshooting
My component re-renders when a prop is an object, array, or function

Reference 
memo(Component, arePropsEqual?) 
Wrap a component in memo to get a memoized version of that component. This memoized version of your component will usually not be re-rendered when its parent component is re-rendered as long as its props have not changed. But React may still re-render it: memoization is a performance optimization, not a guarantee.
import { memo } from 'react';

const SomeComponent = memo(function SomeComponent(props) {
 // ...
});
See more examples below.
Parameters 
Component: The component that you want to memoize. The memo does not modify this component, but returns a new, memoized component instead. Any valid React component, including functions and forwardRef components, is accepted.
optional arePropsEqual: A function that accepts two arguments: the component’s previous props, and its new props. It should return true if the old and new props are equal: that is, if the component will render the same output and behave in the same way with the new props as with the old. Otherwise it should return false. Usually, you will not specify this function. By default, React will compare each prop with Object.is.
Returns 
memo returns a new React component. It behaves the same as the component provided to memo except that React will not always re-render it when its parent is being re-rendered unless its props have changed.

Usage 
Skipping re-rendering when props are unchanged 
React normally re-renders a component whenever its parent re-renders. With memo, you can create a component that React will not re-render when its parent re-renders so long as its new props are the same as the old props. Such a component is said to be memoized.
To memoize a component, wrap it in memo and use the value that it returns in place of your original component:
const Greeting = memo(function Greeting({ name }) {
 return <h1>Hello, {name}!</h1>;
});

export default Greeting;
A React component should always have pure rendering logic. This means that it must return the same output if its props, state, and context haven’t changed. By using memo, you are telling React that your component complies with this requirement, so React doesn’t need to re-render as long as its props haven’t changed. Even with memo, your component will re-render if its own state changes or if a context that it’s using changes.
In this example, notice that the Greeting component re-renders whenever name is changed (because that’s one of its props), but not when address is changed (because it’s not passed to Greeting as a prop):
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
import { memo, useState } from 'react';

export default function MyApp() {
 const [name, setName] = useState('');
 const [address, setAddress] = useState('');
 return (
   <>
     <label>
       Name{': '}
       <input value={name} onChange={e => setName(e.target.value)} />
     </label>
     <label>
       Address{': '}
       <input value={address} onChange={e => setAddress(e.target.value)} />
     </label>
     <Greeting name={name} />
   </>
 );
}

const Greeting = memo(function Greeting({ name }) {
 console.log("Greeting was rendered at", new Date().toLocaleTimeString());
 return <h3>Hello{name && ', '}{name}!</h3>;
});

Console (2)
Greeting was rendered at 9:32:47 AM
Greeting was rendered at 9:32:47 AM
Show more
Note
You should only rely on memo as a performance optimization. If your code doesn’t work without it, find the underlying problem and fix it first. Then you may add memo to improve performance.
Deep Dive
Should you add memo everywhere? 
Show Details











Updating a memoized component using state 
Even when a component is memoized, it will still re-render when its own state changes. Memoization only has to do with props that are passed to the component from its parent.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
import { memo, useState } from 'react';

export default function MyApp() {
 const [name, setName] = useState('');
 const [address, setAddress] = useState('');
 return (
   <>
     <label>
       Name{': '}
       <input value={name} onChange={e => setName(e.target.value)} />
     </label>
     <label>
       Address{': '}
       <input value={address} onChange={e => setAddress(e.target.value)} />
     </label>
     <Greeting name={name} />
   </>
 );
}

const Greeting = memo(function Greeting({ name }) {
 console.log('Greeting was rendered at', new Date().toLocaleTimeString());
 const [greeting, setGreeting] = useState('Hello');
 return (
   <>
     <h3>{greeting}{name && ', '}{name}!</h3>
     <GreetingSelector value={greeting} onChange={setGreeting} />
   </>
 );
});

function GreetingSelector({ value, onChange }) {
 return (
   <>
     <label>
       <input
Console (2)
Greeting was rendered at 9:32:47 AM
Greeting was rendered at 9:32:47 AM
Show more
If you set a state variable to its current value, React will skip re-rendering your component even without memo. You may still see your component function being called an extra time, but the result will be discarded.

Updating a memoized component using a context 
Even when a component is memoized, it will still re-render when a context that it’s using changes. Memoization only has to do with props that are passed to the component from its parent.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
import { createContext, memo, useContext, useState } from 'react';

const ThemeContext = createContext(null);

export default function MyApp() {
 const [theme, setTheme] = useState('dark');

 function handleClick() {
   setTheme(theme === 'dark' ? 'light' : 'dark');
 }

 return (
   <ThemeContext value={theme}>
     <button onClick={handleClick}>
       Switch theme
     </button>
     <Greeting name="Taylor" />
   </ThemeContext>
 );
}

const Greeting = memo(function Greeting({ name }) {
 console.log("Greeting was rendered at", new Date().toLocaleTimeString());
 const theme = useContext(ThemeContext);
 return (
   <h3 className={theme}>Hello, {name}!</h3>
 );
});

Show more
To make your component re-render only when a part of some context changes, split your component in two. Read what you need from the context in the outer component, and pass it down to a memoized child as a prop.

Minimizing props changes 
When you use memo, your component re-renders whenever any prop is not shallowly equal to what it was previously. This means that React compares every prop in your component with its previous value using the Object.is comparison. Note that Object.is(3, 3) is true, but Object.is({}, {}) is false.
To get the most out of memo, minimize the times that the props change. For example, if the prop is an object, prevent the parent component from re-creating that object every time by using useMemo:
function Page() {
 const [name, setName] = useState('Taylor');
 const [age, setAge] = useState(42);

 const person = useMemo(
   () => ({ name, age }),
   [name, age]
 );

 return <Profile person={person} />;
}

const Profile = memo(function Profile({ person }) {
 // ...
});
A better way to minimize props changes is to make sure the component accepts the minimum necessary information in its props. For example, it could accept individual values instead of a whole object:
function Page() {
 const [name, setName] = useState('Taylor');
 const [age, setAge] = useState(42);
 return <Profile name={name} age={age} />;
}

const Profile = memo(function Profile({ name, age }) {
 // ...
});
Even individual values can sometimes be projected to ones that change less frequently. For example, here a component accepts a boolean indicating the presence of a value rather than the value itself:
function GroupsLanding({ person }) {
 const hasGroups = person.groups !== null;
 return <CallToAction hasGroups={hasGroups} />;
}

const CallToAction = memo(function CallToAction({ hasGroups }) {
 // ...
});
When you need to pass a function to memoized component, either declare it outside your component so that it never changes, or useCallback to cache its definition between re-renders.

Specifying a custom comparison function 
In rare cases it may be infeasible to minimize the props changes of a memoized component. In that case, you can provide a custom comparison function, which React will use to compare the old and new props instead of using shallow equality. This function is passed as a second argument to memo. It should return true only if the new props would result in the same output as the old props; otherwise it should return false.
const Chart = memo(function Chart({ dataPoints }) {
 // ...
}, arePropsEqual);

function arePropsEqual(oldProps, newProps) {
 return (
   oldProps.dataPoints.length === newProps.dataPoints.length &&
   oldProps.dataPoints.every((oldPoint, index) => {
     const newPoint = newProps.dataPoints[index];
     return oldPoint.x === newPoint.x && oldPoint.y === newPoint.y;
   })
 );
}
If you do this, use the Performance panel in your browser developer tools to make sure that your comparison function is actually faster than re-rendering the component. You might be surprised.
When you do performance measurements, make sure that React is running in the production mode.
Pitfall
If you provide a custom arePropsEqual implementation, you must compare every prop, including functions. Functions often close over the props and state of parent components. If you return true when oldProps.onClick !== newProps.onClick, your component will keep “seeing” the props and state from a previous render inside its onClick handler, leading to very confusing bugs.
Avoid doing deep equality checks inside arePropsEqual unless you are 100% sure that the data structure you’re working with has a known limited depth. Deep equality checks can become incredibly slow and can freeze your app for many seconds if someone changes the data structure later.

Troubleshooting 
My component re-renders when a prop is an object, array, or function 
React compares old and new props by shallow equality: that is, it considers whether each new prop is reference-equal to the old prop. If you create a new object or array each time the parent is re-rendered, even if the individual elements are each the same, React will still consider it to be changed. Similarly, if you create a new function when rendering the parent component, React will consider it to have changed even if the function has the same definition. To avoid this, simplify props or memoize props in the parent component.
startTransition
startTransition lets you render a part of the UI in the background.
startTransition(action)
Reference
startTransition(action)
Usage
Marking a state update as a non-blocking Transition

Reference 
startTransition(action) 
The startTransition function lets you mark a state update as a Transition.
import { startTransition } from 'react';

function TabContainer() {
 const [tab, setTab] = useState('about');

 function selectTab(nextTab) {
   startTransition(() => {
     setTab(nextTab);
   });
 }
 // ...
}
See more examples below.
Parameters 
action: A function that updates some state by calling one or more set functions. React calls action immediately with no parameters and marks all state updates scheduled synchronously during the action function call as Transitions. Any async calls awaited in the action will be included in the transition, but currently require wrapping any set functions after the await in an additional startTransition (see Troubleshooting). State updates marked as Transitions will be non-blocking and will not display unwanted loading indicators..
Returns 
startTransition does not return anything.
Caveats 
startTransition does not provide a way to track whether a Transition is pending. To show a pending indicator while the Transition is ongoing, you need useTransition instead.
You can wrap an update into a Transition only if you have access to the set function of that state. If you want to start a Transition in response to some prop or a custom Hook return value, try useDeferredValue instead.
The function you pass to startTransition is called immediately, marking all state updates that happen while it executes as Transitions. If you try to perform state updates in a setTimeout, for example, they won’t be marked as Transitions.
You must wrap any state updates after any async requests in another startTransition to mark them as Transitions. This is a known limitation that we will fix in the future (see Troubleshooting).
A state update marked as a Transition will be interrupted by other state updates. For example, if you update a chart component inside a Transition, but then start typing into an input while the chart is in the middle of a re-render, React will restart the rendering work on the chart component after handling the input state update.
Transition updates can’t be used to control text inputs.
If there are multiple ongoing Transitions, React currently batches them together. This is a limitation that may be removed in a future release.

Usage 
Marking a state update as a non-blocking Transition 
You can mark a state update as a Transition by wrapping it in a startTransition call:
import { startTransition } from 'react';

function TabContainer() {
 const [tab, setTab] = useState('about');

 function selectTab(nextTab) {
   startTransition(() => {
     setTab(nextTab);
   });
 }
 // ...
}
Transitions let you keep the user interface updates responsive even on slow devices.
With a Transition, your UI stays responsive in the middle of a re-render. For example, if the user clicks a tab but then change their mind and click another tab, they can do that without waiting for the first re-render to finish.
Note
startTransition is very similar to useTransition, except that it does not provide the isPending flag to track whether a Transition is ongoing. You can call startTransition when useTransition is not available. For example, startTransition works outside components, such as from a data library.
Learn about Transitions and see examples on the useTransition page.
use
use is a React API that lets you read the value of a resource like a Promise or context.
const value = use(resource);
Reference
use(resource)
Usage
Reading context with use
Streaming data from the server to the client
Dealing with rejected Promises
Troubleshooting
“Suspense Exception: This is not a real error!”

Reference 
use(resource) 
Call use in your component to read the value of a resource like a Promise or context.
import { use } from 'react';

function MessageComponent({ messagePromise }) {
 const message = use(messagePromise);
 const theme = use(ThemeContext);
 // ...
Unlike React Hooks, use can be called within loops and conditional statements like if. Like React Hooks, the function that calls use must be a Component or Hook.
When called with a Promise, the use API integrates with Suspense and error boundaries. The component calling use suspends while the Promise passed to use is pending. If the component that calls use is wrapped in a Suspense boundary, the fallback will be displayed.  Once the Promise is resolved, the Suspense fallback is replaced by the rendered components using the data returned by the use API. If the Promise passed to use is rejected, the fallback of the nearest Error Boundary will be displayed.
See more examples below.
Parameters 
resource: this is the source of the data you want to read a value from. A resource can be a Promise or a context.
Returns 
The use API returns the value that was read from the resource like the resolved value of a Promise or context.
Caveats 
The use API must be called inside a Component or a Hook.
When fetching data in a Server Component, prefer async and await over use. async and await pick up rendering from the point where await was invoked, whereas use re-renders the component after the data is resolved.
Prefer creating Promises in Server Components and passing them to Client Components over creating Promises in Client Components. Promises created in Client Components are recreated on every render. Promises passed from a Server Component to a Client Component are stable across re-renders. See this example.

Usage 
Reading context with use 
When a context is passed to use, it works similarly to useContext. While useContext must be called at the top level of your component, use can be called inside conditionals like if and loops like for. use is preferred over useContext because it is more flexible.
import { use } from 'react';

function Button() {
 const theme = use(ThemeContext);
 // ...
use returns the context value for the context you passed. To determine the context value, React searches the component tree and finds the closest context provider above for that particular context.
To pass context to a Button, wrap it or one of its parent components into the corresponding context provider.
function MyPage() {
 return (
   <ThemeContext value="dark">
     <Form />
   </ThemeContext>
 );
}

function Form() {
 // ... renders buttons inside ...
}
It doesn’t matter how many layers of components there are between the provider and the Button. When a Button anywhere inside of Form calls use(ThemeContext), it will receive "dark" as the value.
Unlike useContext, use can be called in conditionals and loops like if.
function HorizontalRule({ show }) {
 if (show) {
   const theme = use(ThemeContext);
   return <hr className={theme} />;
 }
 return false;
}
use is called from inside a if statement, allowing you to conditionally read values from a Context.
Pitfall
Like useContext, use(context) always looks for the closest context provider above the component that calls it. It searches upwards and does not consider context providers in the component from which you’re calling use(context).
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
import { createContext, use } from 'react';

const ThemeContext = createContext(null);

export default function MyApp() {
 return (
   <ThemeContext value="dark">
     <Form />
   </ThemeContext>
 )
}

function Form() {
 return (
   <Panel title="Welcome">
     <Button show={true}>Sign up</Button>
     <Button show={false}>Log in</Button>
   </Panel>
 );
}

function Panel({ title, children }) {
 const theme = use(ThemeContext);
 const className = 'panel-' + theme;
 return (
   <section className={className}>
     <h1>{title}</h1>
     {children}
   </section>
 )
}

function Button({ show, children }) {
 if (show) {
   const theme = use(ThemeContext);
   const className = 'button-' + theme;
Show more
Streaming data from the server to the client 
Data can be streamed from the server to the client by passing a Promise as a prop from a Server Component to a Client Component.
import { fetchMessage } from './lib.js';
import { Message } from './message.js';

export default function App() {
 const messagePromise = fetchMessage();
 return (
   <Suspense fallback={<p>waiting for message...</p>}>
     <Message messagePromise={messagePromise} />
   </Suspense>
 );
}
The Client Component then takes the Promise it received as a prop and passes it to the use API. This allows the Client Component to read the value from the Promise that was initially created by the Server Component.
// message.js
'use client';

import { use } from 'react';

export function Message({ messagePromise }) {
 const messageContent = use(messagePromise);
 return <p>Here is the message: {messageContent}</p>;
}
Because Message is wrapped in Suspense, the fallback will be displayed until the Promise is resolved. When the Promise is resolved, the value will be read by the use API and the Message component will replace the Suspense fallback.
message.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
"use client";

import { use, Suspense } from "react";

function Message({ messagePromise }) {
 const messageContent = use(messagePromise);
 return <p>Here is the message: {messageContent}</p>;
}

export function MessageContainer({ messagePromise }) {
 return (
   <Suspense fallback={<p>⌛Downloading message...</p>}>
     <Message messagePromise={messagePromise} />
   </Suspense>
 );
}

Show more
Note
When passing a Promise from a Server Component to a Client Component, its resolved value must be serializable to pass between server and client. Data types like functions aren’t serializable and cannot be the resolved value of such a Promise.
Deep Dive
Should I resolve a Promise in a Server or Client Component? 
Hide Details
A Promise can be passed from a Server Component to a Client Component and resolved in the Client Component with the use API. You can also resolve the Promise in a Server Component with await and pass the required data to the Client Component as a prop.
export default async function App() {
 const messageContent = await fetchMessage();
 return <Message messageContent={messageContent} />
}
But using await in a Server Component will block its rendering until the await statement is finished. Passing a Promise from a Server Component to a Client Component prevents the Promise from blocking the rendering of the Server Component.
Dealing with rejected Promises 
In some cases a Promise passed to use could be rejected. You can handle rejected Promises by either:
Displaying an error to users with an error boundary.
Providing an alternative value with Promise.catch
Pitfall
use cannot be called in a try-catch block. Instead of a try-catch block wrap your component in an Error Boundary, or provide an alternative value to use with the Promise’s .catch method.
Displaying an error to users with an error boundary 
If you’d like to display an error to your users when a Promise is rejected, you can use an error boundary. To use an error boundary, wrap the component where you are calling the use API in an error boundary. If the Promise passed to use is rejected the fallback for the error boundary will be displayed.
message.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
"use client";

import { use, Suspense } from "react";
import { ErrorBoundary } from "react-error-boundary";

export function MessageContainer({ messagePromise }) {
 return (
   <ErrorBoundary fallback={<p>⚠️Something went wrong</p>}>
     <Suspense fallback={<p>⌛Downloading message...</p>}>
       <Message messagePromise={messagePromise} />
     </Suspense>
   </ErrorBoundary>
 );
}

function Message({ messagePromise }) {
 const content = use(messagePromise);
 return <p>Here is the message: {content}</p>;
}

Show more
Providing an alternative value with Promise.catch 
If you’d like to provide an alternative value when the Promise passed to use is rejected you can use the Promise’s catch method.
import { Message } from './message.js';

export default function App() {
 const messagePromise = new Promise((resolve, reject) => {
   reject();
 }).catch(() => {
   return "no new message found.";
 });

 return (
   <Suspense fallback={<p>waiting for message...</p>}>
     <Message messagePromise={messagePromise} />
   </Suspense>
 );
}
To use the Promise’s catch method, call catch on the Promise object. catch takes a single argument: a function that takes an error message as an argument. Whatever is returned by the function passed to catch will be used as the resolved value of the Promise.

Troubleshooting 
“Suspense Exception: This is not a real error!” 
You are either calling use outside of a React Component or Hook function, or calling use in a try–catch block. If you are calling use inside a try–catch block, wrap your component in an error boundary, or call the Promise’s catch to catch the error and resolve the Promise with another value. See these examples.
If you are calling use outside a React Component or Hook function, move the use call to a React Component or Hook function.
function MessageComponent({messagePromise}) {
 function download() {
   // ❌ the function calling `use` is not a Component or Hook
   const message = use(messagePromise);
   // ...
Instead, call use outside any component closures, where the function that calls use is a Component or Hook.
function MessageComponent({messagePromise}) {
 // ✅ `use` is being called from a component.
 const message = use(messagePromise);
 // ...

experimental_taintObjectReference
Experimental Feature
This API is experimental and is not available in a stable version of React yet.
You can try it by upgrading React packages to the most recent experimental version:
react@experimental
react-dom@experimental
eslint-plugin-react-hooks@experimental
Experimental versions of React may contain bugs. Don’t use them in production.
This API is only available inside React Server Components.
taintObjectReference lets you prevent a specific object instance from being passed to a Client Component like a user object.
experimental_taintObjectReference(message, object);
To prevent passing a key, hash or token, see taintUniqueValue.
Reference
taintObjectReference(message, object)
Usage
Prevent user data from unintentionally reaching the client

Reference 
taintObjectReference(message, object) 
Call taintObjectReference with an object to register it with React as something that should not be allowed to be passed to the Client as is:
import {experimental_taintObjectReference} from 'react';

experimental_taintObjectReference(
 'Do not pass ALL environment variables to the client.',
 process.env
);
See more examples below.
Parameters 
message: The message you want to display if the object gets passed to a Client Component. This message will be displayed as a part of the Error that will be thrown if the object gets passed to a Client Component.
object: The object to be tainted. Functions and class instances can be passed to taintObjectReference as object. Functions and classes are already blocked from being passed to Client Components but the React’s default error message will be replaced by what you defined in message. When a specific instance of a Typed Array is passed to taintObjectReference as object, any other copies of the Typed Array will not be tainted.
Returns 
experimental_taintObjectReference returns undefined.
Caveats 
Recreating or cloning a tainted object creates a new untainted object which may contain sensitive data. For example, if you have a tainted user object, const userInfo = {name: user.name, ssn: user.ssn} or {...user} will create new objects which are not tainted. taintObjectReference only protects against simple mistakes when the object is passed through to a Client Component unchanged.
Pitfall
Do not rely on just tainting for security. Tainting an object doesn’t prevent leaking of every possible derived value. For example, the clone of a tainted object will create a new untainted object. Using data from a tainted object (e.g. {secret: taintedObj.secret}) will create a new value or object that is not tainted. Tainting is a layer of protection; a secure app will have multiple layers of protection, well designed APIs, and isolation patterns.

Usage 
Prevent user data from unintentionally reaching the client 
A Client Component should never accept objects that carry sensitive data. Ideally, the data fetching functions should not expose data that the current user should not have access to. Sometimes mistakes happen during refactoring. To protect against these mistakes happening down the line we can “taint” the user object in our data API.
import {experimental_taintObjectReference} from 'react';

export async function getUser(id) {
 const user = await db`SELECT * FROM users WHERE id = ${id}`;
 experimental_taintObjectReference(
   'Do not pass the entire user object to the client. ' +
     'Instead, pick off the specific properties you need for this use case.',
   user,
 );
 return user;
}
Now whenever anyone tries to pass this object to a Client Component, an error will be thrown with the passed in error message instead.
Deep Dive
Protecting against leaks in data fetching 
Hide Details
If you’re running a Server Components environment that has access to sensitive data, you have to be careful not to pass objects straight through:
// api.js
export async function getUser(id) {
 const user = await db`SELECT * FROM users WHERE id = ${id}`;
 return user;
}
import { getUser } from 'api.js';
import { InfoCard } from 'components.js';

export async function Profile(props) {
 const user = await getUser(props.userId);
 // DO NOT DO THIS
 return <InfoCard user={user} />;
}
// components.js
"use client";

export async function InfoCard({ user }) {
 return <div>{user.name}</div>;
}
Ideally, the getUser should not expose data that the current user should not have access to. To prevent passing the user object to a Client Component down the line we can “taint” the user object:
// api.js
import {experimental_taintObjectReference} from 'react';

export async function getUser(id) {
 const user = await db`SELECT * FROM users WHERE id = ${id}`;
 experimental_taintObjectReference(
   'Do not pass the entire user object to the client. ' +
     'Instead, pick off the specific properties you need for this use case.',
   user,
 );
 return user;
}
Now if anyone tries to pass the user object to a Client Component, an error will be thrown with the passed in error message.
experimental_taintUniqueValue
Experimental Feature
This API is experimental and is not available in a stable version of React yet.
You can try it by upgrading React packages to the most recent experimental version:
react@experimental
react-dom@experimental
eslint-plugin-react-hooks@experimental
Experimental versions of React may contain bugs. Don’t use them in production.
This API is only available inside React Server Components.
taintUniqueValue lets you prevent unique values from being passed to Client Components like passwords, keys, or tokens.
taintUniqueValue(errMessage, lifetime, value)
To prevent passing an object containing sensitive data, see taintObjectReference.
Reference
taintUniqueValue(message, lifetime, value)
Usage
Prevent a token from being passed to Client Components

Reference 
taintUniqueValue(message, lifetime, value) 
Call taintUniqueValue with a password, token, key or hash to register it with React as something that should not be allowed to be passed to the Client as is:
import {experimental_taintUniqueValue} from 'react';

experimental_taintUniqueValue(
 'Do not pass secret keys to the client.',
 process,
 process.env.SECRET_KEY
);
See more examples below.
Parameters 
message: The message you want to display if value is passed to a Client Component. This message will be displayed as a part of the Error that will be thrown if value is passed to a Client Component.
lifetime: Any object that indicates how long value should be tainted. value will be blocked from being sent to any Client Component while this object still exists. For example, passing globalThis blocks the value for the lifetime of an app. lifetime is typically an object whose properties contains value.
value: A string, bigint or TypedArray. value must be a unique sequence of characters or bytes with high entropy such as a cryptographic token, private key, hash, or a long password. value will be blocked from being sent to any Client Component.
Returns 
experimental_taintUniqueValue returns undefined.
Caveats 
Deriving new values from tainted values can compromise tainting protection. New values created by uppercasing tainted values, concatenating tainted string values into a larger string, converting tainted values to base64, substringing tainted values, and other similar transformations are not tainted unless you explicitly call taintUniqueValue on these newly created values.
Do not use taintUniqueValue to protect low-entropy values such as PIN codes or phone numbers. If any value in a request is controlled by an attacker, they could infer which value is tainted by enumerating all possible values of the secret.

Usage 
Prevent a token from being passed to Client Components 
To ensure that sensitive information such as passwords, session tokens, or other unique values do not inadvertently get passed to Client Components, the taintUniqueValue function provides a layer of protection. When a value is tainted, any attempt to pass it to a Client Component will result in an error.
The lifetime argument defines the duration for which the value remains tainted. For values that should remain tainted indefinitely, objects like globalThis or process can serve as the lifetime argument. These objects have a lifespan that spans the entire duration of your app’s execution.
import {experimental_taintUniqueValue} from 'react';

experimental_taintUniqueValue(
 'Do not pass a user password to the client.',
 globalThis,
 process.env.SECRET_KEY
);
If the tainted value’s lifespan is tied to a object, the lifetime should be the object that encapsulates the value. This ensures the tainted value remains protected for the lifetime of the encapsulating object.
import {experimental_taintUniqueValue} from 'react';

export async function getUser(id) {
 const user = await db`SELECT * FROM users WHERE id = ${id}`;
 experimental_taintUniqueValue(
   'Do not pass a user session token to the client.',
   user,
   user.session.token
 );
 return user;
}
In this example, the user object serves as the lifetime argument. If this object gets stored in a global cache or is accessible by another request, the session token remains tainted.
Pitfall
Do not rely solely on tainting for security. Tainting a value doesn’t block every possible derived value. For example, creating a new value by upper casing a tainted string will not taint the new value.
import {experimental_taintUniqueValue} from 'react';

const password = 'correct horse battery staple';

experimental_taintUniqueValue(
 'Do not pass the password to the client.',
 globalThis,
 password
);

const uppercasePassword = password.toUpperCase() // `uppercasePassword` is not tainted
In this example, the constant password is tainted. Then password is used to create a new value uppercasePassword by calling the toUpperCase method on password. The newly created uppercasePassword is not tainted.
Other similar ways of deriving new values from tainted values like concatenating it into a larger string, converting it to base64, or returning a substring create untained values.
Tainting only protects against simple mistakes like explicitly passing secret values to the client. Mistakes in calling the taintUniqueValue like using a global store outside of React, without the corresponding lifetime object, can cause the tainted value to become untainted. Tainting is a layer of protection; a secure app will have multiple layers of protection, well designed APIs, and isolation patterns.
Deep Dive
Using server-only and taintUniqueValue to prevent leaking secrets 
Hide Details
If you’re running a Server Components environment that has access to private keys or passwords such as database passwords, you have to be careful not to pass that to a Client Component.
export async function Dashboard(props) {
 // DO NOT DO THIS
 return <Overview password={process.env.API_PASSWORD} />;
}
"use client";

import {useEffect} from '...'

export async function Overview({ password }) {
 useEffect(() => {
   const headers = { Authorization: password };
   fetch(url, { headers }).then(...);
 }, [password]);
 ...
}
This example would leak the secret API token to the client. If this API token can be used to access data this particular user shouldn’t have access to, it could lead to a data breach.
Ideally, secrets like this are abstracted into a single helper file that can only be imported by trusted data utilities on the server. The helper can even be tagged with server-only to ensure that this file isn’t imported on the client.
import "server-only";

export function fetchAPI(url) {
 const headers = { Authorization: process.env.API_PASSWORD };
 return fetch(url, { headers });
}
Sometimes mistakes happen during refactoring and not all of your colleagues might know about this.
To protect against this mistakes happening down the line we can “taint” the actual password:
import "server-only";
import {experimental_taintUniqueValue} from 'react';

experimental_taintUniqueValue(
 'Do not pass the API token password to the client. ' +
   'Instead do all fetches on the server.'
 process,
 process.env.API_PASSWORD
);
Now whenever anyone tries to pass this password to a Client Component, or send the password to a Client Component with a Server Function, an error will be thrown with message you defined when you called taintUniqueValue.

unstable_addTransitionType
Experimental Feature
This API is experimental and is not available in a stable version of React yet.
You can try it by upgrading React packages to the most recent experimental version:
react@experimental
react-dom@experimental
eslint-plugin-react-hooks@experimental
Experimental versions of React may contain bugs. Don’t use them in production.
unstable_addTransitionType lets you specify the cause of a transition.
startTransition(() => {
 unstable_addTransitionType('my-transition-type');
 setState(newState);
});
Reference
addTransitionType
Usage
Adding the cause of a transition
Customize animations using browser view transition types
Customize animations using View Transition Class
Customize animations using ViewTransition events
Troubleshooting
TODO

Reference 
addTransitionType 
Parameters 
type: The type of transition to add. This can be any string.
Returns 
startTransition does not return anything.
Caveats 
If multiple transitions are combined, all Transition Types are collected. You can also add more than one type to a Transition.
Transition Types are reset after each commit. This means a <Suspense> fallback will associate the types after a startTransition, but revealing the content does not.

Usage 
Adding the cause of a transition 
Call addTransitionType inside of startTransition to indicate the cause of a transition:
import { startTransition, unstable_addTransitionType } from 'react';

function Submit({action) {
 function handleClick() {
   startTransition(() => {
     unstable_addTransitionType('submit-click');
     action();
   });
 }

 return <button onClick={handleClick}>Click me</button>;
}
When you call addTransitionType inside the scope of startTransition, React will associate submit-click as one of the causes for the Transition.
Currently, Transition Types can be used to customize different animations based on what caused the Transition. You have three different ways to choose from for how to use them:
Customize animations using browser view transition types
Customize animations using View Transition Class
Customize animations using ViewTransition events
In the future, we plan to support more use cases for using the cause of a transition.

Customize animations using browser view transition types 
When a ViewTransition activates from a transition, React adds all the Transition Types as browser view transition types to the element.
This allows you to customize different animations based on CSS scopes:
function Component() {
 return (
   <ViewTransition>
     <div>Hello</div>
   </ViewTransition>
 );
}

startTransition(() => {
 unstable_addTransitionType('my-transition-type');
 setShow(true);
});
:root:active-view-transition-type(my-transition-type) {
 &::view-transition-...(...) {
   ...
 }
}

Customize animations using View Transition Class 
You can customize animations for an activated ViewTransition based on type by passing an object to the View Transition Class:
function Component() {
 return (
   <ViewTransition enter={{
     'my-transition-type': 'my-transition-class',
   }}>
     <div>Hello</div>
   </ViewTransition>
 );
}

// ...
startTransition(() => {
 unstable_addTransitionType('my-transition-type');
 setState(newState);
});
If multiple types match, then they’re joined together. If no types match then the special “default” entry is used instead. If any type has the value “none” then that wins and the ViewTransition is disabled (not assigned a name).
These can be combined with enter/exit/update/layout/share props to match based on kind of trigger and Transition Type.
<ViewTransition enter={{
 'navigation-back': 'enter-right',
 'navigation-forward': 'enter-left',
}}
exit={{
 'navigation-back': 'exit-right',
 'navigation-forward': 'exit-left',
}}>

Customize animations using ViewTransition events 
You can imperatively customize animations for an activated ViewTransition based on type using View Transition events:
<ViewTransition onUpdate={(inst, types) => {
 if (types.includes('navigation-back')) {
   ...
 } else if (types.includes('navigation-forward')) {
   ...
 } else {
   ...
 }
}}>
This allows you to pick different imperative Animations based on the cause.

Troubleshooting 
TODO 

Built-in React DOM Hooks
The react-dom package contains Hooks that are only supported for web applications (which run in the browser DOM environment). These Hooks are not supported in non-browser environments like iOS, Android, or Windows applications. If you are looking for Hooks that are supported in web browsers and other environments see the React Hooks page. This page lists all the Hooks in the react-dom package.

Form Hooks 
Forms let you create interactive controls for submitting information.  To manage forms in your components, use one of these Hooks:
useFormStatus allows you to make updates to the UI based on the status of a form.
function Form({ action }) {
 async function increment(n) {
   return n + 1;
 }
 const [count, incrementFormAction] = useActionState(increment, 0);
 return (
   <form action={action}>
     <button formAction={incrementFormAction}>Count: {count}</button>
     <Button />
   </form>
 );
}

function Button() {
 const { pending } = useFormStatus();
 return (
   <button disabled={pending} type="submit">
     Submit
   </button>
 );
}
useFormStatus
useFormStatus is a Hook that gives you status information of the last form submission.
const { pending, data, method, action } = useFormStatus();
Reference
useFormStatus()
Usage
Display a pending state during form submission
Read the form data being submitted
Troubleshooting
status.pending is never true

Reference 
useFormStatus() 
The useFormStatus Hook provides status information of the last form submission.
import { useFormStatus } from "react-dom";
import action from './actions';

function Submit() {
 const status = useFormStatus();
 return <button disabled={status.pending}>Submit</button>
}

export default function App() {
 return (
   <form action={action}>
     <Submit />
   </form>
 );
}
To get status information, the Submit component must be rendered within a <form>. The Hook returns information like the pending property which tells you if the form is actively submitting.
In the above example, Submit uses this information to disable <button> presses while the form is submitting.
See more examples below.
Parameters 
useFormStatus does not take any parameters.
Returns 
A status object with the following properties:
pending: A boolean. If true, this means the parent <form> is pending submission. Otherwise, false.
data: An object implementing the FormData interface that contains the data the parent <form> is submitting. If there is no active submission or no parent <form>, it will be null.
method: A string value of either 'get' or 'post'. This represents whether the parent <form> is submitting with either a GET or POST HTTP method. By default, a <form> will use the GET method and can be specified by the method property.
action: A reference to the function passed to the action prop on the parent <form>. If there is no parent <form>, the property is null. If there is a URI value provided to the action prop, or no action prop specified, status.action will be null.
Caveats 
The useFormStatus Hook must be called from a component that is rendered inside a <form>.
useFormStatus will only return status information for a parent <form>. It will not return status information for any <form> rendered in that same component or children components.

Usage 
Display a pending state during form submission 
To display a pending state while a form is submitting, you can call the useFormStatus Hook in a component rendered in a <form> and read the pending property returned.
Here, we use the pending property to indicate the form is submitting.
App.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
import { useFormStatus } from "react-dom";
import { submitForm } from "./actions.js";

function Submit() {
 const { pending } = useFormStatus();
 return (
   <button type="submit" disabled={pending}>
     {pending ? "Submitting..." : "Submit"}
   </button>
 );
}

function Form({ action }) {
 return (
   <form action={action}>
     <Submit />
   </form>
 );
}

export default function App() {
 return <Form action={submitForm} />;
}

Show more
Pitfall
useFormStatus will not return status information for a <form> rendered in the same component. 
The useFormStatus Hook only returns status information for a parent <form> and not for any <form> rendered in the same component calling the Hook, or child components.
function Form() {
 // 🚩 `pending` will never be true
 // useFormStatus does not track the form rendered in this component
 const { pending } = useFormStatus();
 return <form action={submit}></form>;
}
Instead call useFormStatus from inside a component that is located inside <form>.
function Submit() {
 // ✅ `pending` will be derived from the form that wraps the Submit component
 const { pending } = useFormStatus();
 return <button disabled={pending}>...</button>;
}

function Form() {
 // This is the <form> `useFormStatus` tracks
 return (
   <form action={submit}>
     <Submit />
   </form>
 );
}
Read the form data being submitted 
You can use the data property of the status information returned from useFormStatus to display what data is being submitted by the user.
Here, we have a form where users can request a username. We can use useFormStatus to display a temporary status message confirming what username they have requested.
UsernameForm.jsApp.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
import {useState, useMemo, useRef} from 'react';
import {useFormStatus} from 'react-dom';

export default function UsernameForm() {
 const {pending, data} = useFormStatus();

 return (
   <div>
     <h3>Request a Username: </h3>
     <input type="text" name="username" disabled={pending}/>
     <button type="submit" disabled={pending}>
       Submit
     </button>
     <br />
     <p>{data ? `Requesting ${data?.get("username")}...`: ''}</p>
   </div>
 );
}

Show more

Troubleshooting 
status.pending is never true 
useFormStatus will only return status information for a parent <form>.
If the component that calls useFormStatus is not nested in a <form>, status.pending will always return false. Verify useFormStatus is called in a component that is a child of a <form> element.
useFormStatus will not track the status of a <form> rendered in the same component. See Pitfall for more details.
React DOM Components
React supports all of the browser built-in HTML and SVG components.

Common components 
All of the built-in browser components support some props and events.
Common components (e.g. <div>)
This includes React-specific props like ref and dangerouslySetInnerHTML.

Form components 
These built-in browser components accept user input:
<input>
<select>
<textarea>
They are special in React because passing the value prop to them makes them controlled.

Resource and Metadata Components 
These built-in browser components let you load external resources or annotate the document with metadata:
<link>
<meta>
<script>
<style>
<title>
They are special in React because React can render them into the document head, suspend while resources are loading, and enact other behaviors that are described on the reference page for each specific component.

All HTML components 
React supports all built-in browser HTML components. This includes:
<aside>
<audio>
<b>
<base>
<bdi>
<bdo>
<blockquote>
<body>
<br>
<button>
<canvas>
<caption>
<cite>
<code>
<col>
<colgroup>
<data>
<datalist>
<dd>
<del>
<details>
<dfn>
<dialog>
<div>
<dl>
<dt>
<em>
<embed>
<fieldset>
<figcaption>
<figure>
<footer>
<form>
<h1>
<head>
<header>
<hgroup>
<hr>
<html>
<i>
<iframe>
<img>
<input>
<ins>
<kbd>
<label>
<legend>
<li>
<link>
<main>
<map>
<mark>
<menu>
<meta>
<meter>
<nav>
<noscript>
<object>
<ol>
<optgroup>
<option>
<output>
<p>
<picture>
<pre>
<progress>
<q>
<rp>
<rt>
<ruby>
<s>
<samp>
<script>
<section>
<select>
<slot>
<small>
<source>
<span>
<strong>
<style>
<sub>
<summary>
<sup>
<table>
<tbody>
<td>
<template>
<textarea>
<tfoot>
<th>
<thead>
<time>
<title>
<tr>
<track>
<u>
<ul>
<var>
<video>
<wbr>
Note
Similar to the DOM standard, React uses a camelCase convention for prop names. For example, you’ll write tabIndex instead of tabindex. You can convert existing HTML to JSX with an online converter.

Custom HTML elements 
If you render a tag with a dash, like <my-element>, React will assume you want to render a custom HTML element. In React, rendering custom elements works differently from rendering built-in browser tags:
All custom element props are serialized to strings and are always set using attributes.
Custom elements accept class rather than className, and for rather than htmlFor.
If you render a built-in browser HTML element with an is attribute, it will also be treated as a custom element.
Note
A future version of React will include more comprehensive support for custom elements.
You can try it by upgrading React packages to the most recent experimental version:
react@experimental
react-dom@experimental
Experimental versions of React may contain bugs. Don’t use them in production.

All SVG components 
React supports all built-in browser SVG components. This includes:
<a>
<animate>
<animateMotion>
<animateTransform>
<circle>
<clipPath>
<defs>
<desc>
<discard>
<ellipse>
<feBlend>
<feColorMatrix>
<feComponentTransfer>
<feComposite>
<feConvolveMatrix>
<feDiffuseLighting>
<feDisplacementMap>
<feDistantLight>
<feDropShadow>
<feFlood>
<feFuncA>
<feFuncB>
<feFuncG>
<feFuncR>
<feGaussianBlur>
<feImage>
<feMerge>
<feMergeNode>
<feMorphology>
<feOffset>
<fePointLight>
<feSpecularLighting>
<feSpotLight>
<feTile>
<feTurbulence>
<filter>
<foreignObject>
<g>
<hatch>
<hatchpath>
<image>
<line>
<linearGradient>
<marker>
<mask>
<metadata>
<mpath>
<path>
<pattern>
<polygon>
<polyline>
<radialGradient>
<rect>
<script>
<set>
<stop>
<style>
<svg>
<switch>
<symbol>
<text>
<textPath>
<title>
<tspan>
<use>
<view>
Note
Similar to the DOM standard, React uses a camelCase convention for prop names. For example, you’ll write tabIndex instead of tabindex. You can convert existing SVG to JSX with an online converter.
Namespaced attributes also have to be written without the colon:
xlink:actuate becomes xlinkActuate.
xlink:arcrole becomes xlinkArcrole.
xlink:href becomes xlinkHref.
xlink:role becomes xlinkRole.
xlink:show becomes xlinkShow.
xlink:title becomes xlinkTitle.
xlink:type becomes xlinkType.
xml:base becomes xmlBase.
xml:lang becomes xmlLang.
xml:space becomes xmlSpace.
xmlns:xlink becomes xmlnsXlink.
PrevioususeFormStatus

Common components (e.g. <div>)
All built-in browser components, such as <div>, support some common props and events.
Reference
Common components (e.g. <div>)
ref callback function
React event object
AnimationEvent handler function
ClipboardEvent handler function
CompositionEvent handler function
DragEvent handler function
FocusEvent handler function
Event handler function
InputEvent handler function
KeyboardEvent handler function
MouseEvent handler function
PointerEvent handler function
TouchEvent handler function
TransitionEvent handler function
UIEvent handler function
WheelEvent handler function
Usage
Applying CSS styles
Manipulating a DOM node with a ref
Dangerously setting the inner HTML
Handling mouse events
Handling pointer events
Handling focus events
Handling keyboard events

Reference 
Common components (e.g. <div>) 
<div className="wrapper">Some content</div>
See more examples below.
Props 
These special React props are supported for all built-in components:
children: A React node (an element, a string, a number, a portal, an empty node like null, undefined and booleans, or an array of other React nodes). Specifies the content inside the component. When you use JSX, you will usually specify the children prop implicitly by nesting tags like <div><span /></div>.
dangerouslySetInnerHTML: An object of the form { __html: '<p>some html</p>' } with a raw HTML string inside. Overrides the innerHTML property of the DOM node and displays the passed HTML inside. This should be used with extreme caution! If the HTML inside isn’t trusted (for example, if it’s based on user data), you risk introducing an XSS vulnerability. Read more about using dangerouslySetInnerHTML.
ref: A ref object from useRef or createRef, or a ref callback function, or a string for legacy refs. Your ref will be filled with the DOM element for this node. Read more about manipulating the DOM with refs.
suppressContentEditableWarning: A boolean. If true, suppresses the warning that React shows for elements that both have children and contentEditable={true} (which normally do not work together). Use this if you’re building a text input library that manages the contentEditable content manually.
suppressHydrationWarning: A boolean. If you use server rendering, normally there is a warning when the server and the client render different content. In some rare cases (like timestamps), it is very hard or impossible to guarantee an exact match. If you set suppressHydrationWarning to true, React will not warn you about mismatches in the attributes and the content of that element. It only works one level deep, and is intended to be used as an escape hatch. Don’t overuse it. Read about suppressing hydration errors.
style: An object with CSS styles, for example { fontWeight: 'bold', margin: 20 }. Similarly to the DOM style property, the CSS property names need to be written as camelCase, for example fontWeight instead of font-weight. You can pass strings or numbers as values. If you pass a number, like width: 100, React will automatically append px (“pixels”) to the value unless it’s a unitless property. We recommend using style only for dynamic styles where you don’t know the style values ahead of time. In other cases, applying plain CSS classes with className is more efficient. Read more about className and style.
These standard DOM props are also supported for all built-in components:
accessKey: A string. Specifies a keyboard shortcut for the element. Not generally recommended.
aria-*: ARIA attributes let you specify the accessibility tree information for this element. See ARIA attributes for a complete reference. In React, all ARIA attribute names are exactly the same as in HTML.
autoCapitalize: A string. Specifies whether and how the user input should be capitalized.
className: A string. Specifies the element’s CSS class name. Read more about applying CSS styles.
contentEditable: A boolean. If true, the browser lets the user edit the rendered element directly. This is used to implement rich text input libraries like Lexical. React warns if you try to pass React children to an element with contentEditable={true} because React will not be able to update its content after user edits.
data-*: Data attributes let you attach some string data to the element, for example data-fruit="banana". In React, they are not commonly used because you would usually read data from props or state instead.
dir: Either 'ltr' or 'rtl'. Specifies the text direction of the element.
draggable: A boolean. Specifies whether the element is draggable. Part of HTML Drag and Drop API.
enterKeyHint: A string. Specifies which action to present for the enter key on virtual keyboards.
htmlFor: A string. For <label> and <output>, lets you associate the label with some control. Same as for HTML attribute. React uses the standard DOM property names (htmlFor) instead of HTML attribute names.
hidden: A boolean or a string. Specifies whether the element should be hidden.
id: A string. Specifies a unique identifier for this element, which can be used to find it later or connect it with other elements. Generate it with useId to avoid clashes between multiple instances of the same component.
is: A string. If specified, the component will behave like a custom element.
inputMode: A string. Specifies what kind of keyboard to display (for example, text, number or telephone).
itemProp: A string. Specifies which property the element represents for structured data crawlers.
lang: A string. Specifies the language of the element.
onAnimationEnd: An AnimationEvent handler function. Fires when a CSS animation completes.
onAnimationEndCapture: A version of onAnimationEnd that fires in the capture phase.
onAnimationIteration: An AnimationEvent handler function. Fires when an iteration of a CSS animation ends, and another one begins.
onAnimationIterationCapture: A version of onAnimationIteration that fires in the capture phase.
onAnimationStart: An AnimationEvent handler function. Fires when a CSS animation starts.
onAnimationStartCapture: onAnimationStart, but fires in the capture phase.
onAuxClick: A MouseEvent handler function. Fires when a non-primary pointer button was clicked.
onAuxClickCapture: A version of onAuxClick that fires in the capture phase.
onBeforeInput: An InputEvent handler function. Fires before the value of an editable element is modified. React does not yet use the native beforeinput event, and instead attempts to polyfill it using other events.
onBeforeInputCapture: A version of onBeforeInput that fires in the capture phase.
onBlur: A FocusEvent handler function. Fires when an element lost focus. Unlike the built-in browser blur event, in React the onBlur event bubbles.
onBlurCapture: A version of onBlur that fires in the capture phase.
onClick: A MouseEvent handler function. Fires when the primary button was clicked on the pointing device.
onClickCapture: A version of onClick that fires in the capture phase.
onCompositionStart: A CompositionEvent handler function. Fires when an input method editor starts a new composition session.
onCompositionStartCapture: A version of onCompositionStart that fires in the capture phase.
onCompositionEnd: A CompositionEvent handler function. Fires when an input method editor completes or cancels a composition session.
onCompositionEndCapture: A version of onCompositionEnd that fires in the capture phase.
onCompositionUpdate: A CompositionEvent handler function. Fires when an input method editor receives a new character.
onCompositionUpdateCapture: A version of onCompositionUpdate that fires in the capture phase.
onContextMenu: A MouseEvent handler function. Fires when the user tries to open a context menu.
onContextMenuCapture: A version of onContextMenu that fires in the capture phase.
onCopy: A ClipboardEvent handler function. Fires when the user tries to copy something into the clipboard.
onCopyCapture: A version of onCopy that fires in the capture phase.
onCut: A ClipboardEvent handler function. Fires when the user tries to cut something into the clipboard.
onCutCapture: A version of onCut that fires in the capture phase.
onDoubleClick: A MouseEvent handler function. Fires when the user clicks twice. Corresponds to the browser dblclick event.
onDoubleClickCapture: A version of onDoubleClick that fires in the capture phase.
onDrag: A DragEvent handler function. Fires while the user is dragging something.
onDragCapture: A version of onDrag that fires in the capture phase.
onDragEnd: A DragEvent handler function. Fires when the user stops dragging something.
onDragEndCapture: A version of onDragEnd that fires in the capture phase.
onDragEnter: A DragEvent handler function. Fires when the dragged content enters a valid drop target.
onDragEnterCapture: A version of onDragEnter that fires in the capture phase.
onDragOver: A DragEvent handler function. Fires on a valid drop target while the dragged content is dragged over it. You must call e.preventDefault() here to allow dropping.
onDragOverCapture: A version of onDragOver that fires in the capture phase.
onDragStart: A DragEvent handler function. Fires when the user starts dragging an element.
onDragStartCapture: A version of onDragStart that fires in the capture phase.
onDrop: A DragEvent handler function. Fires when something is dropped on a valid drop target.
onDropCapture: A version of onDrop that fires in the capture phase.
onFocus: A FocusEvent handler function. Fires when an element receives focus. Unlike the built-in browser focus event, in React the onFocus event bubbles.
onFocusCapture: A version of onFocus that fires in the capture phase.
onGotPointerCapture: A PointerEvent handler function. Fires when an element programmatically captures a pointer.
onGotPointerCaptureCapture: A version of onGotPointerCapture that fires in the capture phase.
onKeyDown: A KeyboardEvent handler function. Fires when a key is pressed.
onKeyDownCapture: A version of onKeyDown that fires in the capture phase.
onKeyPress: A KeyboardEvent handler function. Deprecated. Use onKeyDown or onBeforeInput instead.
onKeyPressCapture: A version of onKeyPress that fires in the capture phase.
onKeyUp: A KeyboardEvent handler function. Fires when a key is released.
onKeyUpCapture: A version of onKeyUp that fires in the capture phase.
onLostPointerCapture: A PointerEvent handler function. Fires when an element stops capturing a pointer.
onLostPointerCaptureCapture: A version of onLostPointerCapture that fires in the capture phase.
onMouseDown: A MouseEvent handler function. Fires when the pointer is pressed down.
onMouseDownCapture: A version of onMouseDown that fires in the capture phase.
onMouseEnter: A MouseEvent handler function. Fires when the pointer moves inside an element. Does not have a capture phase. Instead, onMouseLeave and onMouseEnter propagate from the element being left to the one being entered.
onMouseLeave: A MouseEvent handler function. Fires when the pointer moves outside an element. Does not have a capture phase. Instead, onMouseLeave and onMouseEnter propagate from the element being left to the one being entered.
onMouseMove: A MouseEvent handler function. Fires when the pointer changes coordinates.
onMouseMoveCapture: A version of onMouseMove that fires in the capture phase.
onMouseOut: A MouseEvent handler function. Fires when the pointer moves outside an element, or if it moves into a child element.
onMouseOutCapture: A version of onMouseOut that fires in the capture phase.
onMouseUp: A MouseEvent handler function. Fires when the pointer is released.
onMouseUpCapture: A version of onMouseUp that fires in the capture phase.
onPointerCancel: A PointerEvent handler function. Fires when the browser cancels a pointer interaction.
onPointerCancelCapture: A version of onPointerCancel that fires in the capture phase.
onPointerDown: A PointerEvent handler function. Fires when a pointer becomes active.
onPointerDownCapture: A version of onPointerDown that fires in the capture phase.
onPointerEnter: A PointerEvent handler function. Fires when a pointer moves inside an element. Does not have a capture phase. Instead, onPointerLeave and onPointerEnter propagate from the element being left to the one being entered.
onPointerLeave: A PointerEvent handler function. Fires when a pointer moves outside an element. Does not have a capture phase. Instead, onPointerLeave and onPointerEnter propagate from the element being left to the one being entered.
onPointerMove: A PointerEvent handler function. Fires when a pointer changes coordinates.
onPointerMoveCapture: A version of onPointerMove that fires in the capture phase.
onPointerOut: A PointerEvent handler function. Fires when a pointer moves outside an element, if the pointer interaction is cancelled, and a few other reasons.
onPointerOutCapture: A version of onPointerOut that fires in the capture phase.
onPointerUp: A PointerEvent handler function. Fires when a pointer is no longer active.
onPointerUpCapture: A version of onPointerUp that fires in the capture phase.
onPaste: A ClipboardEvent handler function. Fires when the user tries to paste something from the clipboard.
onPasteCapture: A version of onPaste that fires in the capture phase.
onScroll: An Event handler function. Fires when an element has been scrolled. This event does not bubble.
onScrollCapture: A version of onScroll that fires in the capture phase.
onSelect: An Event handler function. Fires after the selection inside an editable element like an input changes. React extends the onSelect event to work for contentEditable={true} elements as well. In addition, React extends it to fire for empty selection and on edits (which may affect the selection).
onSelectCapture: A version of onSelect that fires in the capture phase.
onTouchCancel: A TouchEvent handler function. Fires when the browser cancels a touch interaction.
onTouchCancelCapture: A version of onTouchCancel that fires in the capture phase.
onTouchEnd: A TouchEvent handler function. Fires when one or more touch points are removed.
onTouchEndCapture: A version of onTouchEnd that fires in the capture phase.
onTouchMove: A TouchEvent handler function. Fires one or more touch points are moved.
onTouchMoveCapture: A version of onTouchMove that fires in the capture phase.
onTouchStart: A TouchEvent handler function. Fires when one or more touch points are placed.
onTouchStartCapture: A version of onTouchStart that fires in the capture phase.
onTransitionEnd: A TransitionEvent handler function. Fires when a CSS transition completes.
onTransitionEndCapture: A version of onTransitionEnd that fires in the capture phase.
onWheel: A WheelEvent handler function. Fires when the user rotates a wheel button.
onWheelCapture: A version of onWheel that fires in the capture phase.
role: A string. Specifies the element role explicitly for assistive technologies.
slot: A string. Specifies the slot name when using shadow DOM. In React, an equivalent pattern is typically achieved by passing JSX as props, for example <Layout left={<Sidebar />} right={<Content />} />.
spellCheck: A boolean or null. If explicitly set to true or false, enables or disables spellchecking.
tabIndex: A number. Overrides the default Tab button behavior. Avoid using values other than -1 and 0.
title: A string. Specifies the tooltip text for the element.
translate: Either 'yes' or 'no'. Passing 'no' excludes the element content from being translated.
You can also pass custom attributes as props, for example mycustomprop="someValue". This can be useful when integrating with third-party libraries. The custom attribute name must be lowercase and must not start with on. The value will be converted to a string. If you pass null or undefined, the custom attribute will be removed.
These events fire only for the <form> elements:
onReset: An Event handler function. Fires when a form gets reset.
onResetCapture: A version of onReset that fires in the capture phase.
onSubmit: An Event handler function. Fires when a form gets submitted.
onSubmitCapture: A version of onSubmit that fires in the capture phase.
These events fire only for the <dialog> elements. Unlike browser events, they bubble in React:
onCancel: An Event handler function. Fires when the user tries to dismiss the dialog.
onCancelCapture: A version of onCancel that fires in the capture phase.
onClose: An Event handler function. Fires when a dialog has been closed.
onCloseCapture: A version of onClose that fires in the capture phase.
These events fire only for the <details> elements. Unlike browser events, they bubble in React:
onToggle: An Event handler function. Fires when the user toggles the details.
onToggleCapture: A version of onToggle that fires in the capture phase.
These events fire for <img>, <iframe>, <object>, <embed>, <link>, and SVG <image> elements. Unlike browser events, they bubble in React:
onLoad: An Event handler function. Fires when the resource has loaded.
onLoadCapture: A version of onLoad that fires in the capture phase.
onError: An Event handler function. Fires when the resource could not be loaded.
onErrorCapture: A version of onError that fires in the capture phase.
These events fire for resources like <audio> and <video>. Unlike browser events, they bubble in React:
onAbort: An Event handler function. Fires when the resource has not fully loaded, but not due to an error.
onAbortCapture: A version of onAbort that fires in the capture phase.
onCanPlay: An Event handler function. Fires when there’s enough data to start playing, but not enough to play to the end without buffering.
onCanPlayCapture: A version of onCanPlay that fires in the capture phase.
onCanPlayThrough: An Event handler function. Fires when there’s enough data that it’s likely possible to start playing without buffering until the end.
onCanPlayThroughCapture: A version of onCanPlayThrough that fires in the capture phase.
onDurationChange: An Event handler function. Fires when the media duration has updated.
onDurationChangeCapture: A version of onDurationChange that fires in the capture phase.
onEmptied: An Event handler function. Fires when the media has become empty.
onEmptiedCapture: A version of onEmptied that fires in the capture phase.
onEncrypted: An Event handler function. Fires when the browser encounters encrypted media.
onEncryptedCapture: A version of onEncrypted that fires in the capture phase.
onEnded: An Event handler function. Fires when the playback stops because there’s nothing left to play.
onEndedCapture: A version of onEnded that fires in the capture phase.
onError: An Event handler function. Fires when the resource could not be loaded.
onErrorCapture: A version of onError that fires in the capture phase.
onLoadedData: An Event handler function. Fires when the current playback frame has loaded.
onLoadedDataCapture: A version of onLoadedData that fires in the capture phase.
onLoadedMetadata: An Event handler function. Fires when metadata has loaded.
onLoadedMetadataCapture: A version of onLoadedMetadata that fires in the capture phase.
onLoadStart: An Event handler function. Fires when the browser started loading the resource.
onLoadStartCapture: A version of onLoadStart that fires in the capture phase.
onPause: An Event handler function. Fires when the media was paused.
onPauseCapture: A version of onPause that fires in the capture phase.
onPlay: An Event handler function. Fires when the media is no longer paused.
onPlayCapture: A version of onPlay that fires in the capture phase.
onPlaying: An Event handler function. Fires when the media starts or restarts playing.
onPlayingCapture: A version of onPlaying that fires in the capture phase.
onProgress: An Event handler function. Fires periodically while the resource is loading.
onProgressCapture: A version of onProgress that fires in the capture phase.
onRateChange: An Event handler function. Fires when playback rate changes.
onRateChangeCapture: A version of onRateChange that fires in the capture phase.
onResize: An Event handler function. Fires when video changes size.
onResizeCapture: A version of onResize that fires in the capture phase.
onSeeked: An Event handler function. Fires when a seek operation completes.
onSeekedCapture: A version of onSeeked that fires in the capture phase.
onSeeking: An Event handler function. Fires when a seek operation starts.
onSeekingCapture: A version of onSeeking that fires in the capture phase.
onStalled: An Event handler function. Fires when the browser is waiting for data but it keeps not loading.
onStalledCapture: A version of onStalled that fires in the capture phase.
onSuspend: An Event handler function. Fires when loading the resource was suspended.
onSuspendCapture: A version of onSuspend that fires in the capture phase.
onTimeUpdate: An Event handler function. Fires when the current playback time updates.
onTimeUpdateCapture: A version of onTimeUpdate that fires in the capture phase.
onVolumeChange: An Event handler function. Fires when the volume has changed.
onVolumeChangeCapture: A version of onVolumeChange that fires in the capture phase.
onWaiting: An Event handler function. Fires when the playback stopped due to temporary lack of data.
onWaitingCapture: A version of onWaiting that fires in the capture phase.
Caveats 
You cannot pass both children and dangerouslySetInnerHTML at the same time.
Some events (like onAbort and onLoad) don’t bubble in the browser, but bubble in React.

ref callback function 
Instead of a ref object (like the one returned by useRef), you may pass a function to the ref attribute.
<div ref={(node) => {
 console.log('Attached', node);

 return () => {
   console.log('Clean up', node)
 }
}}>
See an example of using the ref callback.
When the <div> DOM node is added to the screen, React will call your ref callback with the DOM node as the argument. When that <div> DOM node is removed, React will call your the cleanup function returned from the callback.
React will also call your ref callback whenever you pass a different ref callback. In the above example, (node) => { ... } is a different function on every render. When your component re-renders, the previous function will be called with null as the argument, and the next function will be called with the DOM node.
Parameters 
node: A DOM node. React will pass you the DOM node when the ref gets attached. Unless you pass the same function reference for the ref callback on every render, the callback will get temporarily cleanup and re-create during every re-render of the component.
Note
React 19 added cleanup functions for ref callbacks. 
To support backwards compatibility, if a cleanup function is not returned from the ref callback, node will be called with null when the ref is detached. This behavior will be removed in a future version.
Returns 
optional cleanup function: When the ref is detached, React will call the cleanup function. If a function is not returned by the ref callback, React will call the callback again with null as the argument when the ref gets detached. This behavior will be removed in a future version.
Caveats 
When Strict Mode is on, React will run one extra development-only setup+cleanup cycle before the first real setup. This is a stress-test that ensures that your cleanup logic “mirrors” your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, implement the cleanup function.
When you pass a different ref callback, React will call the previous callback’s cleanup function if provided. If no cleanup function is defined, the ref callback will be called with null as the argument. The next function will be called with the DOM node.

React event object 
Your event handlers will receive a React event object. It is also sometimes known as a “synthetic event”.
<button onClick={e => {
 console.log(e); // React event object
}} />
It conforms to the same standard as the underlying DOM events, but fixes some browser inconsistencies.
Some React events do not map directly to the browser’s native events. For example in onMouseLeave, e.nativeEvent will point to a mouseout event. The specific mapping is not part of the public API and may change in the future. If you need the underlying browser event for some reason, read it from e.nativeEvent.
Properties 
React event objects implement some of the standard Event properties:
bubbles: A boolean. Returns whether the event bubbles through the DOM.
cancelable: A boolean. Returns whether the event can be canceled.
currentTarget: A DOM node. Returns the node to which the current handler is attached in the React tree.
defaultPrevented: A boolean. Returns whether preventDefault was called.
eventPhase: A number. Returns which phase the event is currently in.
isTrusted: A boolean. Returns whether the event was initiated by user.
target: A DOM node. Returns the node on which the event has occurred (which could be a distant child).
timeStamp: A number. Returns the time when the event occurred.
Additionally, React event objects provide these properties:
nativeEvent: A DOM Event. The original browser event object.
Methods 
React event objects implement some of the standard Event methods:
preventDefault(): Prevents the default browser action for the event.
stopPropagation(): Stops the event propagation through the React tree.
Additionally, React event objects provide these methods:
isDefaultPrevented(): Returns a boolean value indicating whether preventDefault was called.
isPropagationStopped(): Returns a boolean value indicating whether stopPropagation was called.
persist(): Not used with React DOM. With React Native, call this to read event’s properties after the event.
isPersistent(): Not used with React DOM. With React Native, returns whether persist has been called.
Caveats 
The values of currentTarget, eventPhase, target, and type reflect the values your React code expects. Under the hood, React attaches event handlers at the root, but this is not reflected in React event objects. For example, e.currentTarget may not be the same as the underlying e.nativeEvent.currentTarget. For polyfilled events, e.type (React event type) may differ from e.nativeEvent.type (underlying type).

AnimationEvent handler function 
An event handler type for the CSS animation events.
<div
 onAnimationStart={e => console.log('onAnimationStart')}
 onAnimationIteration={e => console.log('onAnimationIteration')}
 onAnimationEnd={e => console.log('onAnimationEnd')}
/>
Parameters 
e: A React event object with these extra AnimationEvent properties:
animationName
elapsedTime
pseudoElement

ClipboardEvent handler function 
An event handler type for the Clipboard API events.
<input
 onCopy={e => console.log('onCopy')}
 onCut={e => console.log('onCut')}
 onPaste={e => console.log('onPaste')}
/>
Parameters 
e: A React event object with these extra ClipboardEvent properties:
clipboardData

CompositionEvent handler function 
An event handler type for the input method editor (IME) events.
<input
 onCompositionStart={e => console.log('onCompositionStart')}
 onCompositionUpdate={e => console.log('onCompositionUpdate')}
 onCompositionEnd={e => console.log('onCompositionEnd')}
/>
Parameters 
e: A React event object with these extra CompositionEvent properties:
data

DragEvent handler function 
An event handler type for the HTML Drag and Drop API events.
<>
 <div
   draggable={true}
   onDragStart={e => console.log('onDragStart')}
   onDragEnd={e => console.log('onDragEnd')}
 >
   Drag source
 </div>

 <div
   onDragEnter={e => console.log('onDragEnter')}
   onDragLeave={e => console.log('onDragLeave')}
   onDragOver={e => { e.preventDefault(); console.log('onDragOver'); }}
   onDrop={e => console.log('onDrop')}
 >
   Drop target
 </div>
</>
Parameters 
e: A React event object with these extra DragEvent properties:
dataTransfer
It also includes the inherited MouseEvent properties:
altKey
button
buttons
ctrlKey
clientX
clientY
getModifierState(key)
metaKey
movementX
movementY
pageX
pageY
relatedTarget
screenX
screenY
shiftKey
It also includes the inherited UIEvent properties:
detail
view

FocusEvent handler function 
An event handler type for the focus events.
<input
 onFocus={e => console.log('onFocus')}
 onBlur={e => console.log('onBlur')}
/>
See an example.
Parameters 
e: A React event object with these extra FocusEvent properties:
relatedTarget
It also includes the inherited UIEvent properties:
detail
view

Event handler function 
An event handler type for generic events.
Parameters 
e: A React event object with no additional properties.

InputEvent handler function 
An event handler type for the onBeforeInput event.
<input onBeforeInput={e => console.log('onBeforeInput')} />
Parameters 
e: A React event object with these extra InputEvent properties:
data

KeyboardEvent handler function 
An event handler type for keyboard events.
<input
 onKeyDown={e => console.log('onKeyDown')}
 onKeyUp={e => console.log('onKeyUp')}
/>
See an example.
Parameters 
e: A React event object with these extra KeyboardEvent properties:
altKey
charCode
code
ctrlKey
getModifierState(key)
key
keyCode
locale
metaKey
location
repeat
shiftKey
which
It also includes the inherited UIEvent properties:
detail
view

MouseEvent handler function 
An event handler type for mouse events.
<div
 onClick={e => console.log('onClick')}
 onMouseEnter={e => console.log('onMouseEnter')}
 onMouseOver={e => console.log('onMouseOver')}
 onMouseDown={e => console.log('onMouseDown')}
 onMouseUp={e => console.log('onMouseUp')}
 onMouseLeave={e => console.log('onMouseLeave')}
/>
See an example.
Parameters 
e: A React event object with these extra MouseEvent properties:
altKey
button
buttons
ctrlKey
clientX
clientY
getModifierState(key)
metaKey
movementX
movementY
pageX
pageY
relatedTarget
screenX
screenY
shiftKey
It also includes the inherited UIEvent properties:
detail
view

PointerEvent handler function 
An event handler type for pointer events.
<div
 onPointerEnter={e => console.log('onPointerEnter')}
 onPointerMove={e => console.log('onPointerMove')}
 onPointerDown={e => console.log('onPointerDown')}
 onPointerUp={e => console.log('onPointerUp')}
 onPointerLeave={e => console.log('onPointerLeave')}
/>
See an example.
Parameters 
e: A React event object with these extra PointerEvent properties:
height
isPrimary
pointerId
pointerType
pressure
tangentialPressure
tiltX
tiltY
twist
width
It also includes the inherited MouseEvent properties:
altKey
button
buttons
ctrlKey
clientX
clientY
getModifierState(key)
metaKey
movementX
movementY
pageX
pageY
relatedTarget
screenX
screenY
shiftKey
It also includes the inherited UIEvent properties:
detail
view

TouchEvent handler function 
An event handler type for touch events.
<div
 onTouchStart={e => console.log('onTouchStart')}
 onTouchMove={e => console.log('onTouchMove')}
 onTouchEnd={e => console.log('onTouchEnd')}
 onTouchCancel={e => console.log('onTouchCancel')}
/>
Parameters 
e: A React event object with these extra TouchEvent properties:
altKey
ctrlKey
changedTouches
getModifierState(key)
metaKey
shiftKey
touches
targetTouches
It also includes the inherited UIEvent properties:
detail
view

TransitionEvent handler function 
An event handler type for the CSS transition events.
<div
 onTransitionEnd={e => console.log('onTransitionEnd')}
/>
Parameters 
e: A React event object with these extra TransitionEvent properties:
elapsedTime
propertyName
pseudoElement

UIEvent handler function 
An event handler type for generic UI events.
<div
 onScroll={e => console.log('onScroll')}
/>
Parameters 
e: A React event object with these extra UIEvent properties:
detail
view

WheelEvent handler function 
An event handler type for the onWheel event.
<div
 onWheel={e => console.log('onWheel')}
/>
Parameters 
e: A React event object with these extra WheelEvent properties:
deltaMode
deltaX
deltaY
deltaZ
It also includes the inherited MouseEvent properties:
altKey
button
buttons
ctrlKey
clientX
clientY
getModifierState(key)
metaKey
movementX
movementY
pageX
pageY
relatedTarget
screenX
screenY
shiftKey
It also includes the inherited UIEvent properties:
detail
view

Usage 
Applying CSS styles 
In React, you specify a CSS class with className. It works like the class attribute in HTML:
<img className="avatar" />
Then you write the CSS rules for it in a separate CSS file:
/* In your CSS */
.avatar {
 border-radius: 50%;
}
React does not prescribe how you add CSS files. In the simplest case, you’ll add a <link> tag to your HTML. If you use a build tool or a framework, consult its documentation to learn how to add a CSS file to your project.
Sometimes, the style values depend on data. Use the style attribute to pass some styles dynamically:
<img
 className="avatar"
 style={{
   width: user.imageSize,
   height: user.imageSize
 }}
/>
In the above example, style={{}} is not a special syntax, but a regular {} object inside the style={ } JSX curly braces. We recommend only using the style attribute when your styles depend on JavaScript variables.
App.jsAvatar.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
export default function Avatar({ user }) {
 return (
   <img
     src={user.imageUrl}
     alt={'Photo of ' + user.name}
     className="avatar"
     style={{
       width: user.imageSize,
       height: user.imageSize
     }}
   />
 );
}

Deep Dive
How to apply multiple CSS classes conditionally? 
Hide Details
To apply CSS classes conditionally, you need to produce the className string yourself using JavaScript.
For example, className={'row ' + (isSelected ? 'selected': '')} will produce either className="row" or className="row selected" depending on whether isSelected is true.
To make this more readable, you can use a tiny helper library like classnames:
import cn from 'classnames';

function Row({ isSelected }) {
 return (
   <div className={cn('row', isSelected && 'selected')}>
     ...
   </div>
 );
}
It is especially convenient if you have multiple conditional classes:
import cn from 'classnames';

function Row({ isSelected, size }) {
 return (
   <div className={cn('row', {
     selected: isSelected,
     large: size === 'large',
     small: size === 'small',
   })}>
     ...
   </div>
 );
}

Manipulating a DOM node with a ref 
Sometimes, you’ll need to get the browser DOM node associated with a tag in JSX. For example, if you want to focus an <input> when a button is clicked, you need to call focus() on the browser <input> DOM node.
To obtain the browser DOM node for a tag, declare a ref and pass it as the ref attribute to that tag:
import { useRef } from 'react';

export default function Form() {
 const inputRef = useRef(null);
 // ...
 return (
   <input ref={inputRef} />
   // ...
React will put the DOM node into inputRef.current after it’s been rendered to the screen.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
import { useRef } from 'react';

export default function Form() {
 const inputRef = useRef(null);

 function handleClick() {
   inputRef.current.focus();
 }

 return (
   <>
     <input ref={inputRef} />
     <button onClick={handleClick}>
       Focus the input
     </button>
   </>
 );
}

Show more
Read more about manipulating DOM with refs and check out more examples.
For more advanced use cases, the ref attribute also accepts a callback function.

Dangerously setting the inner HTML 
You can pass a raw HTML string to an element like so:
const markup = { __html: '<p>some raw html</p>' };
return <div dangerouslySetInnerHTML={markup} />;
This is dangerous. As with the underlying DOM innerHTML property, you must exercise extreme caution! Unless the markup is coming from a completely trusted source, it is trivial to introduce an XSS vulnerability this way.
For example, if you use a Markdown library that converts Markdown to HTML, you trust that its parser doesn’t contain bugs, and the user only sees their own input, you can display the resulting HTML like this:
package.jsonApp.jsMarkdownPreview.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
import { Remarkable } from 'remarkable';

const md = new Remarkable();

function renderMarkdownToHTML(markdown) {
 // This is ONLY safe because the output HTML
 // is shown to the same user, and because you
 // trust this Markdown parser to not have bugs.
 const renderedHTML = md.render(markdown);
 return {__html: renderedHTML};
}

export default function MarkdownPreview({ markdown }) {
 const markup = renderMarkdownToHTML(markdown);
 return <div dangerouslySetInnerHTML={markup} />;
}

Show more
The {__html} object should be created as close to where the HTML is generated as possible, like the above example does in the renderMarkdownToHTML function. This ensures that all raw HTML being used in your code is explicitly marked as such, and that only variables that you expect to contain HTML are passed to dangerouslySetInnerHTML. It is not recommended to create the object inline like <div dangerouslySetInnerHTML={{__html: markup}} />.
To see why rendering arbitrary HTML is dangerous, replace the code above with this:
const post = {
 // Imagine this content is stored in the database.
 content: `<img src="" onerror='alert("you were hacked")'>`
};

export default function MarkdownPreview() {
 // 🔴 SECURITY HOLE: passing untrusted input to dangerouslySetInnerHTML
 const markup = { __html: post.content };
 return <div dangerouslySetInnerHTML={markup} />;
}
The code embedded in the HTML will run. A hacker could use this security hole to steal user information or to perform actions on their behalf. Only use dangerouslySetInnerHTML with trusted and sanitized data.

Handling mouse events 
This example shows some common mouse events and when they fire.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
export default function MouseExample() {
 return (
   <div
     onMouseEnter={e => console.log('onMouseEnter (parent)')}
     onMouseLeave={e => console.log('onMouseLeave (parent)')}
   >
     <button
       onClick={e => console.log('onClick (first button)')}
       onMouseDown={e => console.log('onMouseDown (first button)')}
       onMouseEnter={e => console.log('onMouseEnter (first button)')}
       onMouseLeave={e => console.log('onMouseLeave (first button)')}
       onMouseOver={e => console.log('onMouseOver (first button)')}
       onMouseUp={e => console.log('onMouseUp (first button)')}
     >
       First button
     </button>
     <button
       onClick={e => console.log('onClick (second button)')}
       onMouseDown={e => console.log('onMouseDown (second button)')}
       onMouseEnter={e => console.log('onMouseEnter (second button)')}
       onMouseLeave={e => console.log('onMouseLeave (second button)')}
       onMouseOver={e => console.log('onMouseOver (second button)')}
       onMouseUp={e => console.log('onMouseUp (second button)')}
     >
       Second button
     </button>
   </div>
 );
}

Show more

Handling pointer events 
This example shows some common pointer events and when they fire.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
export default function PointerExample() {
 return (
   <div
     onPointerEnter={e => console.log('onPointerEnter (parent)')}
     onPointerLeave={e => console.log('onPointerLeave (parent)')}
     style={{ padding: 20, backgroundColor: '#ddd' }}
   >
     <div
       onPointerDown={e => console.log('onPointerDown (first child)')}
       onPointerEnter={e => console.log('onPointerEnter (first child)')}
       onPointerLeave={e => console.log('onPointerLeave (first child)')}
       onPointerMove={e => console.log('onPointerMove (first child)')}
       onPointerUp={e => console.log('onPointerUp (first child)')}
       style={{ padding: 20, backgroundColor: 'lightyellow' }}
     >
       First child
     </div>
     <div
       onPointerDown={e => console.log('onPointerDown (second child)')}
       onPointerEnter={e => console.log('onPointerEnter (second child)')}
       onPointerLeave={e => console.log('onPointerLeave (second child)')}
       onPointerMove={e => console.log('onPointerMove (second child)')}
       onPointerUp={e => console.log('onPointerUp (second child)')}
       style={{ padding: 20, backgroundColor: 'lightblue' }}
     >
       Second child
     </div>
   </div>
 );
}

Show more

Handling focus events 
In React, focus events bubble. You can use the currentTarget and relatedTarget to differentiate if the focusing or blurring events originated from outside of the parent element. The example shows how to detect focusing a child, focusing the parent element, and how to detect focus entering or leaving the whole subtree.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
export default function FocusExample() {
 return (
   <div
     tabIndex={1}
     onFocus={(e) => {
       if (e.currentTarget === e.target) {
         console.log('focused parent');
       } else {
         console.log('focused child', e.target.name);
       }
       if (!e.currentTarget.contains(e.relatedTarget)) {
         // Not triggered when swapping focus between children
         console.log('focus entered parent');
       }
     }}
     onBlur={(e) => {
       if (e.currentTarget === e.target) {
         console.log('unfocused parent');
       } else {
         console.log('unfocused child', e.target.name);
       }
       if (!e.currentTarget.contains(e.relatedTarget)) {
         // Not triggered when swapping focus between children
         console.log('focus left parent');
       }
     }}
   >
     <label>
       First name:
       <input name="firstName" />
     </label>
     <label>
       Last name:
       <input name="lastName" />
     </label>
   </div>
Show more

Handling keyboard events 
This example shows some common keyboard events and when they fire.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
export default function KeyboardExample() {
 return (
   <label>
     First name:
     <input
       name="firstName"
       onKeyDown={e => console.log('onKeyDown:', e.key, e.code)}
       onKeyUp={e => console.log('onKeyUp:', e.key, e.code)}
     />
   </label>
 );
}

​​<input>
The built-in browser <input> component lets you render different kinds of form inputs.
<input />
Reference
<input>
Usage
Displaying inputs of different types
Providing a label for an input
Providing an initial value for an input
Reading the input values when submitting a form
Controlling an input with a state variable
Optimizing re-rendering on every keystroke
Troubleshooting
My text input doesn’t update when I type into it
My checkbox doesn’t update when I click on it
My input caret jumps to the beginning on every keystroke
I’m getting an error: “A component is changing an uncontrolled input to be controlled”

Reference 
<input> 
To display an input, render the built-in browser <input> component.
<input name="myInput" />
See more examples below.
Props 
<input> supports all common element props.
formAction: A string or function. Overrides the parent <form action> for type="submit" and type="image". When a URL is passed to action the form will behave like a standard HTML form. When a function is passed to formAction the function will handle the form submission. See <form action>.
You can make an input controlled by passing one of these props:
checked: A boolean. For a checkbox input or a radio button, controls whether it is selected.
value: A string. For a text input, controls its text. (For a radio button, specifies its form data.)
When you pass either of them, you must also pass an onChange handler that updates the passed value.
These <input> props are only relevant for uncontrolled inputs:
defaultChecked: A boolean. Specifies the initial value for type="checkbox" and type="radio" inputs.
defaultValue: A string. Specifies the initial value for a text input.
These <input> props are relevant both for uncontrolled and controlled inputs:
accept: A string. Specifies which filetypes are accepted by a type="file" input.
alt: A string. Specifies the alternative image text for a type="image" input.
capture: A string. Specifies the media (microphone, video, or camera) captured by a type="file" input.
autoComplete: A string. Specifies one of the possible autocomplete behaviors.
autoFocus: A boolean. If true, React will focus the element on mount.
dirname: A string. Specifies the form field name for the element’s directionality.
disabled: A boolean. If true, the input will not be interactive and will appear dimmed.
children: <input> does not accept children.
form: A string. Specifies the id of the <form> this input belongs to. If omitted, it’s the closest parent form.
formAction: A string. Overrides the parent <form action> for type="submit" and type="image".
formEnctype: A string. Overrides the parent <form enctype> for type="submit" and type="image".
formMethod: A string. Overrides the parent <form method> for type="submit" and type="image".
formNoValidate: A string. Overrides the parent <form noValidate> for type="submit" and type="image".
formTarget: A string. Overrides the parent <form target> for type="submit" and type="image".
height: A string. Specifies the image height for type="image".
list: A string. Specifies the id of the <datalist> with the autocomplete options.
max: A number. Specifies the maximum value of numerical and datetime inputs.
maxLength: A number. Specifies the maximum length of text and other inputs.
min: A number. Specifies the minimum value of numerical and datetime inputs.
minLength: A number. Specifies the minimum length of text and other inputs.
multiple: A boolean. Specifies whether multiple values are allowed for <type="file" and type="email".
name: A string. Specifies the name for this input that’s submitted with the form.
onChange: An Event handler function. Required for controlled inputs. Fires immediately when the input’s value is changed by the user (for example, it fires on every keystroke). Behaves like the browser input event.
onChangeCapture: A version of onChange that fires in the capture phase.
onInput: An Event handler function. Fires immediately when the value is changed by the user. For historical reasons, in React it is idiomatic to use onChange instead which works similarly.
onInputCapture: A version of onInput that fires in the capture phase.
onInvalid: An Event handler function. Fires if an input fails validation on form submit. Unlike the built-in invalid event, the React onInvalid event bubbles.
onInvalidCapture: A version of onInvalid that fires in the capture phase.
onSelect: An Event handler function. Fires after the selection inside the <input> changes. React extends the onSelect event to also fire for empty selection and on edits (which may affect the selection).
onSelectCapture: A version of onSelect that fires in the capture phase.
pattern: A string. Specifies the pattern that the value must match.
placeholder: A string. Displayed in a dimmed color when the input value is empty.
readOnly: A boolean. If true, the input is not editable by the user.
required: A boolean. If true, the value must be provided for the form to submit.
size: A number. Similar to setting width, but the unit depends on the control.
src: A string. Specifies the image source for a type="image" input.
step: A positive number or an 'any' string. Specifies the distance between valid values.
type: A string. One of the input types.
width: A string. Specifies the image width for a type="image" input.
Caveats 
Checkboxes need checked (or defaultChecked), not value (or defaultValue).
If a text input receives a string value prop, it will be treated as controlled.
If a checkbox or a radio button receives a boolean checked prop, it will be treated as controlled.
An input can’t be both controlled and uncontrolled at the same time.
An input cannot switch between being controlled or uncontrolled over its lifetime.
Every controlled input needs an onChange event handler that synchronously updates its backing value.

Usage 
Displaying inputs of different types 
To display an input, render an <input> component. By default, it will be a text input. You can pass type="checkbox" for a checkbox, type="radio" for a radio button, or one of the other input types.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
export default function MyForm() {
 return (
   <>
     <label>
       Text input: <input name="myInput" />
     </label>
     <hr />
     <label>
       Checkbox: <input type="checkbox" name="myCheckbox" />
     </label>
     <hr />
     <p>
       Radio buttons:
       <label>
         <input type="radio" name="myRadio" value="option1" />
         Option 1
       </label>
       <label>
         <input type="radio" name="myRadio" value="option2" />
         Option 2
       </label>
       <label>
         <input type="radio" name="myRadio" value="option3" />
         Option 3
       </label>
     </p>
   </>
 );
}

Show more

Providing a label for an input 
Typically, you will place every <input> inside a <label> tag. This tells the browser that this label is associated with that input. When the user clicks the label, the browser will automatically focus the input. It’s also essential for accessibility: a screen reader will announce the label caption when the user focuses the associated input.
If you can’t nest <input> into a <label>, associate them by passing the same ID to <input id> and <label htmlFor>. To avoid conflicts between multiple instances of one component, generate such an ID with useId.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
import { useId } from 'react';

export default function Form() {
 const ageInputId = useId();
 return (
   <>
     <label>
       Your first name:
       <input name="firstName" />
     </label>
     <hr />
     <label htmlFor={ageInputId}>Your age:</label>
     <input id={ageInputId} name="age" type="number" />
   </>
 );
}

Show more

Providing an initial value for an input 
You can optionally specify the initial value for any input. Pass it as the defaultValue string for text inputs. Checkboxes and radio buttons should specify the initial value with the defaultChecked boolean instead.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
export default function MyForm() {
 return (
   <>
     <label>
       Text input: <input name="myInput" defaultValue="Some initial value" />
     </label>
     <hr />
     <label>
       Checkbox: <input type="checkbox" name="myCheckbox" defaultChecked={true} />
     </label>
     <hr />
     <p>
       Radio buttons:
       <label>
         <input type="radio" name="myRadio" value="option1" />
         Option 1
       </label>
       <label>
         <input
           type="radio"
           name="myRadio"
           value="option2"
           defaultChecked={true}
         />
         Option 2
       </label>
       <label>
         <input type="radio" name="myRadio" value="option3" />
         Option 3
       </label>
     </p>
   </>
 );
}

Show more

Reading the input values when submitting a form 
Add a <form> around your inputs with a <button type="submit"> inside. It will call your <form onSubmit> event handler. By default, the browser will send the form data to the current URL and refresh the page. You can override that behavior by calling e.preventDefault(). Read the form data with new FormData(e.target).
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
export default function MyForm() {
 function handleSubmit(e) {
   // Prevent the browser from reloading the page
   e.preventDefault();

   // Read the form data
   const form = e.target;
   const formData = new FormData(form);

   // You can pass formData as a fetch body directly:
   fetch('/some-api', { method: form.method, body: formData });

   // Or you can work with it as a plain object:
   const formJson = Object.fromEntries(formData.entries());
   console.log(formJson);
 }

 return (
   <form method="post" onSubmit={handleSubmit}>
     <label>
       Text input: <input name="myInput" defaultValue="Some initial value" />
     </label>
     <hr />
     <label>
       Checkbox: <input type="checkbox" name="myCheckbox" defaultChecked={true} />
     </label>
     <hr />
     <p>
       Radio buttons:
       <label><input type="radio" name="myRadio" value="option1" /> Option 1</label>
       <label><input type="radio" name="myRadio" value="option2" defaultChecked={true} /> Option 2</label>
       <label><input type="radio" name="myRadio" value="option3" /> Option 3</label>
     </p>
     <hr />
     <button type="reset">Reset form</button>
     <button type="submit">Submit form</button>
Show more
Note
Give a name to every <input>, for example <input name="firstName" defaultValue="Taylor" />. The name you specified will be used as a key in the form data, for example { firstName: "Taylor" }.
Pitfall
By default, a <button> inside a <form> without a type attribute will submit it. This can be surprising! If you have your own custom Button React component, consider using <button type="button"> instead of <button> (with no type). Then, to be explicit, use <button type="submit"> for buttons that are supposed to submit the form.

Controlling an input with a state variable 
An input like <input /> is uncontrolled. Even if you pass an initial value like <input defaultValue="Initial text" />, your JSX only specifies the initial value. It does not control what the value should be right now.
To render a controlled input, pass the value prop to it (or checked for checkboxes and radios). React will force the input to always have the value you passed. Usually, you would do this by declaring a state variable:
function Form() {
 const [firstName, setFirstName] = useState(''); // Declare a state variable...
 // ...
 return (
   <input
     value={firstName} // ...force the input's value to match the state variable...
     onChange={e => setFirstName(e.target.value)} // ... and update the state variable on any edits!
   />
 );
}
A controlled input makes sense if you needed state anyway—for example, to re-render your UI on every edit:
function Form() {
 const [firstName, setFirstName] = useState('');
 return (
   <>
     <label>
       First name:
       <input value={firstName} onChange={e => setFirstName(e.target.value)} />
     </label>
     {firstName !== '' && <p>Your name is {firstName}.</p>}
     ...
It’s also useful if you want to offer multiple ways to adjust the input state (for example, by clicking a button):
function Form() {
 // ...
 const [age, setAge] = useState('');
 const ageAsNumber = Number(age);
 return (
   <>
     <label>
       Age:
       <input
         value={age}
         onChange={e => setAge(e.target.value)}
         type="number"
       />
       <button onClick={() => setAge(ageAsNumber + 10)}>
         Add 10 years
       </button>
The value you pass to controlled components should not be undefined or null. If you need the initial value to be empty (such as with the firstName field below), initialize your state variable to an empty string ('').
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
import { useState } from 'react';

export default function Form() {
 const [firstName, setFirstName] = useState('');
 const [age, setAge] = useState('20');
 const ageAsNumber = Number(age);
 return (
   <>
     <label>
       First name:
       <input
         value={firstName}
         onChange={e => setFirstName(e.target.value)}
       />
     </label>
     <label>
       Age:
       <input
         value={age}
         onChange={e => setAge(e.target.value)}
         type="number"
       />
       <button onClick={() => setAge(ageAsNumber + 10)}>
         Add 10 years
       </button>
     </label>
     {firstName !== '' &&
       <p>Your name is {firstName}.</p>
     }
     {ageAsNumber > 0 &&
       <p>Your age is {ageAsNumber}.</p>
     }
   </>
 );
}

Show more
Pitfall
If you pass value without onChange, it will be impossible to type into the input. When you control an input by passing some value to it, you force it to always have the value you passed. So if you pass a state variable as a value but forget to update that state variable synchronously during the onChange event handler, React will revert the input after every keystroke back to the value that you specified.

Optimizing re-rendering on every keystroke 
When you use a controlled input, you set the state on every keystroke. If the component containing your state re-renders a large tree, this can get slow. There’s a few ways you can optimize re-rendering performance.
For example, suppose you start with a form that re-renders all page content on every keystroke:
function App() {
 const [firstName, setFirstName] = useState('');
 return (
   <>
     <form>
       <input value={firstName} onChange={e => setFirstName(e.target.value)} />
     </form>
     <PageContent />
   </>
 );
}
Since <PageContent /> doesn’t rely on the input state, you can move the input state into its own component:
function App() {
 return (
   <>
     <SignupForm />
     <PageContent />
   </>
 );
}

function SignupForm() {
 const [firstName, setFirstName] = useState('');
 return (
   <form>
     <input value={firstName} onChange={e => setFirstName(e.target.value)} />
   </form>
 );
}
This significantly improves performance because now only SignupForm re-renders on every keystroke.
If there is no way to avoid re-rendering (for example, if PageContent depends on the search input’s value), useDeferredValue lets you keep the controlled input responsive even in the middle of a large re-render.

Troubleshooting 
My text input doesn’t update when I type into it 
If you render an input with value but no onChange, you will see an error in the console:
// 🔴 Bug: controlled text input with no onChange handler
<input value={something} />
Console
You provided a value prop to a form field without an onChange handler. This will render a read-only field. If the field should be mutable use defaultValue. Otherwise, set either onChange or readOnly.
As the error message suggests, if you only wanted to specify the initial value, pass defaultValue instead:
// ✅ Good: uncontrolled input with an initial value
<input defaultValue={something} />
If you want to control this input with a state variable, specify an onChange handler:
// ✅ Good: controlled input with onChange
<input value={something} onChange={e => setSomething(e.target.value)} />
If the value is intentionally read-only, add a readOnly prop to suppress the error:
// ✅ Good: readonly controlled input without on change
<input value={something} readOnly={true} />

My checkbox doesn’t update when I click on it 
If you render a checkbox with checked but no onChange, you will see an error in the console:
// 🔴 Bug: controlled checkbox with no onChange handler
<input type="checkbox" checked={something} />
Console
You provided a checked prop to a form field without an onChange handler. This will render a read-only field. If the field should be mutable use defaultChecked. Otherwise, set either onChange or readOnly.
As the error message suggests, if you only wanted to specify the initial value, pass defaultChecked instead:
// ✅ Good: uncontrolled checkbox with an initial value
<input type="checkbox" defaultChecked={something} />
If you want to control this checkbox with a state variable, specify an onChange handler:
// ✅ Good: controlled checkbox with onChange
<input type="checkbox" checked={something} onChange={e => setSomething(e.target.checked)} />
Pitfall
You need to read e.target.checked rather than e.target.value for checkboxes.
If the checkbox is intentionally read-only, add a readOnly prop to suppress the error:
// ✅ Good: readonly controlled input without on change
<input type="checkbox" checked={something} readOnly={true} />

My input caret jumps to the beginning on every keystroke 
If you control an input, you must update its state variable to the input’s value from the DOM during onChange.
You can’t update it to something other than e.target.value (or e.target.checked for checkboxes):
function handleChange(e) {
 // 🔴 Bug: updating an input to something other than e.target.value
 setFirstName(e.target.value.toUpperCase());
}
You also can’t update it asynchronously:
function handleChange(e) {
 // 🔴 Bug: updating an input asynchronously
 setTimeout(() => {
   setFirstName(e.target.value);
 }, 100);
}
To fix your code, update it synchronously to e.target.value:
function handleChange(e) {
 // ✅ Updating a controlled input to e.target.value synchronously
 setFirstName(e.target.value);
}
If this doesn’t fix the problem, it’s possible that the input gets removed and re-added from the DOM on every keystroke. This can happen if you’re accidentally resetting state on every re-render, for example if the input or one of its parents always receives a different key attribute, or if you nest component function definitions (which is not supported and causes the “inner” component to always be considered a different tree).

I’m getting an error: “A component is changing an uncontrolled input to be controlled” 
If you provide a value to the component, it must remain a string throughout its lifetime.
You cannot pass value={undefined} first and later pass value="some string" because React won’t know whether you want the component to be uncontrolled or controlled. A controlled component should always receive a string value, not null or undefined.
If your value is coming from an API or a state variable, it might be initialized to null or undefined. In that case, either set it to an empty string ('') initially, or pass value={someValue ?? ''} to ensure value is a string.
Similarly, if you pass checked to a checkbox, ensure it’s always a boolean.
<option>
The built-in browser <option> component lets you render an option inside a <select> box.
<select>
 <option value="someOption">Some option</option>
 <option value="otherOption">Other option</option>
</select>
Reference
<option>
Usage
Displaying a select box with options

Reference 
<option> 
The built-in browser <option> component lets you render an option inside a <select> box.
<select>
 <option value="someOption">Some option</option>
 <option value="otherOption">Other option</option>
</select>
See more examples below.
Props 
<option> supports all common element props.
Additionally, <option> supports these props:
disabled: A boolean. If true, the option will not be selectable and will appear dimmed.
label: A string. Specifies the meaning of the option. If not specified, the text inside the option is used.
value: The value to be used when submitting the parent <select> in a form if this option is selected.
Caveats 
React does not support the selected attribute on <option>. Instead, pass this option’s value to the parent <select defaultValue> for an uncontrolled select box, or <select value> for a controlled select.

Usage 
Displaying a select box with options 
Render a <select> with a list of <option> components inside to display a select box. Give each <option> a value representing the data to be submitted with the form.
Read more about displaying a <select> with a list of <option> components.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
export default function FruitPicker() {
 return (
   <label>
     Pick a fruit:
     <select name="selectedFruit">
       <option value="apple">Apple</option>
       <option value="banana">Banana</option>
       <option value="orange">Orange</option>
     </select>
   </label>
 );
}

<progress>
The built-in browser <progress> component lets you render a progress indicator.
<progress value={0.5} />
Reference
<progress>
Usage
Controlling a progress indicator

Reference 
<progress> 
To display a progress indicator, render the built-in browser <progress> component.
<progress value={0.5} />
See more examples below.
Props 
<progress> supports all common element props.
Additionally, <progress> supports these props:
max: A number. Specifies the maximum value. Defaults to 1.
value: A number between 0 and max, or null for indeterminate progress. Specifies how much was done.

Usage 
Controlling a progress indicator 
To display a progress indicator, render a <progress> component. You can pass a number value between 0 and the max value you specify. If you don’t pass a max value, it will assumed to be 1 by default.
If the operation is not ongoing, pass value={null} to put the progress indicator into an indeterminate state.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
export default function App() {
 return (
   <>
     <progress value={0} />
     <progress value={0.5} />
     <progress value={0.7} />
     <progress value={75} max={100} />
     <progress value={1} />
     <progress value={null} />
   </>
 );
}

<select>
The built-in browser <select> component lets you render a select box with options.
<select>
 <option value="someOption">Some option</option>
 <option value="otherOption">Other option</option>
</select>
Reference
<select>
Usage
Displaying a select box with options
Providing a label for a select box
Providing an initially selected option
Enabling multiple selection
Reading the select box value when submitting a form
Controlling a select box with a state variable

Reference 
<select> 
To display a select box, render the built-in browser <select> component.
<select>
 <option value="someOption">Some option</option>
 <option value="otherOption">Other option</option>
</select>
See more examples below.
Props 
<select> supports all common element props.
You can make a select box controlled by passing a value prop:
value: A string (or an array of strings for multiple={true}). Controls which option is selected. Every value string match the value of some <option> nested inside the <select>.
When you pass value, you must also pass an onChange handler that updates the passed value.
If your <select> is uncontrolled, you may pass the defaultValue prop instead:
defaultValue: A string (or an array of strings for multiple={true}). Specifies the initially selected option.
These <select> props are relevant both for uncontrolled and controlled select boxes:
autoComplete: A string. Specifies one of the possible autocomplete behaviors.
autoFocus: A boolean. If true, React will focus the element on mount.
children: <select> accepts <option>, <optgroup>, and <datalist> components as children. You can also pass your own components as long as they eventually render one of the allowed components. If you pass your own components that eventually render <option> tags, each <option> you render must have a value.
disabled: A boolean. If true, the select box will not be interactive and will appear dimmed.
form: A string. Specifies the id of the <form> this select box belongs to. If omitted, it’s the closest parent form.
multiple: A boolean. If true, the browser allows multiple selection.
name: A string. Specifies the name for this select box that’s submitted with the form.
onChange: An Event handler function. Required for controlled select boxes. Fires immediately when the user picks a different option. Behaves like the browser input event.
onChangeCapture: A version of onChange that fires in the capture phase.
onInput: An Event handler function. Fires immediately when the value is changed by the user. For historical reasons, in React it is idiomatic to use onChange instead which works similarly.
onInputCapture: A version of onInput that fires in the capture phase.
onInvalid: An Event handler function. Fires if an input fails validation on form submit. Unlike the built-in invalid event, the React onInvalid event bubbles.
onInvalidCapture: A version of onInvalid that fires in the capture phase.
required: A boolean. If true, the value must be provided for the form to submit.
size: A number. For multiple={true} selects, specifies the preferred number of initially visible items.
Caveats 
Unlike in HTML, passing a selected attribute to <option> is not supported. Instead, use <select defaultValue> for uncontrolled select boxes and <select value> for controlled select boxes.
If a select box receives a value prop, it will be treated as controlled.
A select box can’t be both controlled and uncontrolled at the same time.
A select box cannot switch between being controlled or uncontrolled over its lifetime.
Every controlled select box needs an onChange event handler that synchronously updates its backing value.

Usage 
Displaying a select box with options 
Render a <select> with a list of <option> components inside to display a select box. Give each <option> a value representing the data to be submitted with the form.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
export default function FruitPicker() {
 return (
   <label>
     Pick a fruit:
     <select name="selectedFruit">
       <option value="apple">Apple</option>
       <option value="banana">Banana</option>
       <option value="orange">Orange</option>
     </select>
   </label>
 );
}


Providing a label for a select box 
Typically, you will place every <select> inside a <label> tag. This tells the browser that this label is associated with that select box. When the user clicks the label, the browser will automatically focus the select box. It’s also essential for accessibility: a screen reader will announce the label caption when the user focuses the select box.
If you can’t nest <select> into a <label>, associate them by passing the same ID to <select id> and <label htmlFor>. To avoid conflicts between multiple instances of one component, generate such an ID with useId.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
import { useId } from 'react';

export default function Form() {
 const vegetableSelectId = useId();
 return (
   <>
     <label>
       Pick a fruit:
       <select name="selectedFruit">
         <option value="apple">Apple</option>
         <option value="banana">Banana</option>
         <option value="orange">Orange</option>
       </select>
     </label>
     <hr />
     <label htmlFor={vegetableSelectId}>
       Pick a vegetable:
     </label>
     <select id={vegetableSelectId} name="selectedVegetable">
       <option value="cucumber">Cucumber</option>
       <option value="corn">Corn</option>
       <option value="tomato">Tomato</option>
     </select>
   </>
 );
}

Show more

Providing an initially selected option 
By default, the browser will select the first <option> in the list. To select a different option by default, pass that <option>’s value as the defaultValue to the <select> element.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
export default function FruitPicker() {
 return (
   <label>
     Pick a fruit:
     <select name="selectedFruit" defaultValue="orange">
       <option value="apple">Apple</option>
       <option value="banana">Banana</option>
       <option value="orange">Orange</option>
     </select>
   </label>
 );
}

Pitfall
Unlike in HTML, passing a selected attribute to an individual <option> is not supported.

Enabling multiple selection 
Pass multiple={true} to the <select> to let the user select multiple options. In that case, if you also specify defaultValue to choose the initially selected options, it must be an array.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
export default function FruitPicker() {
 return (
   <label>
     Pick some fruits:
     <select
       name="selectedFruit"
       defaultValue={['orange', 'banana']}
       multiple={true}
     >
       <option value="apple">Apple</option>
       <option value="banana">Banana</option>
       <option value="orange">Orange</option>
     </select>
   </label>
 );
}

Show more

Reading the select box value when submitting a form 
Add a <form> around your select box with a <button type="submit"> inside. It will call your <form onSubmit> event handler. By default, the browser will send the form data to the current URL and refresh the page. You can override that behavior by calling e.preventDefault(). Read the form data with new FormData(e.target).
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
export default function EditPost() {
 function handleSubmit(e) {
   // Prevent the browser from reloading the page
   e.preventDefault();
   // Read the form data
   const form = e.target;
   const formData = new FormData(form);
   // You can pass formData as a fetch body directly:
   fetch('/some-api', { method: form.method, body: formData });
   // You can generate a URL out of it, as the browser does by default:
   console.log(new URLSearchParams(formData).toString());
   // You can work with it as a plain object.
   const formJson = Object.fromEntries(formData.entries());
   console.log(formJson); // (!) This doesn't include multiple select values
   // Or you can get an array of name-value pairs.
   console.log([...formData.entries()]);
 }

 return (
   <form method="post" onSubmit={handleSubmit}>
     <label>
       Pick your favorite fruit:
       <select name="selectedFruit" defaultValue="orange">
         <option value="apple">Apple</option>
         <option value="banana">Banana</option>
         <option value="orange">Orange</option>
       </select>
     </label>
     <label>
       Pick all your favorite vegetables:
       <select
         name="selectedVegetables"
         multiple={true}
         defaultValue={['corn', 'tomato']}
       >
         <option value="cucumber">Cucumber</option>
Show more
Note
Give a name to your <select>, for example <select name="selectedFruit" />. The name you specified will be used as a key in the form data, for example { selectedFruit: "orange" }.
If you use <select multiple={true}>, the FormData you’ll read from the form will include each selected value as a separate name-value pair. Look closely at the console logs in the example above.
Pitfall
By default, any <button> inside a <form> will submit it. This can be surprising! If you have your own custom Button React component, consider returning <button type="button"> instead of <button>. Then, to be explicit, use <button type="submit"> for buttons that are supposed to submit the form.

Controlling a select box with a state variable 
A select box like <select /> is uncontrolled. Even if you pass an initially selected value like <select defaultValue="orange" />, your JSX only specifies the initial value, not the value right now.
To render a controlled select box, pass the value prop to it. React will force the select box to always have the value you passed. Typically, you will control a select box by declaring a state variable:
function FruitPicker() {
 const [selectedFruit, setSelectedFruit] = useState('orange'); // Declare a state variable...
 // ...
 return (
   <select
     value={selectedFruit} // ...force the select's value to match the state variable...
     onChange={e => setSelectedFruit(e.target.value)} // ... and update the state variable on any change!
   >
     <option value="apple">Apple</option>
     <option value="banana">Banana</option>
     <option value="orange">Orange</option>
   </select>
 );
}
This is useful if you want to re-render some part of the UI in response to every selection.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
import { useState } from 'react';

export default function FruitPicker() {
 const [selectedFruit, setSelectedFruit] = useState('orange');
 const [selectedVegs, setSelectedVegs] = useState(['corn', 'tomato']);
 return (
   <>
     <label>
       Pick a fruit:
       <select
         value={selectedFruit}
         onChange={e => setSelectedFruit(e.target.value)}
       >
         <option value="apple">Apple</option>
         <option value="banana">Banana</option>
         <option value="orange">Orange</option>
       </select>
     </label>
     <hr />
     <label>
       Pick all your favorite vegetables:
       <select
         multiple={true}
         value={selectedVegs}
         onChange={e => {
           const options = [...e.target.selectedOptions];
           const values = options.map(option => option.value);
           setSelectedVegs(values);
         }}
       >
         <option value="cucumber">Cucumber</option>
         <option value="corn">Corn</option>
         <option value="tomato">Tomato</option>
       </select>
     </label>
     <hr />
Show more
Pitfall
If you pass value without onChange, it will be impossible to select an option. When you control a select box by passing some value to it, you force it to always have the value you passed. So if you pass a state variable as a value but forget to update that state variable synchronously during the onChange event handler, React will revert the select box after every keystroke back to the value that you specified.
Unlike in HTML, passing a selected attribute to an individual <option> is not supported.
<textarea>
The built-in browser <textarea> component lets you render a multiline text input.
<textarea />
Reference
<textarea>
Usage
Displaying a text area
Providing a label for a text area
Providing an initial value for a text area
Reading the text area value when submitting a form
Controlling a text area with a state variable
Troubleshooting
My text area doesn’t update when I type into it
My text area caret jumps to the beginning on every keystroke
I’m getting an error: “A component is changing an uncontrolled input to be controlled”

Reference 
<textarea> 
To display a text area, render the built-in browser <textarea> component.
<textarea name="postContent" />
See more examples below.
Props 
<textarea> supports all common element props.
You can make a text area controlled by passing a value prop:
value: A string. Controls the text inside the text area.
When you pass value, you must also pass an onChange handler that updates the passed value.
If your <textarea> is uncontrolled, you may pass the defaultValue prop instead:
defaultValue: A string. Specifies the initial value for a text area.
These <textarea> props are relevant both for uncontrolled and controlled text areas:
autoComplete: Either 'on' or 'off'. Specifies the autocomplete behavior.
autoFocus: A boolean. If true, React will focus the element on mount.
children: <textarea> does not accept children. To set the initial value, use defaultValue.
cols: A number. Specifies the default width in average character widths. Defaults to 20.
disabled: A boolean. If true, the input will not be interactive and will appear dimmed.
form: A string. Specifies the id of the <form> this input belongs to. If omitted, it’s the closest parent form.
maxLength: A number. Specifies the maximum length of text.
minLength: A number. Specifies the minimum length of text.
name: A string. Specifies the name for this input that’s submitted with the form.
onChange: An Event handler function. Required for controlled text areas. Fires immediately when the input’s value is changed by the user (for example, it fires on every keystroke). Behaves like the browser input event.
onChangeCapture: A version of onChange that fires in the capture phase.
onInput: An Event handler function. Fires immediately when the value is changed by the user. For historical reasons, in React it is idiomatic to use onChange instead which works similarly.
onInputCapture: A version of onInput that fires in the capture phase.
onInvalid: An Event handler function. Fires if an input fails validation on form submit. Unlike the built-in invalid event, the React onInvalid event bubbles.
onInvalidCapture: A version of onInvalid that fires in the capture phase.
onSelect: An Event handler function. Fires after the selection inside the <textarea> changes. React extends the onSelect event to also fire for empty selection and on edits (which may affect the selection).
onSelectCapture: A version of onSelect that fires in the capture phase.
placeholder: A string. Displayed in a dimmed color when the text area value is empty.
readOnly: A boolean. If true, the text area is not editable by the user.
required: A boolean. If true, the value must be provided for the form to submit.
rows: A number. Specifies the default height in average character heights. Defaults to 2.
wrap: Either 'hard', 'soft', or 'off'. Specifies how the text should be wrapped when submitting a form.
Caveats 
Passing children like <textarea>something</textarea> is not allowed. Use defaultValue for initial content.
If a text area receives a string value prop, it will be treated as controlled.
A text area can’t be both controlled and uncontrolled at the same time.
A text area cannot switch between being controlled or uncontrolled over its lifetime.
Every controlled text area needs an onChange event handler that synchronously updates its backing value.

Usage 
Displaying a text area 
Render <textarea> to display a text area. You can specify its default size with the rows and cols attributes, but by default the user will be able to resize it. To disable resizing, you can specify resize: none in the CSS.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
export default function NewPost() {
 return (
   <label>
     Write your post:
     <textarea name="postContent" rows={4} cols={40} />
   </label>
 );
}


Providing a label for a text area 
Typically, you will place every <textarea> inside a <label> tag. This tells the browser that this label is associated with that text area. When the user clicks the label, the browser will focus the text area. It’s also essential for accessibility: a screen reader will announce the label caption when the user focuses the text area.
If you can’t nest <textarea> into a <label>, associate them by passing the same ID to <textarea id> and <label htmlFor>. To avoid conflicts between instances of one component, generate such an ID with useId.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
import { useId } from 'react';

export default function Form() {
 const postTextAreaId = useId();
 return (
   <>
     <label htmlFor={postTextAreaId}>
       Write your post:
     </label>
     <textarea
       id={postTextAreaId}
       name="postContent"
       rows={4}
       cols={40}
     />
   </>
 );
}

Show more

Providing an initial value for a text area 
You can optionally specify the initial value for the text area. Pass it as the defaultValue string.
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
export default function EditPost() {
 return (
   <label>
     Edit your post:
     <textarea
       name="postContent"
       defaultValue="I really enjoyed biking yesterday!"
       rows={4}
       cols={40}
     />
   </label>
 );
}

Pitfall
Unlike in HTML, passing initial text like <textarea>Some content</textarea> is not supported.

Reading the text area value when submitting a form 
Add a <form> around your textarea with a <button type="submit"> inside. It will call your <form onSubmit> event handler. By default, the browser will send the form data to the current URL and refresh the page. You can override that behavior by calling e.preventDefault(). Read the form data with new FormData(e.target).
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
export default function EditPost() {
 function handleSubmit(e) {
   // Prevent the browser from reloading the page
   e.preventDefault();

   // Read the form data
   const form = e.target;
   const formData = new FormData(form);

   // You can pass formData as a fetch body directly:
   fetch('/some-api', { method: form.method, body: formData });

   // Or you can work with it as a plain object:
   const formJson = Object.fromEntries(formData.entries());
   console.log(formJson);
 }

 return (
   <form method="post" onSubmit={handleSubmit}>
     <label>
       Post title: <input name="postTitle" defaultValue="Biking" />
     </label>
     <label>
       Edit your post:
       <textarea
         name="postContent"
         defaultValue="I really enjoyed biking yesterday!"
         rows={4}
         cols={40}
       />
     </label>
     <hr />
     <button type="reset">Reset edits</button>
     <button type="submit">Save post</button>
   </form>
 );
Show more
Note
Give a name to your <textarea>, for example <textarea name="postContent" />. The name you specified will be used as a key in the form data, for example { postContent: "Your post" }.
Pitfall
By default, any <button> inside a <form> will submit it. This can be surprising! If you have your own custom Button React component, consider returning <button type="button"> instead of <button>. Then, to be explicit, use <button type="submit"> for buttons that are supposed to submit the form.

Controlling a text area with a state variable 
A text area like <textarea /> is uncontrolled. Even if you pass an initial value like <textarea defaultValue="Initial text" />, your JSX only specifies the initial value, not the value right now.
To render a controlled text area, pass the value prop to it. React will force the text area to always have the value you passed. Typically, you will control a text area by declaring a state variable:
function NewPost() {
 const [postContent, setPostContent] = useState(''); // Declare a state variable...
 // ...
 return (
   <textarea
     value={postContent} // ...force the input's value to match the state variable...
     onChange={e => setPostContent(e.target.value)} // ... and update the state variable on any edits!
   />
 );
}
This is useful if you want to re-render some part of the UI in response to every keystroke.
package.jsonApp.jsMarkdownPreview.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
{
 "dependencies": {
   "react": "latest",
   "react-dom": "latest",
   "react-scripts": "latest",
   "remarkable": "2.0.1"
 },
 "scripts": {
   "start": "react-scripts start",
   "build": "react-scripts build",
   "test": "react-scripts test --env=jsdom",
   "eject": "react-scripts eject"
 },
 "devDependencies": {}
}
Pitfall
If you pass value without onChange, it will be impossible to type into the text area. When you control a text area by passing some value to it, you force it to always have the value you passed. So if you pass a state variable as a value but forget to update that state variable synchronously during the onChange event handler, React will revert the text area after every keystroke back to the value that you specified.

Troubleshooting 
My text area doesn’t update when I type into it 
If you render a text area with value but no onChange, you will see an error in the console:
// 🔴 Bug: controlled text area with no onChange handler
<textarea value={something} />
Console
You provided a value prop to a form field without an onChange handler. This will render a read-only field. If the field should be mutable use defaultValue. Otherwise, set either onChange or readOnly.
As the error message suggests, if you only wanted to specify the initial value, pass defaultValue instead:
// ✅ Good: uncontrolled text area with an initial value
<textarea defaultValue={something} />
If you want to control this text area with a state variable, specify an onChange handler:
// ✅ Good: controlled text area with onChange
<textarea value={something} onChange={e => setSomething(e.target.value)} />
If the value is intentionally read-only, add a readOnly prop to suppress the error:
// ✅ Good: readonly controlled text area without on change
<textarea value={something} readOnly={true} />

My text area caret jumps to the beginning on every keystroke 
If you control a text area, you must update its state variable to the text area’s value from the DOM during onChange.
You can’t update it to something other than e.target.value:
function handleChange(e) {
 // 🔴 Bug: updating an input to something other than e.target.value
 setFirstName(e.target.value.toUpperCase());
}
You also can’t update it asynchronously:
function handleChange(e) {
 // 🔴 Bug: updating an input asynchronously
 setTimeout(() => {
   setFirstName(e.target.value);
 }, 100);
}
To fix your code, update it synchronously to e.target.value:
function handleChange(e) {
 // ✅ Updating a controlled input to e.target.value synchronously
 setFirstName(e.target.value);
}
If this doesn’t fix the problem, it’s possible that the text area gets removed and re-added from the DOM on every keystroke. This can happen if you’re accidentally resetting state on every re-render. For example, this can happen if the text area or one of its parents always receives a different key attribute, or if you nest component definitions (which is not allowed in React and causes the “inner” component to remount on every render).

I’m getting an error: “A component is changing an uncontrolled input to be controlled” 
If you provide a value to the component, it must remain a string throughout its lifetime.
You cannot pass value={undefined} first and later pass value="some string" because React won’t know whether you want the component to be uncontrolled or controlled. A controlled component should always receive a string value, not null or undefined.
If your value is coming from an API or a state variable, it might be initialized to null or undefined. In that case, either set it to an empty string ('') initially, or pass value={someValue ?? ''} to ensure value is a string.

<link>
The built-in browser <link> component lets you use external resources such as stylesheets or annotate the document with link metadata.
<link rel="icon" href="favicon.ico" />
Reference
<link>
Usage
Linking to related resources
Linking to a stylesheet
Controlling stylesheet precedence
Deduplicated stylesheet rendering
Annotating specific items within the document with links

Reference 
<link> 
To link to external resources such as stylesheets, fonts, and icons, or to annotate the document with link metadata, render the built-in browser <link> component. You can render <link> from any component and React will in most cases place the corresponding DOM element in the document head.
<link rel="icon" href="favicon.ico" />
See more examples below.
Props 
<link> supports all common element props.
rel: a string, required. Specifies the relationship to the resource. React treats links with rel="stylesheet" differently from other links.
These props apply when rel="stylesheet":
precedence: a string. Tells React where to rank the <link> DOM node relative to others in the document <head>, which determines which stylesheet can override the other. React will infer that precedence values it discovers first are “lower” and precedence values it discovers later are “higher”. Many style systems can work fine using a single precedence value because style rules are atomic. Stylesheets with the same precedence go together whether they are <link> or inline <style> tags or loaded using preinit functions.
media: a string. Restricts the stylesheet to a certain media query.
title: a string. Specifies the name of an alternative stylesheet.
These props apply when rel="stylesheet" but disable React’s special treatment of stylesheets:
disabled: a boolean. Disables the stylesheet.
onError: a function. Called when the stylesheet fails to load.
onLoad: a function. Called when the stylesheet finishes being loaded.
These props apply when rel="preload" or rel="modulepreload":
as: a string. The type of resource. Its possible values are audio, document, embed, fetch, font, image, object, script, style, track, video, worker.
imageSrcSet: a string. Applicable only when as="image". Specifies the source set of the image.
imageSizes: a string. Applicable only when as="image". Specifies the sizes of the image.
These props apply when rel="icon" or rel="apple-touch-icon":
sizes: a string. The sizes of the icon.
These props apply in all cases:
href: a string. The URL of the linked resource.
crossOrigin: a string. The CORS policy to use. Its possible values are anonymous and use-credentials. It is required when as is set to "fetch".
referrerPolicy: a string. The Referrer header to send when fetching. Its possible values are no-referrer-when-downgrade (the default), no-referrer, origin, origin-when-cross-origin, and unsafe-url.
fetchPriority: a string. Suggests a relative priority for fetching the resource. The possible values are auto (the default), high, and low.
hrefLang: a string. The language of the linked resource.
integrity: a string. A cryptographic hash of the resource, to verify its authenticity.
type: a string. The MIME type of the linked resource.
Props that are not recommended for use with React:
blocking: a string. If set to "render", instructs the browser not to render the page until the stylesheet is loaded. React provides more fine-grained control using Suspense.
Special rendering behavior 
React will always place the DOM element corresponding to the <link> component within the document’s <head>, regardless of where in the React tree it is rendered. The <head> is the only valid place for <link> to exist within the DOM, yet it’s convenient and keeps things composable if a component representing a specific page can render <link> components itself.
There are a few exceptions to this:
If the <link> has a rel="stylesheet" prop, then it has to also have a precedence prop to get this special behavior. This is because the order of stylesheets within the document is significant, so React needs to know how to order this stylesheet relative to others, which you specify using the precedence prop. If the precedence prop is omitted, there is no special behavior.
If the <link> has an itemProp prop, there is no special behavior, because in this case it doesn’t apply to the document but instead represents metadata about a specific part of the page.
If the <link> has an onLoad or onError prop, because in that case you are managing the loading of the linked resource manually within your React component.
Special behavior for stylesheets 
In addition, if the <link> is to a stylesheet (namely, it has rel="stylesheet" in its props), React treats it specially in the following ways:
The component that renders <link> will suspend while the stylesheet is loading.
If multiple components render links to the same stylesheet, React will de-duplicate them and only put a single link into the DOM. Two links are considered the same if they have the same href prop.
There are two exception to this special behavior:
If the link doesn’t have a precedence prop, there is no special behavior, because the order of stylesheets within the document is significant, so React needs to know how to order this stylesheet relative to others, which you specify using the precedence prop.
If you supply any of the onLoad, onError, or disabled props, there is no special behavior, because these props indicate that you are managing the loading of the stylesheet manually within your component.
This special treatment comes with two caveats:
React will ignore changes to props after the link has been rendered. (React will issue a warning in development if this happens.)
React may leave the link in the DOM even after the component that rendered it has been unmounted.

Usage 
Linking to related resources 
You can annotate the document with links to related resources such as an icon, canonical URL, or pingback. React will place this metadata within the document <head> regardless of where in the React tree it is rendered.
App.jsShowRenderedHTML.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
import ShowRenderedHTML from './ShowRenderedHTML.js';

export default function BlogPage() {
 return (
   <ShowRenderedHTML>
     <link rel="icon" href="favicon.ico" />
     <link rel="pingback" href="http://www.example.com/xmlrpc.php" />
     <h1>My Blog</h1>
     <p>...</p>
   </ShowRenderedHTML>
 );
}

Linking to a stylesheet 
If a component depends on a certain stylesheet in order to be displayed correctly, you can render a link to that stylesheet within the component. Your component will suspend while the stylesheet is loading. You must supply the precedence prop, which tells React where to place this stylesheet relative to others — stylesheets with higher precedence can override those with lower precedence.
Note
When you want to use a stylesheet, it can be beneficial to call the preinit function. Calling this function may allow the browser to start fetching the stylesheet earlier than if you just render a <link> component, for example by sending an HTTP Early Hints response.
App.jsShowRenderedHTML.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
import ShowRenderedHTML from './ShowRenderedHTML.js';

export default function SiteMapPage() {
 return (
   <ShowRenderedHTML>
     <link rel="stylesheet" href="sitemap.css" precedence="medium" />
     <p>...</p>
   </ShowRenderedHTML>
 );
}

Controlling stylesheet precedence 
Stylesheets can conflict with each other, and when they do, the browser goes with the one that comes later in the document. React lets you control the order of stylesheets with the precedence prop. In this example, three components render stylesheets, and the ones with the same precedence are grouped together in the <head>.
App.jsShowRenderedHTML.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
import ShowRenderedHTML from './ShowRenderedHTML.js';

export default function HomePage() {
 return (
   <ShowRenderedHTML>
     <FirstComponent />
     <SecondComponent />
     <ThirdComponent/>
     ...
   </ShowRenderedHTML>
 );
}

function FirstComponent() {
 return <link rel="stylesheet" href="first.css" precedence="first" />;
}

function SecondComponent() {
 return <link rel="stylesheet" href="second.css" precedence="second" />;
}

function ThirdComponent() {
 return <link rel="stylesheet" href="third.css" precedence="first" />;
}


Show more
Note the precedence values themselves are arbitrary and their naming is up to you. React will infer that precedence values it discovers first are “lower” and precedence values it discovers later are “higher”.
Deduplicated stylesheet rendering 
If you render the same stylesheet from multiple components, React will place only a single <link> in the document head.
App.jsShowRenderedHTML.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
import ShowRenderedHTML from './ShowRenderedHTML.js';

export default function HomePage() {
 return (
   <ShowRenderedHTML>
     <Component />
     <Component />
     ...
   </ShowRenderedHTML>
 );
}

function Component() {
 return <link rel="stylesheet" href="styles.css" precedence="medium" />;
}

Annotating specific items within the document with links 
You can use the <link> component with the itemProp prop to annotate specific items within the document with links to related resources. In this case, React will not place these annotations within the document <head> but will place them like any other React component.
<section itemScope>
 <h3>Annotating specific items</h3>
 <link itemProp="author" href="http://example.com/" />
 <p>...</p>
</section>

<meta>
The built-in browser <meta> component lets you add metadata to the document.
<meta name="keywords" content="React, JavaScript, semantic markup, html" />
Reference
<meta>
Usage
Annotating the document with metadata
Annotating specific items within the document with metadata

Reference 
<meta> 
To add document metadata, render the built-in browser <meta> component. You can render <meta> from any component and React will always place the corresponding DOM element in the document head.
<meta name="keywords" content="React, JavaScript, semantic markup, html" />
See more examples below.
Props 
<meta> supports all common element props.
It should have exactly one of the following props: name, httpEquiv, charset, itemProp. The <meta> component does something different depending on which of these props is specified.
name: a string. Specifies the kind of metadata to be attached to the document.
charset: a string. Specifies the character set used by the document. The only valid value is "utf-8".
httpEquiv: a string. Specifies a directive for processing the document.
itemProp: a string. Specifies metadata about a particular item within the document rather than the document as a whole.
content: a string. Specifies the metadata to be attached when used with the name or itemProp props or the behavior of the directive when used with the httpEquiv prop.
Special rendering behavior 
React will always place the DOM element corresponding to the <meta> component within the document’s <head>, regardless of where in the React tree it is rendered. The <head> is the only valid place for <meta> to exist within the DOM, yet it’s convenient and keeps things composable if a component representing a specific page can render <meta> components itself.
There is one exception to this: if <meta> has an itemProp prop, there is no special behavior, because in this case it doesn’t represent metadata about the document but rather metadata about a specific part of the page.

Usage 
Annotating the document with metadata 
You can annotate the document with metadata such as keywords, a summary, or the author’s name. React will place this metadata within the document <head> regardless of where in the React tree it is rendered.
<meta name="author" content="John Smith" />
<meta name="keywords" content="React, JavaScript, semantic markup, html" />
<meta name="description" content="API reference for the <meta> component in React DOM" />
You can render the <meta> component from any component. React will put a <meta> DOM node in the document <head>.
App.jsShowRenderedHTML.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
import ShowRenderedHTML from './ShowRenderedHTML.js';

export default function SiteMapPage() {
 return (
   <ShowRenderedHTML>
     <meta name="keywords" content="React" />
     <meta name="description" content="A site map for the React website" />
     <h1>Site Map</h1>
     <p>...</p>
   </ShowRenderedHTML>
 );
}

Annotating specific items within the document with metadata 
You can use the <meta> component with the itemProp prop to annotate specific items within the document with metadata. In this case, React will not place these annotations within the document <head> but will place them like any other React component.
<section itemScope>
 <h3>Annotating specific items</h3>
 <meta itemProp="description" content="API reference for using <meta> with itemProp" />
 <p>...</p>
</section>

<script>
The built-in browser <script> component lets you add a script to your document.
<script> alert("hi!") </script>
Reference
<script>
Usage
Rendering an external script
Rendering an inline script

Reference 
<script> 
To add inline or external scripts to your document, render the built-in browser <script> component. You can render <script> from any component and React will in certain cases place the corresponding DOM element in the document head and de-duplicate identical scripts.
<script> alert("hi!") </script>
<script src="script.js" />
See more examples below.
Props 
<script> supports all common element props.
It should have either children or a src prop.
children: a string. The source code of an inline script.
src: a string. The URL of an external script.
Other supported props:
async: a boolean. Allows the browser to defer execution of the script until the rest of the document has been processed — the preferred behavior for performance.
crossOrigin: a string. The CORS policy to use. Its possible values are anonymous and use-credentials.
fetchPriority: a string. Lets the browser rank scripts in priority when fetching multiple scripts at the same time. Can be "high", "low", or "auto" (the default).
integrity: a string. A cryptographic hash of the script, to verify its authenticity.
noModule: a boolean. Disables the script in browsers that support ES modules — allowing for a fallback script for browsers that do not.
nonce: a string. A cryptographic nonce to allow the resource when using a strict Content Security Policy.
referrer: a string. Says what Referer header to send when fetching the script and any resources that the script fetches in turn.
type: a string. Says whether the script is a classic script, ES module, or import map.
Props that disable React’s special treatment of scripts:
onError: a function. Called when the script fails to load.
onLoad: a function. Called when the script finishes being loaded.
Props that are not recommended for use with React:
blocking: a string. If set to "render", instructs the browser not to render the page until the scriptsheet is loaded. React provides more fine-grained control using Suspense.
defer: a string. Prevents the browser from executing the script until the document is done loading. Not compatible with streaming server-rendered components. Use the async prop instead.
Special rendering behavior 
React can move <script> components to the document’s <head> and de-duplicate identical scripts.
To opt into this behavior, provide the src and async={true} props. React will de-duplicate scripts if they have the same src. The async prop must be true to allow scripts to be safely moved.
This special treatment comes with two caveats:
React will ignore changes to props after the script has been rendered. (React will issue a warning in development if this happens.)
React may leave the script in the DOM even after the component that rendered it has been unmounted. (This has no effect as scripts just execute once when they are inserted into the DOM.)

Usage 
Rendering an external script 
If a component depends on certain scripts in order to be displayed correctly, you can render a <script> within the component.
However, the component might be committed before the script has finished loading.
You can start depending on the script content once the load event is fired e.g. by using the onLoad prop.
React will de-duplicate scripts that have the same src, inserting only one of them into the DOM even if multiple components render it.
App.jsShowRenderedHTML.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
import ShowRenderedHTML from './ShowRenderedHTML.js';

function Map({lat, long}) {
 return (
   <>
     <script async src="map-api.js" onLoad={() => console.log('script loaded')} />
     <div id="map" data-lat={lat} data-long={long} />
   </>
 );
}

export default function Page() {
 return (
   <ShowRenderedHTML>
     <Map />
   </ShowRenderedHTML>
 );
}

Show more
Note
When you want to use a script, it can be beneficial to call the preinit function. Calling this function may allow the browser to start fetching the script earlier than if you just render a <script> component, for example by sending an HTTP Early Hints response.
Rendering an inline script 
To include an inline script, render the <script> component with the script source code as its children. Inline scripts are not de-duplicated or moved to the document <head>.
App.jsShowRenderedHTML.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
import ShowRenderedHTML from './ShowRenderedHTML.js';

function Tracking() {
 return (
   <script>
     ga('send', 'pageview');
   </script>
 );
}

export default function Page() {
 return (
   <ShowRenderedHTML>
     <h1>My Website</h1>
     <Tracking />
     <p>Welcome</p>
   </ShowRenderedHTML>
 );
}

Show more

<style>
The built-in browser <style> component lets you add inline CSS stylesheets to your document.
<style>{` p { color: red; } `}</style>
Reference
<style>
Usage
Rendering an inline CSS stylesheet

Reference 
<style> 
To add inline styles to your document, render the built-in browser <style> component. You can render <style> from any component and React will in certain cases place the corresponding DOM element in the document head and de-duplicate identical styles.
<style>{` p { color: red; } `}</style>
See more examples below.
Props 
<style> supports all common element props.
children: a string, required. The contents of the stylesheet.
precedence: a string. Tells React where to rank the <style> DOM node relative to others in the document <head>, which determines which stylesheet can override the other. React will infer that precedence values it discovers first are “lower” and precedence values it discovers later are “higher”. Many style systems can work fine using a single precedence value because style rules are atomic. Stylesheets with the same precedence go together whether they are <link> or inline <style> tags or loaded using preinit functions.
href: a string. Allows React to de-duplicate styles that have the same href.
media: a string. Restricts the stylesheet to a certain media query.
nonce: a string. A cryptographic nonce to allow the resource when using a strict Content Security Policy.
title: a string. Specifies the name of an alternative stylesheet.
Props that are not recommended for use with React:
blocking: a string. If set to "render", instructs the browser not to render the page until the stylesheet is loaded. React provides more fine-grained control using Suspense.
Special rendering behavior 
React can move <style> components to the document’s <head>, de-duplicate identical stylesheets, and suspend while the stylesheet is loading.
To opt into this behavior, provide the href and precedence props. React will de-duplicate styles if they have the same href. The precedence prop tells React where to rank the <style> DOM node relative to others in the document <head>, which determines which stylesheet can override the other.
This special treatment comes with two caveats:
React will ignore changes to props after the style has been rendered. (React will issue a warning in development if this happens.)
React will drop all extraneous props when using the precedence prop (beyond href and precedence).
React may leave the style in the DOM even after the component that rendered it has been unmounted.

Usage 
Rendering an inline CSS stylesheet 
If a component depends on certain CSS styles in order to be displayed correctly, you can render an inline stylesheet within the component.
The href prop should uniquely identify the stylesheet, because React will de-duplicate stylesheets that have the same href.
If you supply a precedence prop, React will reorder inline stylesheets based on the order these values appear in the component tree.
Inline stylesheets will not trigger Suspense boundaries while they’re loading.
Even if they load async resources like fonts or images.
App.jsShowRenderedHTML.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
import ShowRenderedHTML from './ShowRenderedHTML.js';
import { useId } from 'react';

function PieChart({data, colors}) {
 const id = useId();
 const stylesheet = colors.map((color, index) =>
   `#${id} .color-${index}: \{ color: "${color}"; \}`
 ).join();
 return (
   <>
     <style href={"PieChart-" + JSON.stringify(colors)} precedence="medium">
       {stylesheet}
     </style>
     <svg id={id}>
       …
     </svg>
   </>
 );
}

export default function App() {
 return (
   <ShowRenderedHTML>
     <PieChart data="..." colors={['red', 'green', 'blue']} />
   </ShowRenderedHTML>
 );
}

Show more

<style>
The built-in browser <style> component lets you add inline CSS stylesheets to your document.
<style>{` p { color: red; } `}</style>
Reference
<style>
Usage
Rendering an inline CSS stylesheet

Reference 
<style> 
To add inline styles to your document, render the built-in browser <style> component. You can render <style> from any component and React will in certain cases place the corresponding DOM element in the document head and de-duplicate identical styles.
<style>{` p { color: red; } `}</style>
See more examples below.
Props 
<style> supports all common element props.
children: a string, required. The contents of the stylesheet.
precedence: a string. Tells React where to rank the <style> DOM node relative to others in the document <head>, which determines which stylesheet can override the other. React will infer that precedence values it discovers first are “lower” and precedence values it discovers later are “higher”. Many style systems can work fine using a single precedence value because style rules are atomic. Stylesheets with the same precedence go together whether they are <link> or inline <style> tags or loaded using preinit functions.
href: a string. Allows React to de-duplicate styles that have the same href.
media: a string. Restricts the stylesheet to a certain media query.
nonce: a string. A cryptographic nonce to allow the resource when using a strict Content Security Policy.
title: a string. Specifies the name of an alternative stylesheet.
Props that are not recommended for use with React:
blocking: a string. If set to "render", instructs the browser not to render the page until the stylesheet is loaded. React provides more fine-grained control using Suspense.
Special rendering behavior 
React can move <style> components to the document’s <head>, de-duplicate identical stylesheets, and suspend while the stylesheet is loading.
To opt into this behavior, provide the href and precedence props. React will de-duplicate styles if they have the same href. The precedence prop tells React where to rank the <style> DOM node relative to others in the document <head>, which determines which stylesheet can override the other.
This special treatment comes with two caveats:
React will ignore changes to props after the style has been rendered. (React will issue a warning in development if this happens.)
React will drop all extraneous props when using the precedence prop (beyond href and precedence).
React may leave the style in the DOM even after the component that rendered it has been unmounted.

Usage 
Rendering an inline CSS stylesheet 
If a component depends on certain CSS styles in order to be displayed correctly, you can render an inline stylesheet within the component.
The href prop should uniquely identify the stylesheet, because React will de-duplicate stylesheets that have the same href.
If you supply a precedence prop, React will reorder inline stylesheets based on the order these values appear in the component tree.
Inline stylesheets will not trigger Suspense boundaries while they’re loading.
Even if they load async resources like fonts or images.
App.jsShowRenderedHTML.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
import ShowRenderedHTML from './ShowRenderedHTML.js';
import { useId } from 'react';

function PieChart({data, colors}) {
 const id = useId();
 const stylesheet = colors.map((color, index) =>
   `#${id} .color-${index}: \{ color: "${color}"; \}`
 ).join();
 return (
   <>
     <style href={"PieChart-" + JSON.stringify(colors)} precedence="medium">
       {stylesheet}
     </style>
     <svg id={id}>
       …
     </svg>
   </>
 );
}

export default function App() {
 return (
   <ShowRenderedHTML>
     <PieChart data="..." colors={['red', 'green', 'blue']} />
   </ShowRenderedHTML>
 );
}

Show more

<title>
The built-in browser <title> component lets you specify the title of the document.
<title>My Blog</title>
Reference
<title>
Usage
Set the document title
Use variables in the title

Reference 
<title> 
To specify the title of the document, render the built-in browser <title> component. You can render <title> from any component and React will always place the corresponding DOM element in the document head.
<title>My Blog</title>
See more examples below.
Props 
<title> supports all common element props.
children: <title> accepts only text as a child. This text will become the title of the document. You can also pass your own components as long as they only render text.
Special rendering behavior 
React will always place the DOM element corresponding to the <title> component within the document’s <head>, regardless of where in the React tree it is rendered. The <head> is the only valid place for <title> to exist within the DOM, yet it’s convenient and keeps things composable if a component representing a specific page can render its <title> itself.
There are two exception to this:
If <title> is within an <svg> component, then there is no special behavior, because in this context it doesn’t represent the document’s title but rather is an accessibility annotation for that SVG graphic.
If the <title> has an itemProp prop, there is no special behavior, because in this case it doesn’t represent the document’s title but rather metadata about a specific part of the page.
Pitfall
Only render a single <title> at a time. If more than one component renders a <title> tag at the same time, React will place all of those titles in the document head. When this happens, the behavior of browsers and search engines is undefined.

Usage 
Set the document title 
Render the <title> component from any component with text as its children. React will put a <title> DOM node in the document <head>.
App.jsShowRenderedHTML.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
import ShowRenderedHTML from './ShowRenderedHTML.js';

export default function ContactUsPage() {
 return (
   <ShowRenderedHTML>
     <title>My Site: Contact Us</title>
     <h1>Contact Us</h1>
     <p>Email us at support@example.com</p>
   </ShowRenderedHTML>
 );
}

Use variables in the title 
The children of the <title> component must be a single string of text. (Or a single number or a single object with a toString method.) It might not be obvious, but using JSX curly braces like this:
<title>Results page {pageNumber}</title> // 🔴 Problem: This is not a single string
… actually causes the <title> component to get a two-element array as its children (the string "Results page" and the value of pageNumber). This will cause an error. Instead, use string interpolation to pass <title> a single string:
<title>{`Results page ${pageNumber}`}</title>


React DOM APIs
The react-dom package contains methods that are only supported for the web applications (which run in the browser DOM environment). They are not supported for React Native.

APIs 
These APIs can be imported from your components. They are rarely used:
createPortal lets you render child components in a different part of the DOM tree.
flushSync lets you force React to flush a state update and update the DOM synchronously.
Resource Preloading APIs 
These APIs can be used to make apps faster by pre-loading resources such as scripts, stylesheets, and fonts as soon as you know you need them, for example before navigating to another page where the resources will be used.
React-based frameworks frequently handle resource loading for you, so you might not have to call these APIs yourself. Consult your framework’s documentation for details.
prefetchDNS lets you prefetch the IP address of a DNS domain name that you expect to connect to.
preconnect lets you connect to a server you expect to request resources from, even if you don’t know what resources you’ll need yet.
preload lets you fetch a stylesheet, font, image, or external script that you expect to use.
preloadModule lets you fetch an ESM module that you expect to use.
preinit lets you fetch and evaluate an external script or fetch and insert a stylesheet.
preinitModule lets you fetch and evaluate an ESM module.

Entry points 
The react-dom package provides two additional entry points:
react-dom/client contains APIs to render React components on the client (in the browser).
react-dom/server contains APIs to render React components on the server.

Removed APIs 
These APIs were removed in React 19:
findDOMNode: see alternatives.
hydrate: use hydrateRoot instead.
render: use createRoot instead.
unmountComponentAtNode: use root.unmount() instead.
renderToNodeStream: use react-dom/server APIs instead.
renderToStaticNodeStream: use react-dom/server APIs instead.
createPortal
createPortal lets you render some children into a different part of the DOM.
<div>
 <SomeComponent />
 {createPortal(children, domNode, key?)}
</div>
Reference
createPortal(children, domNode, key?)
Usage
Rendering to a different part of the DOM
Rendering a modal dialog with a portal
Rendering React components into non-React server markup
Rendering React components into non-React DOM nodes

Reference 
createPortal(children, domNode, key?) 
To create a portal, call createPortal, passing some JSX, and the DOM node where it should be rendered:
import { createPortal } from 'react-dom';

// ...

<div>
 <p>This child is placed in the parent div.</p>
 {createPortal(
   <p>This child is placed in the document body.</p>,
   document.body
 )}
</div>
See more examples below.
A portal only changes the physical placement of the DOM node. In every other way, the JSX you render into a portal acts as a child node of the React component that renders it. For example, the child can access the context provided by the parent tree, and events bubble up from children to parents according to the React tree.
Parameters 
children: Anything that can be rendered with React, such as a piece of JSX (e.g. <div /> or <SomeComponent />), a Fragment (<>...</>), a string or a number, or an array of these.
domNode: Some DOM node, such as those returned by document.getElementById(). The node must already exist. Passing a different DOM node during an update will cause the portal content to be recreated.
optional key: A unique string or number to be used as the portal’s key.
Returns 
createPortal returns a React node that can be included into JSX or returned from a React component. If React encounters it in the render output, it will place the provided children inside the provided domNode.
Caveats 
Events from portals propagate according to the React tree rather than the DOM tree. For example, if you click inside a portal, and the portal is wrapped in <div onClick>, that onClick handler will fire. If this causes issues, either stop the event propagation from inside the portal, or move the portal itself up in the React tree.

Usage 
Rendering to a different part of the DOM 
Portals let your components render some of their children into a different place in the DOM. This lets a part of your component “escape” from whatever containers it may be in. For example, a component can display a modal dialog or a tooltip that appears above and outside of the rest of the page.
To create a portal, render the result of createPortal with some JSX and the DOM node where it should go:
import { createPortal } from 'react-dom';

function MyComponent() {
 return (
   <div style={{ border: '2px solid black' }}>
     <p>This child is placed in the parent div.</p>
     {createPortal(
       <p>This child is placed in the document body.</p>,
       document.body
     )}
   </div>
 );
}
React will put the DOM nodes for the JSX you passed inside of the DOM node you provided.
Without a portal, the second <p> would be placed inside the parent <div>, but the portal “teleported” it into the document.body:
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
import { createPortal } from 'react-dom';

export default function MyComponent() {
 return (
   <div style={{ border: '2px solid black' }}>
     <p>This child is placed in the parent div.</p>
     {createPortal(
       <p>This child is placed in the document body.</p>,
       document.body
     )}
   </div>
 );
}

Notice how the second paragraph visually appears outside the parent <div> with the border. If you inspect the DOM structure with developer tools, you’ll see that the second <p> got placed directly into the <body>:
<body>
 <div id="root">
   ...
     <div style="border: 2px solid black">
       <p>This child is placed inside the parent div.</p>
     </div>
   ...
 </div>
 <p>This child is placed in the document body.</p>
</body>
A portal only changes the physical placement of the DOM node. In every other way, the JSX you render into a portal acts as a child node of the React component that renders it. For example, the child can access the context provided by the parent tree, and events still bubble up from children to parents according to the React tree.

Rendering a modal dialog with a portal 
You can use a portal to create a modal dialog that floats above the rest of the page, even if the component that summons the dialog is inside a container with overflow: hidden or other styles that interfere with the dialog.
In this example, the two containers have styles that disrupt the modal dialog, but the one rendered into a portal is unaffected because, in the DOM, the modal is not contained within the parent JSX elements.
App.jsNoPortalExample.jsPortalExample.jsModalContent.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
import NoPortalExample from './NoPortalExample';
import PortalExample from './PortalExample';

export default function App() {
 return (
   <>
     <div className="clipping-container">
       <NoPortalExample  />
     </div>
     <div className="clipping-container">
       <PortalExample />
     </div>
   </>
 );
}

Pitfall
It’s important to make sure that your app is accessible when using portals. For instance, you may need to manage keyboard focus so that the user can move the focus in and out of the portal in a natural way.
Follow the WAI-ARIA Modal Authoring Practices when creating modals. If you use a community package, ensure that it is accessible and follows these guidelines.

Rendering React components into non-React server markup 
Portals can be useful if your React root is only part of a static or server-rendered page that isn’t built with React. For example, if your page is built with a server framework like Rails, you can create areas of interactivity within static areas such as sidebars. Compared with having multiple separate React roots, portals let you treat the app as a single React tree with shared state even though its parts render to different parts of the DOM.
index.jsindex.htmlApp.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
import { createPortal } from 'react-dom';

const sidebarContentEl = document.getElementById('sidebar-content');

export default function App() {
 return (
   <>
     <MainContent />
     {createPortal(
       <SidebarContent />,
       sidebarContentEl
     )}
   </>
 );
}

function MainContent() {
 return <p>This part is rendered by React</p>;
}

function SidebarContent() {
 return <p>This part is also rendered by React!</p>;
}

Show more

Rendering React components into non-React DOM nodes 
You can also use a portal to manage the content of a DOM node that’s managed outside of React. For example, suppose you’re integrating with a non-React map widget and you want to render React content inside a popup. To do this, declare a popupContainer state variable to store the DOM node you’re going to render into:
const [popupContainer, setPopupContainer] = useState(null);
When you create the third-party widget, store the DOM node returned by the widget so you can render into it:
useEffect(() => {
 if (mapRef.current === null) {
   const map = createMapWidget(containerRef.current);
   mapRef.current = map;
   const popupDiv = addPopupToMapWidget(map);
   setPopupContainer(popupDiv);
 }
}, []);
This lets you use createPortal to render React content into popupContainer once it becomes available:
return (
 <div style={{ width: 250, height: 250 }} ref={containerRef}>
   {popupContainer !== null && createPortal(
     <p>Hello from React!</p>,
     popupContainer
   )}
 </div>
);
Here is a complete example you can play with:
App.jsmap-widget.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
import { useRef, useEffect, useState } from 'react';
import { createPortal } from 'react-dom';
import { createMapWidget, addPopupToMapWidget } from './map-widget.js';

export default function Map() {
 const containerRef = useRef(null);
 const mapRef = useRef(null);
 const [popupContainer, setPopupContainer] = useState(null);

 useEffect(() => {
   if (mapRef.current === null) {
     const map = createMapWidget(containerRef.current);
     mapRef.current = map;
     const popupDiv = addPopupToMapWidget(map);
     setPopupContainer(popupDiv);
   }
 }, []);

 return (
   <div style={{ width: 250, height: 250 }} ref={containerRef}>
     {popupContainer !== null && createPortal(
       <p>Hello from React!</p>,
       popupContainer
     )}
   </div>
 );
}



createPortal
createPortal lets you render some children into a different part of the DOM.
<div>
 <SomeComponent />
 {createPortal(children, domNode, key?)}
</div>
Reference
createPortal(children, domNode, key?)
Usage
Rendering to a different part of the DOM
Rendering a modal dialog with a portal
Rendering React components into non-React server markup
Rendering React components into non-React DOM nodes

Reference 
createPortal(children, domNode, key?) 
To create a portal, call createPortal, passing some JSX, and the DOM node where it should be rendered:
import { createPortal } from 'react-dom';

// ...

<div>
 <p>This child is placed in the parent div.</p>
 {createPortal(
   <p>This child is placed in the document body.</p>,
   document.body
 )}
</div>
See more examples below.
A portal only changes the physical placement of the DOM node. In every other way, the JSX you render into a portal acts as a child node of the React component that renders it. For example, the child can access the context provided by the parent tree, and events bubble up from children to parents according to the React tree.
Parameters 
children: Anything that can be rendered with React, such as a piece of JSX (e.g. <div /> or <SomeComponent />), a Fragment (<>...</>), a string or a number, or an array of these.
domNode: Some DOM node, such as those returned by document.getElementById(). The node must already exist. Passing a different DOM node during an update will cause the portal content to be recreated.
optional key: A unique string or number to be used as the portal’s key.
Returns 
createPortal returns a React node that can be included into JSX or returned from a React component. If React encounters it in the render output, it will place the provided children inside the provided domNode.
Caveats 
Events from portals propagate according to the React tree rather than the DOM tree. For example, if you click inside a portal, and the portal is wrapped in <div onClick>, that onClick handler will fire. If this causes issues, either stop the event propagation from inside the portal, or move the portal itself up in the React tree.

Usage 
Rendering to a different part of the DOM 
Portals let your components render some of their children into a different place in the DOM. This lets a part of your component “escape” from whatever containers it may be in. For example, a component can display a modal dialog or a tooltip that appears above and outside of the rest of the page.
To create a portal, render the result of createPortal with some JSX and the DOM node where it should go:
import { createPortal } from 'react-dom';

function MyComponent() {
 return (
   <div style={{ border: '2px solid black' }}>
     <p>This child is placed in the parent div.</p>
     {createPortal(
       <p>This child is placed in the document body.</p>,
       document.body
     )}
   </div>
 );
}
React will put the DOM nodes for the JSX you passed inside of the DOM node you provided.
Without a portal, the second <p> would be placed inside the parent <div>, but the portal “teleported” it into the document.body:
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
import { createPortal } from 'react-dom';

export default function MyComponent() {
 return (
   <div style={{ border: '2px solid black' }}>
     <p>This child is placed in the parent div.</p>
     {createPortal(
       <p>This child is placed in the document body.</p>,
       document.body
     )}
   </div>
 );
}

Notice how the second paragraph visually appears outside the parent <div> with the border. If you inspect the DOM structure with developer tools, you’ll see that the second <p> got placed directly into the <body>:
<body>
 <div id="root">
   ...
     <div style="border: 2px solid black">
       <p>This child is placed inside the parent div.</p>
     </div>
   ...
 </div>
 <p>This child is placed in the document body.</p>
</body>
A portal only changes the physical placement of the DOM node. In every other way, the JSX you render into a portal acts as a child node of the React component that renders it. For example, the child can access the context provided by the parent tree, and events still bubble up from children to parents according to the React tree.

Rendering a modal dialog with a portal 
You can use a portal to create a modal dialog that floats above the rest of the page, even if the component that summons the dialog is inside a container with overflow: hidden or other styles that interfere with the dialog.
In this example, the two containers have styles that disrupt the modal dialog, but the one rendered into a portal is unaffected because, in the DOM, the modal is not contained within the parent JSX elements.
App.jsNoPortalExample.jsPortalExample.jsModalContent.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
import NoPortalExample from './NoPortalExample';
import PortalExample from './PortalExample';

export default function App() {
 return (
   <>
     <div className="clipping-container">
       <NoPortalExample  />
     </div>
     <div className="clipping-container">
       <PortalExample />
     </div>
   </>
 );
}

Pitfall
It’s important to make sure that your app is accessible when using portals. For instance, you may need to manage keyboard focus so that the user can move the focus in and out of the portal in a natural way.
Follow the WAI-ARIA Modal Authoring Practices when creating modals. If you use a community package, ensure that it is accessible and follows these guidelines.

Rendering React components into non-React server markup 
Portals can be useful if your React root is only part of a static or server-rendered page that isn’t built with React. For example, if your page is built with a server framework like Rails, you can create areas of interactivity within static areas such as sidebars. Compared with having multiple separate React roots, portals let you treat the app as a single React tree with shared state even though its parts render to different parts of the DOM.
index.jsindex.htmlApp.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
import { createPortal } from 'react-dom';

const sidebarContentEl = document.getElementById('sidebar-content');

export default function App() {
 return (
   <>
     <MainContent />
     {createPortal(
       <SidebarContent />,
       sidebarContentEl
     )}
   </>
 );
}

function MainContent() {
 return <p>This part is rendered by React</p>;
}

function SidebarContent() {
 return <p>This part is also rendered by React!</p>;
}

Show more

Rendering React components into non-React DOM nodes 
You can also use a portal to manage the content of a DOM node that’s managed outside of React. For example, suppose you’re integrating with a non-React map widget and you want to render React content inside a popup. To do this, declare a popupContainer state variable to store the DOM node you’re going to render into:
const [popupContainer, setPopupContainer] = useState(null);
When you create the third-party widget, store the DOM node returned by the widget so you can render into it:
useEffect(() => {
 if (mapRef.current === null) {
   const map = createMapWidget(containerRef.current);
   mapRef.current = map;
   const popupDiv = addPopupToMapWidget(map);
   setPopupContainer(popupDiv);
 }
}, []);
This lets you use createPortal to render React content into popupContainer once it becomes available:
return (
 <div style={{ width: 250, height: 250 }} ref={containerRef}>
   {popupContainer !== null && createPortal(
     <p>Hello from React!</p>,
     popupContainer
   )}
 </div>
);
Here is a complete example you can play with:
App.jsmap-widget.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
import { useRef, useEffect, useState } from 'react';
import { createPortal } from 'react-dom';
import { createMapWidget, addPopupToMapWidget } from './map-widget.js';

export default function Map() {
 const containerRef = useRef(null);
 const mapRef = useRef(null);
 const [popupContainer, setPopupContainer] = useState(null);

 useEffect(() => {
   if (mapRef.current === null) {
     const map = createMapWidget(containerRef.current);
     mapRef.current = map;
     const popupDiv = addPopupToMapWidget(map);
     setPopupContainer(popupDiv);
   }
 }, []);

 return (
   <div style={{ width: 250, height: 250 }} ref={containerRef}>
     {popupContainer !== null && createPortal(
       <p>Hello from React!</p>,
       popupContainer
     )}
   </div>
 );
}

Show more

flushSync
Pitfall
Using flushSync is uncommon and can hurt the performance of your app.
flushSync lets you force React to flush any updates inside the provided callback synchronously. This ensures that the DOM is updated immediately.
flushSync(callback)
Reference
flushSync(callback)
Usage
Flushing updates for third-party integrations

Reference 
flushSync(callback) 
Call flushSync to force React to flush any pending work and update the DOM synchronously.
import { flushSync } from 'react-dom';

flushSync(() => {
 setSomething(123);
});
Most of the time, flushSync can be avoided. Use flushSync as last resort.
See more examples below.
Parameters 
callback: A function. React will immediately call this callback and flush any updates it contains synchronously. It may also flush any pending updates, or Effects, or updates inside of Effects. If an update suspends as a result of this flushSync call, the fallbacks may be re-shown.
Returns 
flushSync returns undefined.
Caveats 
flushSync can significantly hurt performance. Use sparingly.
flushSync may force pending Suspense boundaries to show their fallback state.
flushSync may run pending Effects and synchronously apply any updates they contain before returning.
flushSync may flush updates outside the callback when necessary to flush the updates inside the callback. For example, if there are pending updates from a click, React may flush those before flushing the updates inside the callback.

Usage 
Flushing updates for third-party integrations 
When integrating with third-party code such as browser APIs or UI libraries, it may be necessary to force React to flush updates. Use flushSync to force React to flush any state updates inside the callback synchronously:
flushSync(() => {
 setSomething(123);
});
// By this line, the DOM is updated.
This ensures that, by the time the next line of code runs, React has already updated the DOM.
Using flushSync is uncommon, and using it often can significantly hurt the performance of your app. If your app only uses React APIs, and does not integrate with third-party libraries, flushSync should be unnecessary.
However, it can be helpful for integrating with third-party code like browser APIs.
Some browser APIs expect results inside of callbacks to be written to the DOM synchronously, by the end of the callback, so the browser can do something with the rendered DOM. In most cases, React handles this for you automatically. But in some cases it may be necessary to force a synchronous update.
For example, the browser onbeforeprint API allows you to change the page immediately before the print dialog opens. This is useful for applying custom print styles that allow the document to display better for printing. In the example below, you use flushSync inside of the onbeforeprint callback to immediately “flush” the React state to the DOM. Then, by the time the print dialog opens, isPrinting displays “yes”:
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
import { useState, useEffect } from 'react';
import { flushSync } from 'react-dom';

export default function PrintApp() {
 const [isPrinting, setIsPrinting] = useState(false);

 useEffect(() => {
   function handleBeforePrint() {
     flushSync(() => {
       setIsPrinting(true);
     })
   }

   function handleAfterPrint() {
     setIsPrinting(false);
   }

   window.addEventListener('beforeprint', handleBeforePrint);
   window.addEventListener('afterprint', handleAfterPrint);
   return () => {
     window.removeEventListener('beforeprint', handleBeforePrint);
     window.removeEventListener('afterprint', handleAfterPrint);
   }
 }, []);

 return (
   <>
     <h1>isPrinting: {isPrinting ? 'yes' : 'no'}</h1>
     <button onClick={() => window.print()}>
       Print
     </button>
   </>
 );
}

Show more
Without flushSync, the print dialog will display isPrinting as “no”. This is because React batches the updates asynchronously and the print dialog is displayed before the state is updated.
Pitfall
flushSync can significantly hurt performance, and may unexpectedly force pending Suspense boundaries to show their fallback state.
Most of the time, flushSync can be avoided, so use flushSync as a last resort.
preconnect
preconnect lets you eagerly connect to a server that you expect to load resources from.
preconnect("https://example.com");
Reference
preconnect(href)
Usage
Preconnecting when rendering
Preconnecting in an event handler

Reference 
preconnect(href) 
To preconnect to a host, call the preconnect function from react-dom.
import { preconnect } from 'react-dom';

function AppRoot() {
 preconnect("https://example.com");
 // ...
}
See more examples below.
The preconnect function provides the browser with a hint that it should open a connection to the given server. If the browser chooses to do so, this can speed up the loading of resources from that server.
Parameters 
href: a string. The URL of the server you want to connect to.
Returns 
preconnect returns nothing.
Caveats 
Multiple calls to preconnect with the same server have the same effect as a single call.
In the browser, you can call preconnect in any situation: while rendering a component, in an Effect, in an event handler, and so on.
In server-side rendering or when rendering Server Components, preconnect only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.
If you know the specific resources you’ll need, you can call other functions instead that will start loading the resources right away.
There is no benefit to preconnecting to the same server the webpage itself is hosted from because it’s already been connected to by the time the hint would be given.

Usage 
Preconnecting when rendering 
Call preconnect when rendering a component if you know that its children will load external resources from that host.
import { preconnect } from 'react-dom';

function AppRoot() {
 preconnect("https://example.com");
 return ...;
}
Preconnecting in an event handler 
Call preconnect in an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.
import { preconnect } from 'react-dom';

function CallToAction() {
 const onClick = () => {
   preconnect('http://example.com');
   startWizard();
 }
 return (
   <button onClick={onClick}>Start Wizard</button>
 );
}

prefetchDNS
prefetchDNS lets you eagerly look up the IP of a server that you expect to load resources from.
prefetchDNS("https://example.com");
Reference
prefetchDNS(href)
Usage
Prefetching DNS when rendering
Prefetching DNS in an event handler

Reference 
prefetchDNS(href) 
To look up a host, call the prefetchDNS function from react-dom.
import { prefetchDNS } from 'react-dom';

function AppRoot() {
 prefetchDNS("https://example.com");
 // ...
}
See more examples below.
The prefetchDNS function provides the browser with a hint that it should look up the IP address of a given server. If the browser chooses to do so, this can speed up the loading of resources from that server.
Parameters 
href: a string. The URL of the server you want to connect to.
Returns 
prefetchDNS returns nothing.
Caveats 
Multiple calls to prefetchDNS with the same server have the same effect as a single call.
In the browser, you can call prefetchDNS in any situation: while rendering a component, in an Effect, in an event handler, and so on.
In server-side rendering or when rendering Server Components, prefetchDNS only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.
If you know the specific resources you’ll need, you can call other functions instead that will start loading the resources right away.
There is no benefit to prefetching the same server the webpage itself is hosted from because it’s already been looked up by the time the hint would be given.
Compared with preconnect, prefetchDNS may be better if you are speculatively connecting to a large number of domains, in which case the overhead of preconnections might outweigh the benefit.

Usage 
Prefetching DNS when rendering 
Call prefetchDNS when rendering a component if you know that its children will load external resources from that host.
import { prefetchDNS } from 'react-dom';

function AppRoot() {
 prefetchDNS("https://example.com");
 return ...;
}
Prefetching DNS in an event handler 
Call prefetchDNS in an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.
import { prefetchDNS } from 'react-dom';

function CallToAction() {
 const onClick = () => {
   prefetchDNS('http://example.com');
   startWizard();
 }
 return (
   <button onClick={onClick}>Start Wizard</button>
 );
}

preinit
Note
React-based frameworks frequently handle resource loading for you, so you might not have to call this API yourself. Consult your framework’s documentation for details.
preinit lets you eagerly fetch and evaluate a stylesheet or external script.
preinit("https://example.com/script.js", {as: "script"});
Reference
preinit(href, options)
Usage
Preiniting when rendering
Preiniting in an event handler

Reference 
preinit(href, options) 
To preinit a script or stylesheet, call the preinit function from react-dom.
import { preinit } from 'react-dom';

function AppRoot() {
 preinit("https://example.com/script.js", {as: "script"});
 // ...
}
See more examples below.
The preinit function provides the browser with a hint that it should start downloading and executing the given resource, which can save time. Scripts that you preinit are executed when they finish downloading. Stylesheets that you preinit are inserted into the document, which causes them to go into effect right away.
Parameters 
href: a string. The URL of the resource you want to download and execute.
options: an object. It contains the following properties:
as: a required string. The type of resource. Its possible values are script and style.
precedence: a string. Required with stylesheets. Says where to insert the stylesheet relative to others. Stylesheets with higher precedence can override those with lower precedence. The possible values are reset, low, medium, high.
crossOrigin: a string. The CORS policy to use. Its possible values are anonymous and use-credentials.
integrity: a string. A cryptographic hash of the resource, to verify its authenticity.
nonce: a string. A cryptographic nonce to allow the resource when using a strict Content Security Policy.
fetchPriority: a string. Suggests a relative priority for fetching the resource. The possible values are auto (the default), high, and low.
Returns 
preinit returns nothing.
Caveats 
Multiple calls to preinit with the same href have the same effect as a single call.
In the browser, you can call preinit in any situation: while rendering a component, in an Effect, in an event handler, and so on.
In server-side rendering or when rendering Server Components, preinit only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.

Usage 
Preiniting when rendering 
Call preinit when rendering a component if you know that it or its children will use a specific resource, and you’re OK with the resource being evaluated and thereby taking effect immediately upon being downloaded.
Examples of preiniting
1. Preiniting an external script2. Preiniting a stylesheet
Example 1 of 2: Preiniting an external script 
import { preinit } from 'react-dom';

function AppRoot() {
 preinit("https://example.com/script.js", {as: "script"});
 return ...;
}
If you want the browser to download the script but not to execute it right away, use preload instead. If you want to load an ESM module, use preinitModule.
Next Example
Preiniting in an event handler 
Call preinit in an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.
import { preinit } from 'react-dom';

function CallToAction() {
 const onClick = () => {
   preinit("https://example.com/wizardStyles.css", {as: "style"});
   startWizard();
 }
 return (
   <button onClick={onClick}>Start Wizard</button>
 );
}

preinitModule
Note
React-based frameworks frequently handle resource loading for you, so you might not have to call this API yourself. Consult your framework’s documentation for details.
preinitModule lets you eagerly fetch and evaluate an ESM module.
preinitModule("https://example.com/module.js", {as: "script"});
Reference
preinitModule(href, options)
Usage
Preloading when rendering
Preloading in an event handler

Reference 
preinitModule(href, options) 
To preinit an ESM module, call the preinitModule function from react-dom.
import { preinitModule } from 'react-dom';

function AppRoot() {
 preinitModule("https://example.com/module.js", {as: "script"});
 // ...
}
See more examples below.
The preinitModule function provides the browser with a hint that it should start downloading and executing the given module, which can save time. Modules that you preinit are executed when they finish downloading.
Parameters 
href: a string. The URL of the module you want to download and execute.
options: an object. It contains the following properties:
as: a required string. It must be 'script'.
crossOrigin: a string. The CORS policy to use. Its possible values are anonymous and use-credentials.
integrity: a string. A cryptographic hash of the module, to verify its authenticity.
nonce: a string. A cryptographic nonce to allow the module when using a strict Content Security Policy.
Returns 
preinitModule returns nothing.
Caveats 
Multiple calls to preinitModule with the same href have the same effect as a single call.
In the browser, you can call preinitModule in any situation: while rendering a component, in an Effect, in an event handler, and so on.
In server-side rendering or when rendering Server Components, preinitModule only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.

Usage 
Preloading when rendering 
Call preinitModule when rendering a component if you know that it or its children will use a specific module and you’re OK with the module being evaluated and thereby taking effect immediately upon being downloaded.
import { preinitModule } from 'react-dom';

function AppRoot() {
 preinitModule("https://example.com/module.js", {as: "script"});
 return ...;
}
If you want the browser to download the module but not to execute it right away, use preloadModule instead. If you want to preinit a script that isn’t an ESM module, use preinit.
Preloading in an event handler 
Call preinitModule in an event handler before transitioning to a page or state where the module will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.
import { preinitModule } from 'react-dom';

function CallToAction() {
 const onClick = () => {
   preinitModule("https://example.com/module.js", {as: "script"});
   startWizard();
 }
 return (
   <button onClick={onClick}>Start Wizard</button>
 );
}

preload
Note
React-based frameworks frequently handle resource loading for you, so you might not have to call this API yourself. Consult your framework’s documentation for details.
preload lets you eagerly fetch a resource such as a stylesheet, font, or external script that you expect to use.
preload("https://example.com/font.woff2", {as: "font"});
Reference
preload(href, options)
Usage
Preloading when rendering
Preloading in an event handler

Reference 
preload(href, options) 
To preload a resource, call the preload function from react-dom.
import { preload } from 'react-dom';

function AppRoot() {
 preload("https://example.com/font.woff2", {as: "font"});
 // ...
}
See more examples below.
The preload function provides the browser with a hint that it should start downloading the given resource, which can save time.
Parameters 
href: a string. The URL of the resource you want to download.
options: an object. It contains the following properties:
as: a required string. The type of resource. Its possible values are audio, document, embed, fetch, font, image, object, script, style, track, video, worker.
crossOrigin: a string. The CORS policy to use. Its possible values are anonymous and use-credentials. It is required when as is set to "fetch".
referrerPolicy: a string. The Referrer header to send when fetching. Its possible values are no-referrer-when-downgrade (the default), no-referrer, origin, origin-when-cross-origin, and unsafe-url.
integrity: a string. A cryptographic hash of the resource, to verify its authenticity.
type: a string. The MIME type of the resource.
nonce: a string. A cryptographic nonce to allow the resource when using a strict Content Security Policy.
fetchPriority: a string. Suggests a relative priority for fetching the resource. The possible values are auto (the default), high, and low.
imageSrcSet: a string. For use only with as: "image". Specifies the source set of the image.
imageSizes: a string. For use only with as: "image". Specifies the sizes of the image.
Returns 
preload returns nothing.
Caveats 
Multiple equivalent calls to preload have the same effect as a single call. Calls to preload are considered equivalent according to the following rules:
Two calls are equivalent if they have the same href, except:
If as is set to image, two calls are equivalent if they have the same href, imageSrcSet, and imageSizes.
In the browser, you can call preload in any situation: while rendering a component, in an Effect, in an event handler, and so on.
In server-side rendering or when rendering Server Components, preload only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.

Usage 
Preloading when rendering 
Call preload when rendering a component if you know that it or its children will use a specific resource.
Examples of preloading
1. Preloading an external script2. Preloading a stylesheet3. Preloading a font4. Preloading an image
Example 1 of 4: Preloading an external script 
import { preload } from 'react-dom';

function AppRoot() {
 preload("https://example.com/script.js", {as: "script"});
 return ...;
}
If you want the browser to start executing the script immediately (rather than just downloading it), use preinit instead. If you want to load an ESM module, use preloadModule.
Next Example
Preloading in an event handler 
Call preload in an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.
import { preload } from 'react-dom';

function CallToAction() {
 const onClick = () => {
   preload("https://example.com/wizardStyles.css", {as: "style"});
   startWizard();
 }
 return (
   <button onClick={onClick}>Start Wizard</button>
 );
}
Example 2 of 4: Preloading a stylesheet 
import { preload } from 'react-dom';

function AppRoot() {
 preload("https://example.com/style.css", {as: "style"});
 return ...;
}
If you want the stylesheet to be inserted into the document immediately (which means the browser will start parsing it immediately rather than just downloading it), use preinit instead.
Next Example
Example 3 of 4: Preloading a font 
import { preload } from 'react-dom';

function AppRoot() {
 preload("https://example.com/style.css", {as: "style"});
 preload("https://example.com/font.woff2", {as: "font"});
 return ...;
}
If you preload a stylesheet, it’s smart to also preload any fonts that the stylesheet refers to. That way, the browser can start downloading the font before it’s downloaded and parsed the stylesheet.
Next Example
4. Preloading an image

preloadModule
Note
React-based frameworks frequently handle resource loading for you, so you might not have to call this API yourself. Consult your framework’s documentation for details.
preloadModule lets you eagerly fetch an ESM module that you expect to use.
preloadModule("https://example.com/module.js", {as: "script"});
Reference
preloadModule(href, options)
Usage
Preloading when rendering
Preloading in an event handler

Reference 
preloadModule(href, options) 
To preload an ESM module, call the preloadModule function from react-dom.
import { preloadModule } from 'react-dom';

function AppRoot() {
 preloadModule("https://example.com/module.js", {as: "script"});
 // ...
}
See more examples below.
The preloadModule function provides the browser with a hint that it should start downloading the given module, which can save time.
Parameters 
href: a string. The URL of the module you want to download.
options: an object. It contains the following properties:
as: a required string. It must be 'script'.
crossOrigin: a string. The CORS policy to use. Its possible values are anonymous and use-credentials.
integrity: a string. A cryptographic hash of the module, to verify its authenticity.
nonce: a string. A cryptographic nonce to allow the module when using a strict Content Security Policy.
Returns 
preloadModule returns nothing.
Caveats 
Multiple calls to preloadModule with the same href have the same effect as a single call.
In the browser, you can call preloadModule in any situation: while rendering a component, in an Effect, in an event handler, and so on.
In server-side rendering or when rendering Server Components, preloadModule only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.

Usage 
Preloading when rendering 
Call preloadModule when rendering a component if you know that it or its children will use a specific module.
import { preloadModule } from 'react-dom';

function AppRoot() {
 preloadModule("https://example.com/module.js", {as: "script"});
 return ...;
}
If you want the browser to start executing the module immediately (rather than just downloading it), use preinitModule instead. If you want to load a script that isn’t an ESM module, use preload.
Preloading in an event handler 
Call preloadModule in an event handler before transitioning to a page or state where the module will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.
import { preloadModule } from 'react-dom';

function CallToAction() {
 const onClick = () => {
   preloadModule("https://example.com/module.js", {as: "script"});
   startWizard();
 }
 return (
   <button onClick={onClick}>Start Wizard</button>
 );
}

lient React DOM APIs
The react-dom/client APIs let you render React components on the client (in the browser). These APIs are typically used at the top level of your app to initialize your React tree. A framework may call them for you. Most of your components don’t need to import or use them.

Client APIs 
createRoot lets you create a root to display React components inside a browser DOM node.
hydrateRoot lets you display React components inside a browser DOM node whose HTML content was previously generated by react-dom/server.

Browser support 
React supports all popular browsers, including Internet Explorer 9 and above. Some polyfills are required for older browsers such as IE 9 and IE 10.
createRoot
createRoot lets you create a root to display React components inside a browser DOM node.
const root = createRoot(domNode, options?)
Reference
createRoot(domNode, options?)
root.render(reactNode)
root.unmount()
Usage
Rendering an app fully built with React
Rendering a page partially built with React
Updating a root component
Error logging in production
Troubleshooting
I’ve created a root, but nothing is displayed
I’m getting an error: “You passed a second argument to root.render”
I’m getting an error: “Target container is not a DOM element”
I’m getting an error: “Functions are not valid as a React child.”
My server-rendered HTML gets re-created from scratch

Reference 
createRoot(domNode, options?) 
Call createRoot to create a React root for displaying content inside a browser DOM element.
import { createRoot } from 'react-dom/client';

const domNode = document.getElementById('root');
const root = createRoot(domNode);
React will create a root for the domNode, and take over managing the DOM inside it. After you’ve created a root, you need to call root.render to display a React component inside of it:
root.render(<App />);
An app fully built with React will usually only have one createRoot call for its root component. A page that uses “sprinkles” of React for parts of the page may have as many separate roots as needed.
See more examples below.
Parameters 
domNode: A DOM element. React will create a root for this DOM element and allow you to call functions on the root, such as render to display rendered React content.
optional options: An object with options for this React root.
optional onCaughtError: Callback called when React catches an error in an Error Boundary. Called with the error caught by the Error Boundary, and an errorInfo object containing the componentStack.
optional onUncaughtError: Callback called when an error is thrown and not caught by an Error Boundary. Called with the error that was thrown, and an errorInfo object containing the componentStack.
optional onRecoverableError: Callback called when React automatically recovers from errors. Called with an error React throws, and an errorInfo object containing the componentStack. Some recoverable errors may include the original error cause as error.cause.
optional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page.
Returns 
createRoot returns an object with two methods: render and unmount.
Caveats 
If your app is server-rendered, using createRoot() is not supported. Use hydrateRoot() instead.
You’ll likely have only one createRoot call in your app. If you use a framework, it might do this call for you.
When you want to render a piece of JSX in a different part of the DOM tree that isn’t a child of your component (for example, a modal or a tooltip), use createPortal instead of createRoot.

root.render(reactNode) 
Call root.render to display a piece of JSX (“React node”) into the React root’s browser DOM node.
root.render(<App />);
React will display <App /> in the root, and take over managing the DOM inside it.
See more examples below.
Parameters 
reactNode: A React node that you want to display. This will usually be a piece of JSX like <App />, but you can also pass a React element constructed with createElement(), a string, a number, null, or undefined.
Returns 
root.render returns undefined.
Caveats 
The first time you call root.render, React will clear all the existing HTML content inside the React root before rendering the React component into it.
If your root’s DOM node contains HTML generated by React on the server or during the build, use hydrateRoot() instead, which attaches the event handlers to the existing HTML.
If you call render on the same root more than once, React will update the DOM as necessary to reflect the latest JSX you passed. React will decide which parts of the DOM can be reused and which need to be recreated by “matching it up” with the previously rendered tree. Calling render on the same root again is similar to calling the set function on the root component: React avoids unnecessary DOM updates.
Although rendering is synchronous once it starts, root.render(...) is not. This means code after root.render() may run before any effects (useLayoutEffect, useEffect) of that specific render are fired. This is usually fine and rarely needs adjustment. In rare cases where effect timing matters, you can wrap root.render(...) in flushSync to ensure the initial render runs fully synchronously.
const root = createRoot(document.getElementById('root'));
root.render(<App />);
// 🚩 The HTML will not include the rendered <App /> yet:
console.log(document.body.innerHTML);

root.unmount() 
Call root.unmount to destroy a rendered tree inside a React root.
root.unmount();
An app fully built with React will usually not have any calls to root.unmount.
This is mostly useful if your React root’s DOM node (or any of its ancestors) may get removed from the DOM by some other code. For example, imagine a jQuery tab panel that removes inactive tabs from the DOM. If a tab gets removed, everything inside it (including the React roots inside) would get removed from the DOM as well. In that case, you need to tell React to “stop” managing the removed root’s content by calling root.unmount. Otherwise, the components inside the removed root won’t know to clean up and free up global resources like subscriptions.
Calling root.unmount will unmount all the components in the root and “detach” React from the root DOM node, including removing any event handlers or state in the tree.
Parameters 
root.unmount does not accept any parameters.
Returns 
root.unmount returns undefined.
Caveats 
Calling root.unmount will unmount all the components in the tree and “detach” React from the root DOM node.
Once you call root.unmount you cannot call root.render again on the same root. Attempting to call root.render on an unmounted root will throw a “Cannot update an unmounted root” error. However, you can create a new root for the same DOM node after the previous root for that node has been unmounted.

Usage 
Rendering an app fully built with React 
If your app is fully built with React, create a single root for your entire app.
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'));
root.render(<App />);
Usually, you only need to run this code once at startup. It will:
Find the browser DOM node defined in your HTML.
Display the React component for your app inside.
index.jsindex.htmlApp.js
Reset
Fork
1
2
3
4
5
6
7
import { createRoot } from 'react-dom/client';
import App from './App.js';
import './styles.css';

const root = createRoot(document.getElementById('root'));
root.render(<App />);

If your app is fully built with React, you shouldn’t need to create any more roots, or to call root.render again.
From this point on, React will manage the DOM of your entire app. To add more components, nest them inside the App component. When you need to update the UI, each of your components can do this by using state. When you need to display extra content like a modal or a tooltip outside the DOM node, render it with a portal.
Note
When your HTML is empty, the user sees a blank page until the app’s JavaScript code loads and runs:
<div id="root"></div>
This can feel very slow! To solve this, you can generate the initial HTML from your components on the server or during the build. Then your visitors can read text, see images, and click links before any of the JavaScript code loads. We recommend using a framework that does this optimization out of the box. Depending on when it runs, this is called server-side rendering (SSR) or static site generation (SSG).
Pitfall
Apps using server rendering or static generation must call hydrateRoot instead of createRoot. React will then hydrate (reuse) the DOM nodes from your HTML instead of destroying and re-creating them.

Rendering a page partially built with React 
If your page isn’t fully built with React, you can call createRoot multiple times to create a root for each top-level piece of UI managed by React. You can display different content in each root by calling root.render.
Here, two different React components are rendered into two DOM nodes defined in the index.html file:
index.jsindex.htmlComponents.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
import './styles.css';
import { createRoot } from 'react-dom/client';
import { Comments, Navigation } from './Components.js';

const navDomNode = document.getElementById('navigation');
const navRoot = createRoot(navDomNode);
navRoot.render(<Navigation />);

const commentDomNode = document.getElementById('comments');
const commentRoot = createRoot(commentDomNode);
commentRoot.render(<Comments />);

You could also create a new DOM node with document.createElement() and add it to the document manually.
const domNode = document.createElement('div');
const root = createRoot(domNode);
root.render(<Comment />);
document.body.appendChild(domNode); // You can add it anywhere in the document
To remove the React tree from the DOM node and clean up all the resources used by it, call root.unmount.
root.unmount();
This is mostly useful if your React components are inside an app written in a different framework.

Updating a root component 
You can call render more than once on the same root. As long as the component tree structure matches up with what was previously rendered, React will preserve the state. Notice how you can type in the input, which means that the updates from repeated render calls every second in this example are not destructive:
index.jsApp.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
import { createRoot } from 'react-dom/client';
import './styles.css';
import App from './App.js';

const root = createRoot(document.getElementById('root'));

let i = 0;
setInterval(() => {
 root.render(<App counter={i} />);
 i++;
}, 1000);

It is uncommon to call render multiple times. Usually, your components will update state instead.
Error logging in production 
By default, React will log all errors to the console. To implement your own error reporting, you can provide the optional error handler root options onUncaughtError, onCaughtError and onRecoverableError:
import { createRoot } from "react-dom/client";
import { reportCaughtError } from "./reportError";

const container = document.getElementById("root");
const root = createRoot(container, {
 onCaughtError: (error, errorInfo) => {
   if (error.message !== "Known error") {
     reportCaughtError({
       error,
       componentStack: errorInfo.componentStack,
     });
   }
 },
});
The onCaughtError option is a function called with two arguments:
The error that was thrown.
An errorInfo object that contains the componentStack of the error.
Together with onUncaughtError and onRecoverableError, you can can implement your own error reporting system:
index.jsreportError.jsApp.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
import { createRoot } from "react-dom/client";
import App from "./App.js";
import {
 onCaughtErrorProd,
 onRecoverableErrorProd,
 onUncaughtErrorProd,
} from "./reportError";

const container = document.getElementById("root");
const root = createRoot(container, {
 // Keep in mind to remove these options in development to leverage
 // React's default handlers or implement your own overlay for development.
 // The handlers are only specfied unconditionally here for demonstration purposes.
 onCaughtError: onCaughtErrorProd,
 onRecoverableError: onRecoverableErrorProd,
 onUncaughtError: onUncaughtErrorProd,
});
root.render(<App />);

Show more
Troubleshooting 
I’ve created a root, but nothing is displayed 
Make sure you haven’t forgotten to actually render your app into the root:
import { createRoot } from 'react-dom/client';
import App from './App.js';

const root = createRoot(document.getElementById('root'));
root.render(<App />);
Until you do that, nothing is displayed.

I’m getting an error: “You passed a second argument to root.render” 
A common mistake is to pass the options for createRoot to root.render(...):
Console
Warning: You passed a second argument to root.render(…) but it only accepts one argument.
To fix, pass the root options to createRoot(...), not root.render(...):
// 🚩 Wrong: root.render only takes one argument.
root.render(App, {onUncaughtError});

// ✅ Correct: pass options to createRoot.
const root = createRoot(container, {onUncaughtError});
root.render(<App />);

I’m getting an error: “Target container is not a DOM element” 
This error means that whatever you’re passing to createRoot is not a DOM node.
If you’re not sure what’s happening, try logging it:
const domNode = document.getElementById('root');
console.log(domNode); // ???
const root = createRoot(domNode);
root.render(<App />);
For example, if domNode is null, it means that getElementById returned null. This will happen if there is no node in the document with the given ID at the time of your call. There may be a few reasons for it:
The ID you’re looking for might differ from the ID you used in the HTML file. Check for typos!
Your bundle’s <script> tag cannot “see” any DOM nodes that appear after it in the HTML.
Another common way to get this error is to write createRoot(<App />) instead of createRoot(domNode).

I’m getting an error: “Functions are not valid as a React child.” 
This error means that whatever you’re passing to root.render is not a React component.
This may happen if you call root.render with Component instead of <Component />:
// 🚩 Wrong: App is a function, not a Component.
root.render(App);

// ✅ Correct: <App /> is a component.
root.render(<App />);
Or if you pass a function to root.render, instead of the result of calling it:
// 🚩 Wrong: createApp is a function, not a component.
root.render(createApp);

// ✅ Correct: call createApp to return a component.
root.render(createApp());

My server-rendered HTML gets re-created from scratch 
If your app is server-rendered and includes the initial HTML generated by React, you might notice that creating a root and calling root.render deletes all that HTML, and then re-creates all the DOM nodes from scratch. This can be slower, resets focus and scroll positions, and may lose other user input.
Server-rendered apps must use hydrateRoot instead of createRoot:
import { hydrateRoot } from 'react-dom/client';
import App from './App.js';

hydrateRoot(
 document.getElementById('root'),
 <App />
);
Note that its API is different. In particular, usually there will be no further root.render call.
hydrateRoot
hydrateRoot lets you display React components inside a browser DOM node whose HTML content was previously generated by react-dom/server.
const root = hydrateRoot(domNode, reactNode, options?)
Reference
hydrateRoot(domNode, reactNode, options?)
root.render(reactNode)
root.unmount()
Usage
Hydrating server-rendered HTML
Hydrating an entire document
Suppressing unavoidable hydration mismatch errors
Handling different client and server content
Updating a hydrated root component
Error logging in production
Troubleshooting
I’m getting an error: “You passed a second argument to root.render”

Reference 
hydrateRoot(domNode, reactNode, options?) 
Call hydrateRoot to “attach” React to existing HTML that was already rendered by React in a server environment.
import { hydrateRoot } from 'react-dom/client';

const domNode = document.getElementById('root');
const root = hydrateRoot(domNode, reactNode);
React will attach to the HTML that exists inside the domNode, and take over managing the DOM inside it. An app fully built with React will usually only have one hydrateRoot call with its root component.
See more examples below.
Parameters 
domNode: A DOM element that was rendered as the root element on the server.
reactNode: The “React node” used to render the existing HTML. This will usually be a piece of JSX like <App /> which was rendered with a ReactDOM Server method such as renderToPipeableStream(<App />).
optional options: An object with options for this React root.
optional onCaughtError: Callback called when React catches an error in an Error Boundary. Called with the error caught by the Error Boundary, and an errorInfo object containing the componentStack.
optional onUncaughtError: Callback called when an error is thrown and not caught by an Error Boundary. Called with the error that was thrown and an errorInfo object containing the componentStack.
optional onRecoverableError: Callback called when React automatically recovers from errors. Called with the error React throws, and an errorInfo object containing the componentStack. Some recoverable errors may include the original error cause as error.cause.
optional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as used on the server.
Returns 
hydrateRoot returns an object with two methods: render and unmount.
Caveats 
hydrateRoot() expects the rendered content to be identical with the server-rendered content. You should treat mismatches as bugs and fix them.
In development mode, React warns about mismatches during hydration. There are no guarantees that attribute differences will be patched up in case of mismatches. This is important for performance reasons because in most apps, mismatches are rare, and so validating all markup would be prohibitively expensive.
You’ll likely have only one hydrateRoot call in your app. If you use a framework, it might do this call for you.
If your app is client-rendered with no HTML rendered already, using hydrateRoot() is not supported. Use createRoot() instead.

root.render(reactNode) 
Call root.render to update a React component inside a hydrated React root for a browser DOM element.
root.render(<App />);
React will update <App /> in the hydrated root.
See more examples below.
Parameters 
reactNode: A “React node” that you want to update. This will usually be a piece of JSX like <App />, but you can also pass a React element constructed with createElement(), a string, a number, null, or undefined.
Returns 
root.render returns undefined.
Caveats 
If you call root.render before the root has finished hydrating, React will clear the existing server-rendered HTML content and switch the entire root to client rendering.

root.unmount() 
Call root.unmount to destroy a rendered tree inside a React root.
root.unmount();
An app fully built with React will usually not have any calls to root.unmount.
This is mostly useful if your React root’s DOM node (or any of its ancestors) may get removed from the DOM by some other code. For example, imagine a jQuery tab panel that removes inactive tabs from the DOM. If a tab gets removed, everything inside it (including the React roots inside) would get removed from the DOM as well. You need to tell React to “stop” managing the removed root’s content by calling root.unmount. Otherwise, the components inside the removed root won’t clean up and free up resources like subscriptions.
Calling root.unmount will unmount all the components in the root and “detach” React from the root DOM node, including removing any event handlers or state in the tree.
Parameters 
root.unmount does not accept any parameters.
Returns 
root.unmount returns undefined.
Caveats 
Calling root.unmount will unmount all the components in the tree and “detach” React from the root DOM node.
Once you call root.unmount you cannot call root.render again on the root. Attempting to call root.render on an unmounted root will throw a “Cannot update an unmounted root” error.

Usage 
Hydrating server-rendered HTML 
If your app’s HTML was generated by react-dom/server, you need to hydrate it on the client.
import { hydrateRoot } from 'react-dom/client';

hydrateRoot(document.getElementById('root'), <App />);
This will hydrate the server HTML inside the browser DOM node with the React component for your app. Usually, you will do it once at startup. If you use a framework, it might do this behind the scenes for you.
To hydrate your app, React will “attach” your components’ logic to the initial generated HTML from the server. Hydration turns the initial HTML snapshot from the server into a fully interactive app that runs in the browser.
index.jsindex.htmlApp.js
Reset
Fork
1
2
3
4
5
6
7
8
9
import './styles.css';
import { hydrateRoot } from 'react-dom/client';
import App from './App.js';

hydrateRoot(
 document.getElementById('root'),
 <App />
);

You shouldn’t need to call hydrateRoot again or to call it in more places. From this point on, React will be managing the DOM of your application. To update the UI, your components will use state instead.
Pitfall
The React tree you pass to hydrateRoot needs to produce the same output as it did on the server.
This is important for the user experience. The user will spend some time looking at the server-generated HTML before your JavaScript code loads. Server rendering creates an illusion that the app loads faster by showing the HTML snapshot of its output. Suddenly showing different content breaks that illusion. This is why the server render output must match the initial render output on the client.
The most common causes leading to hydration errors include:
Extra whitespace (like newlines) around the React-generated HTML inside the root node.
Using checks like typeof window !== 'undefined' in your rendering logic.
Using browser-only APIs like window.matchMedia in your rendering logic.
Rendering different data on the server and the client.
React recovers from some hydration errors, but you must fix them like other bugs. In the best case, they’ll lead to a slowdown; in the worst case, event handlers can get attached to the wrong elements.

Hydrating an entire document 
Apps fully built with React can render the entire document as JSX, including the <html> tag:
function App() {
 return (
   <html>
     <head>
       <meta charSet="utf-8" />
       <meta name="viewport" content="width=device-width, initial-scale=1" />
       <link rel="stylesheet" href="/styles.css"></link>
       <title>My app</title>
     </head>
     <body>
       <Router />
     </body>
   </html>
 );
}
To hydrate the entire document, pass the document global as the first argument to hydrateRoot:
import { hydrateRoot } from 'react-dom/client';
import App from './App.js';

hydrateRoot(document, <App />);

Suppressing unavoidable hydration mismatch errors 
If a single element’s attribute or text content is unavoidably different between the server and the client (for example, a timestamp), you may silence the hydration mismatch warning.
To silence hydration warnings on an element, add suppressHydrationWarning={true}:
index.jsindex.htmlApp.js
Reset
Fork
1
2
3
4
5
6
7
8
export default function App() {
 return (
   <h1 suppressHydrationWarning={true}>
     Current Date: {new Date().toLocaleDateString()}
   </h1>
 );
}

This only works one level deep, and is intended to be an escape hatch. Don’t overuse it. React will not attempt to patch mismatched text content.

Handling different client and server content 
If you intentionally need to render something different on the server and the client, you can do a two-pass rendering. Components that render something different on the client can read a state variable like isClient, which you can set to true in an Effect:
index.jsindex.htmlApp.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
import { useState, useEffect } from "react";

export default function App() {
 const [isClient, setIsClient] = useState(false);

 useEffect(() => {
   setIsClient(true);
 }, []);

 return (
   <h1>
     {isClient ? 'Is Client' : 'Is Server'}
   </h1>
 );
}

This way the initial render pass will render the same content as the server, avoiding mismatches, but an additional pass will happen synchronously right after hydration.
Pitfall
This approach makes hydration slower because your components have to render twice. Be mindful of the user experience on slow connections. The JavaScript code may load significantly later than the initial HTML render, so rendering a different UI immediately after hydration may also feel jarring to the user.

Updating a hydrated root component 
After the root has finished hydrating, you can call root.render to update the root React component. Unlike with createRoot, you don’t usually need to do this because the initial content was already rendered as HTML.
If you call root.render at some point after hydration, and the component tree structure matches up with what was previously rendered, React will preserve the state. Notice how you can type in the input, which means that the updates from repeated render calls every second in this example are not destructive:
index.jsindex.htmlApp.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
import { hydrateRoot } from 'react-dom/client';
import './styles.css';
import App from './App.js';

const root = hydrateRoot(
 document.getElementById('root'),
 <App counter={0} />
);

let i = 0;
setInterval(() => {
 root.render(<App counter={i} />);
 i++;
}, 1000);

It is uncommon to call root.render on a hydrated root. Usually, you’ll update state inside one of the components instead.
Error logging in production 
By default, React will log all errors to the console. To implement your own error reporting, you can provide the optional error handler root options onUncaughtError, onCaughtError and onRecoverableError:
import { hydrateRoot } from "react-dom/client";
import App from "./App.js";
import { reportCaughtError } from "./reportError";

const container = document.getElementById("root");
const root = hydrateRoot(container, <App />, {
 onCaughtError: (error, errorInfo) => {
   if (error.message !== "Known error") {
     reportCaughtError({
       error,
       componentStack: errorInfo.componentStack,
     });
   }
 },
});
The onCaughtError option is a function called with two arguments:
The error that was thrown.
An errorInfo object that contains the componentStack of the error.
Together with onUncaughtError and onRecoverableError, you can implement your own error reporting system:
index.jsreportError.jsApp.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
import { hydrateRoot } from "react-dom/client";
import App from "./App.js";
import {
 onCaughtErrorProd,
 onRecoverableErrorProd,
 onUncaughtErrorProd,
} from "./reportError";

const container = document.getElementById("root");
hydrateRoot(container, <App />, {
 // Keep in mind to remove these options in development to leverage
 // React's default handlers or implement your own overlay for development.
 // The handlers are only specfied unconditionally here for demonstration purposes.
 onCaughtError: onCaughtErrorProd,
 onRecoverableError: onRecoverableErrorProd,
 onUncaughtError: onUncaughtErrorProd,
});

Console (2)
Recoverable Error: Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:

- A server/client branch `if (typeof window !== 'undefined')`.
- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.
- Date formatting in a user's locale which doesn't match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.

https://react.dev/link/hydration-mismatch

  <App>
+   <button onClick={function onClick}>
-   Server content before hydration.
    ...

    at throwOnHydrationMismatch (https://786946de.sandpack-bundler-4bw.pages.dev/node_modules/react-dom/cjs/react-dom-client.development.js:11:106063)
    at beginWork (https://786946de.sandpack-bundler-4bw.pages.dev/node_modules/react-dom/cjs/react-dom-client.development.js:11:272443)
    at runWithFiberInDEV (https://786946de.sandpack-bundler-4bw.pages.dev/node_modules/react-dom/cjs/react-dom-client.development.js:11:19643)
    at performUnitOfWork (https://786946de.sandpack-bundler-4bw.pages.dev/node_modules/react-dom/cjs/react-dom-client.development.js:11:384335)
    at workLoopSync (https://786946de.sandpack-bundler-4bw.pages.dev/node_modules/react-dom/cjs/react-dom-client.development.js:11:380104)
    at renderRootSync (https://786946de.sandpack-bundler-4bw.pages.dev/node_modules/react-dom/cjs/react-dom-client.development.js:11:379580)
    at performWorkOnRoot (https://786946de.sandpack-bundler-4bw.pages.dev/node_modules/react-dom/cjs/react-dom-client.development.js:11:366905)
    at performWorkOnRootViaSchedulerTask (https://786946de.sandpack-bundler-4bw.pages.dev/node_modules/react-dom/cjs/react-dom-client.development.js:11:414241)
    at MessagePort.performWorkUntilDeadline (https://786946de.sandpack-bundler-4bw.pages.dev/node_modules/scheduler/cjs/scheduler.development.js:9:704) Component Stack:
Component Stack:  
    at button (<anonymous>)
    at App (https://786946de.sandpack-bundler-4bw.pages.dev/src/App.js:46:79)
Show more
Troubleshooting 
I’m getting an error: “You passed a second argument to root.render” 
A common mistake is to pass the options for hydrateRoot to root.render(...):
Console
Warning: You passed a second argument to root.render(…) but it only accepts one argument.
To fix, pass the root options to hydrateRoot(...), not root.render(...):
// 🚩 Wrong: root.render only takes one argument.
root.render(App, {onUncaughtError});

// ✅ Correct: pass options to createRoot.
const root = hydrateRoot(container, <App />, {onUncaughtError});
Server React DOM APIs
The react-dom/server APIs let you server-side render React components to HTML. These APIs are only used on the server at the top level of your app to generate the initial HTML. A framework may call them for you. Most of your components don’t need to import or use them.

Server APIs for Node.js Streams 
These methods are only available in the environments with Node.js Streams:
renderToPipeableStream renders a React tree to a pipeable Node.js Stream.

Server APIs for Web Streams 
These methods are only available in the environments with Web Streams, which includes browsers, Deno, and some modern edge runtimes:
renderToReadableStream renders a React tree to a Readable Web Stream.

Legacy Server APIs for non-streaming environments 
These methods can be used in the environments that don’t support streams:
renderToString renders a React tree to a string.
renderToStaticMarkup renders a non-interactive React tree to a string.
They have limited functionality compared to the streaming APIs.
renderToPipeableStream
renderToPipeableStream renders a React tree to a pipeable Node.js Stream.
const { pipe, abort } = renderToPipeableStream(reactNode, options?)
Reference
renderToPipeableStream(reactNode, options?)
Usage
Rendering a React tree as HTML to a Node.js Stream
Streaming more content as it loads
Specifying what goes into the shell
Logging crashes on the server
Recovering from errors inside the shell
Recovering from errors outside the shell
Setting the status code
Handling different errors in different ways
Waiting for all content to load for crawlers and static generation
Aborting server rendering
Note
This API is specific to Node.js. Environments with Web Streams, like Deno and modern edge runtimes, should use renderToReadableStream instead.

Reference 
renderToPipeableStream(reactNode, options?) 
Call renderToPipeableStream to render your React tree as HTML into a Node.js Stream.
import { renderToPipeableStream } from 'react-dom/server';

const { pipe } = renderToPipeableStream(<App />, {
 bootstrapScripts: ['/main.js'],
 onShellReady() {
   response.setHeader('content-type', 'text/html');
   pipe(response);
 }
});
On the client, call hydrateRoot to make the server-generated HTML interactive.
See more examples below.
Parameters 
reactNode: A React node you want to render to HTML. For example, a JSX element like <App />. It is expected to represent the entire document, so the App component should render the <html> tag.
optional options: An object with streaming options.
optional bootstrapScriptContent: If specified, this string will be placed in an inline <script> tag.
optional bootstrapScripts: An array of string URLs for the <script> tags to emit on the page. Use this to include the <script> that calls hydrateRoot. Omit it if you don’t want to run React on the client at all.
optional bootstrapModules: Like bootstrapScripts, but emits <script type="module"> instead.
optional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to hydrateRoot.
optional namespaceURI: A string with the root namespace URI for the stream. Defaults to regular HTML. Pass 'http://www.w3.org/2000/svg' for SVG or 'http://www.w3.org/1998/Math/MathML' for MathML.
optional nonce: A nonce string to allow scripts for script-src Content-Security-Policy.
optional onAllReady: A callback that fires when all rendering is complete, including both the shell and all additional content. You can use this instead of onShellReady for crawlers and static generation. If you start streaming here, you won’t get any progressive loading. The stream will contain the final HTML.
optional onError: A callback that fires whenever there is a server error, whether recoverable or not. By default, this only calls console.error. If you override it to log crash reports, make sure that you still call console.error. You can also use it to adjust the status code before the shell is emitted.
optional onShellReady: A callback that fires right after the initial shell has been rendered. You can set the status code and call pipe here to start streaming. React will stream the additional content after the shell along with the inline <script> tags that replace the HTML loading fallbacks with the content.
optional onShellError: A callback that fires if there was an error rendering the initial shell. It receives the error as an argument. No bytes were emitted from the stream yet, and neither onShellReady nor onAllReady will get called, so you can output a fallback HTML shell.
optional progressiveChunkSize: The number of bytes in a chunk. Read more about the default heuristic.
Returns 
renderToPipeableStream returns an object with two methods:
pipe outputs the HTML into the provided Writable Node.js Stream. Call pipe in onShellReady if you want to enable streaming, or in onAllReady for crawlers and static generation.
abort lets you abort server rendering and render the rest on the client.

Usage 
Rendering a React tree as HTML to a Node.js Stream 
Call renderToPipeableStream to render your React tree as HTML into a Node.js Stream:
import { renderToPipeableStream } from 'react-dom/server';

// The route handler syntax depends on your backend framework
app.use('/', (request, response) => {
 const { pipe } = renderToPipeableStream(<App />, {
   bootstrapScripts: ['/main.js'],
   onShellReady() {
     response.setHeader('content-type', 'text/html');
     pipe(response);
   }
 });
});
Along with the root component, you need to provide a list of bootstrap <script> paths. Your root component should return the entire document including the root <html> tag.
For example, it might look like this:
export default function App() {
 return (
   <html>
     <head>
       <meta charSet="utf-8" />
       <meta name="viewport" content="width=device-width, initial-scale=1" />
       <link rel="stylesheet" href="/styles.css"></link>
       <title>My app</title>
     </head>
     <body>
       <Router />
     </body>
   </html>
 );
}
React will inject the doctype and your bootstrap <script> tags into the resulting HTML stream:
<!DOCTYPE html>
<html>
 <!-- ... HTML from your components ... -->
</html>
<script src="/main.js" async=""></script>
On the client, your bootstrap script should hydrate the entire document with a call to hydrateRoot:
import { hydrateRoot } from 'react-dom/client';
import App from './App.js';

hydrateRoot(document, <App />);
This will attach event listeners to the server-generated HTML and make it interactive.
Deep Dive
Reading CSS and JS asset paths from the build output 
Show Details













































Streaming more content as it loads 
Streaming allows the user to start seeing the content even before all the data has loaded on the server. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:
function ProfilePage() {
 return (
   <ProfileLayout>
     <ProfileCover />
     <Sidebar>
       <Friends />
       <Photos />
     </Sidebar>
     <Posts />
   </ProfileLayout>
 );
}
Imagine that loading data for <Posts /> takes some time. Ideally, you’d want to show the rest of the profile page content to the user without waiting for the posts. To do this, wrap Posts in a <Suspense> boundary:
function ProfilePage() {
 return (
   <ProfileLayout>
     <ProfileCover />
     <Sidebar>
       <Friends />
       <Photos />
     </Sidebar>
     <Suspense fallback={<PostsGlimmer />}>
       <Posts />
     </Suspense>
   </ProfileLayout>
 );
}
This tells React to start streaming the HTML before Posts loads its data. React will send the HTML for the loading fallback (PostsGlimmer) first, and then, when Posts finishes loading its data, React will send the remaining HTML along with an inline <script> tag that replaces the loading fallback with that HTML. From the user’s perspective, the page will first appear with the PostsGlimmer, later replaced by the Posts.
You can further nest <Suspense> boundaries to create a more granular loading sequence:
function ProfilePage() {
 return (
   <ProfileLayout>
     <ProfileCover />
     <Suspense fallback={<BigSpinner />}>
       <Sidebar>
         <Friends />
         <Photos />
       </Sidebar>
       <Suspense fallback={<PostsGlimmer />}>
         <Posts />
       </Suspense>
     </Suspense>
   </ProfileLayout>
 );
}
In this example, React can start streaming the page even earlier. Only ProfileLayout and ProfileCover must finish rendering first because they are not wrapped in any <Suspense> boundary. However, if Sidebar, Friends, or Photos need to load some data, React will send the HTML for the BigSpinner fallback instead. Then, as more data becomes available, more content will continue to be revealed until all of it becomes visible.
Streaming does not need to wait for React itself to load in the browser, or for your app to become interactive. The HTML content from the server will get progressively revealed before any of the <script> tags load.
Read more about how streaming HTML works.
Note
Only Suspense-enabled data sources will activate the Suspense component. They include:
Data fetching with Suspense-enabled frameworks like Relay and Next.js
Lazy-loading component code with lazy
Reading the value of a Promise with use
Suspense does not detect when data is fetched inside an Effect or event handler.
The exact way you would load data in the Posts component above depends on your framework. If you use a Suspense-enabled framework, you’ll find the details in its data fetching documentation.
Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.

Specifying what goes into the shell 
The part of your app outside of any <Suspense> boundaries is called the shell:
function ProfilePage() {
 return (
   <ProfileLayout>
     <ProfileCover />
     <Suspense fallback={<BigSpinner />}>
       <Sidebar>
         <Friends />
         <Photos />
       </Sidebar>
       <Suspense fallback={<PostsGlimmer />}>
         <Posts />
       </Suspense>
     </Suspense>
   </ProfileLayout>
 );
}
It determines the earliest loading state that the user may see:
<ProfileLayout>
 <ProfileCover />
 <BigSpinner />
</ProfileLayout>
If you wrap the whole app into a <Suspense> boundary at the root, the shell will only contain that spinner. However, that’s not a pleasant user experience because seeing a big spinner on the screen can feel slower and more annoying than waiting a bit more and seeing the real layout. This is why usually you’ll want to place the <Suspense> boundaries so that the shell feels minimal but complete—like a skeleton of the entire page layout.
The onShellReady callback fires when the entire shell has been rendered. Usually, you’ll start streaming then:
const { pipe } = renderToPipeableStream(<App />, {
 bootstrapScripts: ['/main.js'],
 onShellReady() {
   response.setHeader('content-type', 'text/html');
   pipe(response);
 }
});
By the time onShellReady fires, components in nested <Suspense> boundaries might still be loading data.

Logging crashes on the server 
By default, all errors on the server are logged to console. You can override this behavior to log crash reports:
const { pipe } = renderToPipeableStream(<App />, {
 bootstrapScripts: ['/main.js'],
 onShellReady() {
   response.setHeader('content-type', 'text/html');
   pipe(response);
 },
 onError(error) {
   console.error(error);
   logServerCrashReport(error);
 }
});
If you provide a custom onError implementation, don’t forget to also log errors to the console like above.

Recovering from errors inside the shell 
In this example, the shell contains ProfileLayout, ProfileCover, and PostsGlimmer:
function ProfilePage() {
 return (
   <ProfileLayout>
     <ProfileCover />
     <Suspense fallback={<PostsGlimmer />}>
       <Posts />
     </Suspense>
   </ProfileLayout>
 );
}
If an error occurs while rendering those components, React won’t have any meaningful HTML to send to the client. Override onShellError to send a fallback HTML that doesn’t rely on server rendering as the last resort:
const { pipe } = renderToPipeableStream(<App />, {
 bootstrapScripts: ['/main.js'],
 onShellReady() {
   response.setHeader('content-type', 'text/html');
   pipe(response);
 },
 onShellError(error) {
   response.statusCode = 500;
   response.setHeader('content-type', 'text/html');
   response.send('<h1>Something went wrong</h1>');
 },
 onError(error) {
   console.error(error);
   logServerCrashReport(error);
 }
});
If there is an error while generating the shell, both onError and onShellError will fire. Use onError for error reporting and use onShellError to send the fallback HTML document. Your fallback HTML does not have to be an error page. Instead, you may include an alternative shell that renders your app on the client only.

Recovering from errors outside the shell 
In this example, the <Posts /> component is wrapped in <Suspense> so it is not a part of the shell:
function ProfilePage() {
 return (
   <ProfileLayout>
     <ProfileCover />
     <Suspense fallback={<PostsGlimmer />}>
       <Posts />
     </Suspense>
   </ProfileLayout>
 );
}
If an error happens in the Posts component or somewhere inside it, React will try to recover from it:
It will emit the loading fallback for the closest <Suspense> boundary (PostsGlimmer) into the HTML.
It will “give up” on trying to render the Posts content on the server anymore.
When the JavaScript code loads on the client, React will retry rendering Posts on the client.
If retrying rendering Posts on the client also fails, React will throw the error on the client. As with all the errors thrown during rendering, the closest parent error boundary determines how to present the error to the user. In practice, this means that the user will see a loading indicator until it is certain that the error is not recoverable.
If retrying rendering Posts on the client succeeds, the loading fallback from the server will be replaced with the client rendering output. The user will not know that there was a server error. However, the server onError callback and the client onRecoverableError callbacks will fire so that you can get notified about the error.

Setting the status code 
Streaming introduces a tradeoff. You want to start streaming the page as early as possible so that the user can see the content sooner. However, once you start streaming, you can no longer set the response status code.
By dividing your app into the shell (above all <Suspense> boundaries) and the rest of the content, you’ve already solved a part of this problem. If the shell errors, you’ll get the onShellError callback which lets you set the error status code. Otherwise, you know that the app may recover on the client, so you can send “OK”.
const { pipe } = renderToPipeableStream(<App />, {
 bootstrapScripts: ['/main.js'],
 onShellReady() {
   response.statusCode = 200;
   response.setHeader('content-type', 'text/html');
   pipe(response);
 },
 onShellError(error) {
   response.statusCode = 500;
   response.setHeader('content-type', 'text/html');
   response.send('<h1>Something went wrong</h1>');
 },
 onError(error) {
   console.error(error);
   logServerCrashReport(error);
 }
});
If a component outside the shell (i.e. inside a <Suspense> boundary) throws an error, React will not stop rendering. This means that the onError callback will fire, but you will still get onShellReady instead of onShellError. This is because React will try to recover from that error on the client, as described above.
However, if you’d like, you can use the fact that something has errored to set the status code:
let didError = false;

const { pipe } = renderToPipeableStream(<App />, {
 bootstrapScripts: ['/main.js'],
 onShellReady() {
   response.statusCode = didError ? 500 : 200;
   response.setHeader('content-type', 'text/html');
   pipe(response);
 },
 onShellError(error) {
   response.statusCode = 500;
   response.setHeader('content-type', 'text/html');
   response.send('<h1>Something went wrong</h1>');
 },
 onError(error) {
   didError = true;
   console.error(error);
   logServerCrashReport(error);
 }
});
This will only catch errors outside the shell that happened while generating the initial shell content, so it’s not exhaustive. If knowing whether an error occurred for some content is critical, you can move it up into the shell.

Handling different errors in different ways 
You can create your own Error subclasses and use the instanceof operator to check which error is thrown. For example, you can define a custom NotFoundError and throw it from your component. Then your onError, onShellReady, and onShellError callbacks can do something different depending on the error type:
let didError = false;
let caughtError = null;

function getStatusCode() {
 if (didError) {
   if (caughtError instanceof NotFoundError) {
     return 404;
   } else {
     return 500;
   }
 } else {
   return 200;
 }
}

const { pipe } = renderToPipeableStream(<App />, {
 bootstrapScripts: ['/main.js'],
 onShellReady() {
   response.statusCode = getStatusCode();
   response.setHeader('content-type', 'text/html');
   pipe(response);
 },
 onShellError(error) {
  response.statusCode = getStatusCode();
  response.setHeader('content-type', 'text/html');
  response.send('<h1>Something went wrong</h1>');
 },
 onError(error) {
   didError = true;
   caughtError = error;
   console.error(error);
   logServerCrashReport(error);
 }
});
Keep in mind that once you emit the shell and start streaming, you can’t change the status code.

Waiting for all content to load for crawlers and static generation 
Streaming offers a better user experience because the user can see the content as it becomes available.
However, when a crawler visits your page, or if you’re generating the pages at the build time, you might want to let all of the content load first and then produce the final HTML output instead of revealing it progressively.
You can wait for all the content to load using the onAllReady callback:
let didError = false;
let isCrawler = // ... depends on your bot detection strategy ...

const { pipe } = renderToPipeableStream(<App />, {
 bootstrapScripts: ['/main.js'],
 onShellReady() {
   if (!isCrawler) {
     response.statusCode = didError ? 500 : 200;
     response.setHeader('content-type', 'text/html');
     pipe(response);
   }
 },
 onShellError(error) {
   response.statusCode = 500;
   response.setHeader('content-type', 'text/html');
   response.send('<h1>Something went wrong</h1>');
 },
 onAllReady() {
   if (isCrawler) {
     response.statusCode = didError ? 500 : 200;
     response.setHeader('content-type', 'text/html');
     pipe(response);     
   }
 },
 onError(error) {
   didError = true;
   console.error(error);
   logServerCrashReport(error);
 }
});
A regular visitor will get a stream of progressively loaded content. A crawler will receive the final HTML output after all the data loads. However, this also means that the crawler will have to wait for all data, some of which might be slow to load or error. Depending on your app, you could choose to send the shell to the crawlers too.

Aborting server rendering 
You can force the server rendering to “give up” after a timeout:
const { pipe, abort } = renderToPipeableStream(<App />, {
 // ...
});

setTimeout(() => {
 abort();
}, 10000);
React will flush the remaining loading fallbacks as HTML, and will attempt to render the rest on the client.
renderToReadableStream
renderToReadableStream renders a React tree to a Readable Web Stream.
const stream = await renderToReadableStream(reactNode, options?)
Reference
renderToReadableStream(reactNode, options?)
Usage
Rendering a React tree as HTML to a Readable Web Stream
Streaming more content as it loads
Specifying what goes into the shell
Logging crashes on the server
Recovering from errors inside the shell
Recovering from errors outside the shell
Setting the status code
Handling different errors in different ways
Waiting for all content to load for crawlers and static generation
Aborting server rendering
Note
This API depends on Web Streams. For Node.js, use renderToPipeableStream instead.

Reference 
renderToReadableStream(reactNode, options?) 
Call renderToReadableStream to render your React tree as HTML into a Readable Web Stream.
import { renderToReadableStream } from 'react-dom/server';

async function handler(request) {
 const stream = await renderToReadableStream(<App />, {
   bootstrapScripts: ['/main.js']
 });
 return new Response(stream, {
   headers: { 'content-type': 'text/html' },
 });
}
On the client, call hydrateRoot to make the server-generated HTML interactive.
See more examples below.
Parameters 
reactNode: A React node you want to render to HTML. For example, a JSX element like <App />. It is expected to represent the entire document, so the App component should render the <html> tag.
optional options: An object with streaming options.
optional bootstrapScriptContent: If specified, this string will be placed in an inline <script> tag.
optional bootstrapScripts: An array of string URLs for the <script> tags to emit on the page. Use this to include the <script> that calls hydrateRoot. Omit it if you don’t want to run React on the client at all.
optional bootstrapModules: Like bootstrapScripts, but emits <script type="module"> instead.
optional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to hydrateRoot.
optional namespaceURI: A string with the root namespace URI for the stream. Defaults to regular HTML. Pass 'http://www.w3.org/2000/svg' for SVG or 'http://www.w3.org/1998/Math/MathML' for MathML.
optional nonce: A nonce string to allow scripts for script-src Content-Security-Policy.
optional onError: A callback that fires whenever there is a server error, whether recoverable or not. By default, this only calls console.error. If you override it to log crash reports, make sure that you still call console.error. You can also use it to adjust the status code before the shell is emitted.
optional progressiveChunkSize: The number of bytes in a chunk. Read more about the default heuristic.
optional signal: An abort signal that lets you abort server rendering and render the rest on the client.
Returns 
renderToReadableStream returns a Promise:
If rendering the shell is successful, that Promise will resolve to a Readable Web Stream.
If rendering the shell fails, the Promise will be rejected. Use this to output a fallback shell.
The returned stream has an additional property:
allReady: A Promise that resolves when all rendering is complete, including both the shell and all additional content. You can await stream.allReady before returning a response for crawlers and static generation. If you do that, you won’t get any progressive loading. The stream will contain the final HTML.

Usage 
Rendering a React tree as HTML to a Readable Web Stream 
Call renderToReadableStream to render your React tree as HTML into a Readable Web Stream:
import { renderToReadableStream } from 'react-dom/server';

async function handler(request) {
 const stream = await renderToReadableStream(<App />, {
   bootstrapScripts: ['/main.js']
 });
 return new Response(stream, {
   headers: { 'content-type': 'text/html' },
 });
}
Along with the root component, you need to provide a list of bootstrap <script> paths. Your root component should return the entire document including the root <html> tag.
For example, it might look like this:
export default function App() {
 return (
   <html>
     <head>
       <meta charSet="utf-8" />
       <meta name="viewport" content="width=device-width, initial-scale=1" />
       <link rel="stylesheet" href="/styles.css"></link>
       <title>My app</title>
     </head>
     <body>
       <Router />
     </body>
   </html>
 );
}
React will inject the doctype and your bootstrap <script> tags into the resulting HTML stream:
<!DOCTYPE html>
<html>
 <!-- ... HTML from your components ... -->
</html>
<script src="/main.js" async=""></script>
On the client, your bootstrap script should hydrate the entire document with a call to hydrateRoot:
import { hydrateRoot } from 'react-dom/client';
import App from './App.js';

hydrateRoot(document, <App />);
This will attach event listeners to the server-generated HTML and make it interactive.
Deep Dive
Reading CSS and JS asset paths from the build output 
Hide Details
The final asset URLs (like JavaScript and CSS files) are often hashed after the build. For example, instead of styles.css you might end up with styles.123456.css. Hashing static asset filenames guarantees that every distinct build of the same asset will have a different filename. This is useful because it lets you safely enable long-term caching for static assets: a file with a certain name would never change content.
However, if you don’t know the asset URLs until after the build, there’s no way for you to put them in the source code. For example, hardcoding "/styles.css" into JSX like earlier wouldn’t work. To keep them out of your source code, your root component can read the real filenames from a map passed as a prop:
export default function App({ assetMap }) {
 return (
   <html>
     <head>
       <title>My app</title>
       <link rel="stylesheet" href={assetMap['styles.css']}></link>
     </head>
     ...
   </html>
 );
}
On the server, render <App assetMap={assetMap} /> and pass your assetMap with the asset URLs:
// You'd need to get this JSON from your build tooling, e.g. read it from the build output.
const assetMap = {
 'styles.css': '/styles.123456.css',
 'main.js': '/main.123456.js'
};

async function handler(request) {
 const stream = await renderToReadableStream(<App assetMap={assetMap} />, {
   bootstrapScripts: [assetMap['/main.js']]
 });
 return new Response(stream, {
   headers: { 'content-type': 'text/html' },
 });
}
Since your server is now rendering <App assetMap={assetMap} />, you need to render it with assetMap on the client too to avoid hydration errors. You can serialize and pass assetMap to the client like this:
// You'd need to get this JSON from your build tooling.
const assetMap = {
 'styles.css': '/styles.123456.css',
 'main.js': '/main.123456.js'
};

async function handler(request) {
 const stream = await renderToReadableStream(<App assetMap={assetMap} />, {
   // Careful: It's safe to stringify() this because this data isn't user-generated.
   bootstrapScriptContent: `window.assetMap = ${JSON.stringify(assetMap)};`,
   bootstrapScripts: [assetMap['/main.js']],
 });
 return new Response(stream, {
   headers: { 'content-type': 'text/html' },
 });
}
In the example above, the bootstrapScriptContent option adds an extra inline <script> tag that sets the global window.assetMap variable on the client. This lets the client code read the same assetMap:
import { hydrateRoot } from 'react-dom/client';
import App from './App.js';

hydrateRoot(document, <App assetMap={window.assetMap} />);
Both client and server render App with the same assetMap prop, so there are no hydration errors.

Streaming more content as it loads 
Streaming allows the user to start seeing the content even before all the data has loaded on the server. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:
function ProfilePage() {
 return (
   <ProfileLayout>
     <ProfileCover />
     <Sidebar>
       <Friends />
       <Photos />
     </Sidebar>
     <Posts />
   </ProfileLayout>
 );
}
Imagine that loading data for <Posts /> takes some time. Ideally, you’d want to show the rest of the profile page content to the user without waiting for the posts. To do this, wrap Posts in a <Suspense> boundary:
function ProfilePage() {
 return (
   <ProfileLayout>
     <ProfileCover />
     <Sidebar>
       <Friends />
       <Photos />
     </Sidebar>
     <Suspense fallback={<PostsGlimmer />}>
       <Posts />
     </Suspense>
   </ProfileLayout>
 );
}
This tells React to start streaming the HTML before Posts loads its data. React will send the HTML for the loading fallback (PostsGlimmer) first, and then, when Posts finishes loading its data, React will send the remaining HTML along with an inline <script> tag that replaces the loading fallback with that HTML. From the user’s perspective, the page will first appear with the PostsGlimmer, later replaced by the Posts.
You can further nest <Suspense> boundaries to create a more granular loading sequence:
function ProfilePage() {
 return (
   <ProfileLayout>
     <ProfileCover />
     <Suspense fallback={<BigSpinner />}>
       <Sidebar>
         <Friends />
         <Photos />
       </Sidebar>
       <Suspense fallback={<PostsGlimmer />}>
         <Posts />
       </Suspense>
     </Suspense>
   </ProfileLayout>
 );
}
In this example, React can start streaming the page even earlier. Only ProfileLayout and ProfileCover must finish rendering first because they are not wrapped in any <Suspense> boundary. However, if Sidebar, Friends, or Photos need to load some data, React will send the HTML for the BigSpinner fallback instead. Then, as more data becomes available, more content will continue to be revealed until all of it becomes visible.
Streaming does not need to wait for React itself to load in the browser, or for your app to become interactive. The HTML content from the server will get progressively revealed before any of the <script> tags load.
Read more about how streaming HTML works.
Note
Only Suspense-enabled data sources will activate the Suspense component. They include:
Data fetching with Suspense-enabled frameworks like Relay and Next.js
Lazy-loading component code with lazy
Reading the value of a Promise with use
Suspense does not detect when data is fetched inside an Effect or event handler.
The exact way you would load data in the Posts component above depends on your framework. If you use a Suspense-enabled framework, you’ll find the details in its data fetching documentation.
Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.

Specifying what goes into the shell 
The part of your app outside of any <Suspense> boundaries is called the shell:
function ProfilePage() {
 return (
   <ProfileLayout>
     <ProfileCover />
     <Suspense fallback={<BigSpinner />}>
       <Sidebar>
         <Friends />
         <Photos />
       </Sidebar>
       <Suspense fallback={<PostsGlimmer />}>
         <Posts />
       </Suspense>
     </Suspense>
   </ProfileLayout>
 );
}
It determines the earliest loading state that the user may see:
<ProfileLayout>
 <ProfileCover />
 <BigSpinner />
</ProfileLayout>
If you wrap the whole app into a <Suspense> boundary at the root, the shell will only contain that spinner. However, that’s not a pleasant user experience because seeing a big spinner on the screen can feel slower and more annoying than waiting a bit more and seeing the real layout. This is why usually you’ll want to place the <Suspense> boundaries so that the shell feels minimal but complete—like a skeleton of the entire page layout.
The async call to renderToReadableStream will resolve to a stream as soon as the entire shell has been rendered. Usually, you’ll start streaming then by creating and returning a response with that stream:
async function handler(request) {
 const stream = await renderToReadableStream(<App />, {
   bootstrapScripts: ['/main.js']
 });
 return new Response(stream, {
   headers: { 'content-type': 'text/html' },
 });
}
By the time the stream is returned, components in nested <Suspense> boundaries might still be loading data.

Logging crashes on the server 
By default, all errors on the server are logged to console. You can override this behavior to log crash reports:
async function handler(request) {
 const stream = await renderToReadableStream(<App />, {
   bootstrapScripts: ['/main.js'],
   onError(error) {
     console.error(error);
     logServerCrashReport(error);
   }
 });
 return new Response(stream, {
   headers: { 'content-type': 'text/html' },
 });
}
If you provide a custom onError implementation, don’t forget to also log errors to the console like above.

Recovering from errors inside the shell 
In this example, the shell contains ProfileLayout, ProfileCover, and PostsGlimmer:
function ProfilePage() {
 return (
   <ProfileLayout>
     <ProfileCover />
     <Suspense fallback={<PostsGlimmer />}>
       <Posts />
     </Suspense>
   </ProfileLayout>
 );
}
If an error occurs while rendering those components, React won’t have any meaningful HTML to send to the client. Wrap your renderToReadableStream call in a try...catch to send a fallback HTML that doesn’t rely on server rendering as the last resort:
async function handler(request) {
 try {
   const stream = await renderToReadableStream(<App />, {
     bootstrapScripts: ['/main.js'],
     onError(error) {
       console.error(error);
       logServerCrashReport(error);
     }
   });
   return new Response(stream, {
     headers: { 'content-type': 'text/html' },
   });
 } catch (error) {
   return new Response('<h1>Something went wrong</h1>', {
     status: 500,
     headers: { 'content-type': 'text/html' },
   });
 }
}
If there is an error while generating the shell, both onError and your catch block will fire. Use onError for error reporting and use the catch block to send the fallback HTML document. Your fallback HTML does not have to be an error page. Instead, you may include an alternative shell that renders your app on the client only.

Recovering from errors outside the shell 
In this example, the <Posts /> component is wrapped in <Suspense> so it is not a part of the shell:
function ProfilePage() {
 return (
   <ProfileLayout>
     <ProfileCover />
     <Suspense fallback={<PostsGlimmer />}>
       <Posts />
     </Suspense>
   </ProfileLayout>
 );
}
If an error happens in the Posts component or somewhere inside it, React will try to recover from it:
It will emit the loading fallback for the closest <Suspense> boundary (PostsGlimmer) into the HTML.
It will “give up” on trying to render the Posts content on the server anymore.
When the JavaScript code loads on the client, React will retry rendering Posts on the client.
If retrying rendering Posts on the client also fails, React will throw the error on the client. As with all the errors thrown during rendering, the closest parent error boundary determines how to present the error to the user. In practice, this means that the user will see a loading indicator until it is certain that the error is not recoverable.
If retrying rendering Posts on the client succeeds, the loading fallback from the server will be replaced with the client rendering output. The user will not know that there was a server error. However, the server onError callback and the client onRecoverableError callbacks will fire so that you can get notified about the error.

Setting the status code 
Streaming introduces a tradeoff. You want to start streaming the page as early as possible so that the user can see the content sooner. However, once you start streaming, you can no longer set the response status code.
By dividing your app into the shell (above all <Suspense> boundaries) and the rest of the content, you’ve already solved a part of this problem. If the shell errors, your catch block will run which lets you set the error status code. Otherwise, you know that the app may recover on the client, so you can send “OK”.
async function handler(request) {
 try {
   const stream = await renderToReadableStream(<App />, {
     bootstrapScripts: ['/main.js'],
     onError(error) {
       console.error(error);
       logServerCrashReport(error);
     }
   });
   return new Response(stream, {
     status: 200,
     headers: { 'content-type': 'text/html' },
   });
 } catch (error) {
   return new Response('<h1>Something went wrong</h1>', {
     status: 500,
     headers: { 'content-type': 'text/html' },
   });
 }
}
If a component outside the shell (i.e. inside a <Suspense> boundary) throws an error, React will not stop rendering. This means that the onError callback will fire, but your code will continue running without getting into the catch block. This is because React will try to recover from that error on the client, as described above.
However, if you’d like, you can use the fact that something has errored to set the status code:
async function handler(request) {
 try {
   let didError = false;
   const stream = await renderToReadableStream(<App />, {
     bootstrapScripts: ['/main.js'],
     onError(error) {
       didError = true;
       console.error(error);
       logServerCrashReport(error);
     }
   });
   return new Response(stream, {
     status: didError ? 500 : 200,
     headers: { 'content-type': 'text/html' },
   });
 } catch (error) {
   return new Response('<h1>Something went wrong</h1>', {
     status: 500,
     headers: { 'content-type': 'text/html' },
   });
 }
}
This will only catch errors outside the shell that happened while generating the initial shell content, so it’s not exhaustive. If knowing whether an error occurred for some content is critical, you can move it up into the shell.

Handling different errors in different ways 
You can create your own Error subclasses and use the instanceof operator to check which error is thrown. For example, you can define a custom NotFoundError and throw it from your component. Then you can save the error in onError and do something different before returning the response depending on the error type:
async function handler(request) {
 let didError = false;
 let caughtError = null;

 function getStatusCode() {
   if (didError) {
     if (caughtError instanceof NotFoundError) {
       return 404;
     } else {
       return 500;
     }
   } else {
     return 200;
   }
 }

 try {
   const stream = await renderToReadableStream(<App />, {
     bootstrapScripts: ['/main.js'],
     onError(error) {
       didError = true;
       caughtError = error;
       console.error(error);
       logServerCrashReport(error);
     }
   });
   return new Response(stream, {
     status: getStatusCode(),
     headers: { 'content-type': 'text/html' },
   });
 } catch (error) {
   return new Response('<h1>Something went wrong</h1>', {
     status: getStatusCode(),
     headers: { 'content-type': 'text/html' },
   });
 }
}
Keep in mind that once you emit the shell and start streaming, you can’t change the status code.

Waiting for all content to load for crawlers and static generation 
Streaming offers a better user experience because the user can see the content as it becomes available.
However, when a crawler visits your page, or if you’re generating the pages at the build time, you might want to let all of the content load first and then produce the final HTML output instead of revealing it progressively.
You can wait for all the content to load by awaiting the stream.allReady Promise:
async function handler(request) {
 try {
   let didError = false;
   const stream = await renderToReadableStream(<App />, {
     bootstrapScripts: ['/main.js'],
     onError(error) {
       didError = true;
       console.error(error);
       logServerCrashReport(error);
     }
   });
   let isCrawler = // ... depends on your bot detection strategy ...
   if (isCrawler) {
     await stream.allReady;
   }
   return new Response(stream, {
     status: didError ? 500 : 200,
     headers: { 'content-type': 'text/html' },
   });
 } catch (error) {
   return new Response('<h1>Something went wrong</h1>', {
     status: 500,
     headers: { 'content-type': 'text/html' },
   });
 }
}
A regular visitor will get a stream of progressively loaded content. A crawler will receive the final HTML output after all the data loads. However, this also means that the crawler will have to wait for all data, some of which might be slow to load or error. Depending on your app, you could choose to send the shell to the crawlers too.

Aborting server rendering 
You can force the server rendering to “give up” after a timeout:
async function handler(request) {
 try {
   const controller = new AbortController();
   setTimeout(() => {
     controller.abort();
   }, 10000);

   const stream = await renderToReadableStream(<App />, {
     signal: controller.signal,
     bootstrapScripts: ['/main.js'],
     onError(error) {
       didError = true;
       console.error(error);
       logServerCrashReport(error);
     }
   });
   // ...
React will flush the remaining loading fallbacks as HTML, and will attempt to render the rest on the client.
renderToStaticMarkup
renderToStaticMarkup renders a non-interactive React tree to an HTML string.
const html = renderToStaticMarkup(reactNode, options?)
Reference
renderToStaticMarkup(reactNode, options?)
Usage
Rendering a non-interactive React tree as HTML to a string

Reference 
renderToStaticMarkup(reactNode, options?) 
On the server, call renderToStaticMarkup to render your app to HTML.
import { renderToStaticMarkup } from 'react-dom/server';

const html = renderToStaticMarkup(<Page />);
It will produce non-interactive HTML output of your React components.
See more examples below.
Parameters 
reactNode: A React node you want to render to HTML. For example, a JSX node like <Page />.
optional options: An object for server render.
optional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page.
Returns 
An HTML string.
Caveats 
renderToStaticMarkup output cannot be hydrated.
renderToStaticMarkup has limited Suspense support. If a component suspends, renderToStaticMarkup immediately sends its fallback as HTML.
renderToStaticMarkup works in the browser, but using it in the client code is not recommended. If you need to render a component to HTML in the browser, get the HTML by rendering it into a DOM node.

Usage 
Rendering a non-interactive React tree as HTML to a string 
Call renderToStaticMarkup to render your app to an HTML string which you can send with your server response:
import { renderToStaticMarkup } from 'react-dom/server';

// The route handler syntax depends on your backend framework
app.use('/', (request, response) => {
 const html = renderToStaticMarkup(<Page />);
 response.send(html);
});
This will produce the initial non-interactive HTML output of your React components.
Pitfall
This method renders non-interactive HTML that cannot be hydrated.  This is useful if you want to use React as a simple static page generator, or if you’re rendering completely static content like emails.
Interactive apps should use renderToString on the server and hydrateRoot on the client.
PreviousrenderToReadableStream

renderToString
Pitfall
renderToString does not support streaming or waiting for data. See the alternatives.
renderToString renders a React tree to an HTML string.
const html = renderToString(reactNode, options?)
Reference
renderToString(reactNode, options?)
Usage
Rendering a React tree as HTML to a string
Alternatives
Migrating from renderToString to a streaming render on the server
Migrating from renderToString to a static prerender on the server
Removing renderToString from the client code
Troubleshooting
When a component suspends, the HTML always contains a fallback

Reference 
renderToString(reactNode, options?) 
On the server, call renderToString to render your app to HTML.
import { renderToString } from 'react-dom/server';

const html = renderToString(<App />);
On the client, call hydrateRoot to make the server-generated HTML interactive.
See more examples below.
Parameters 
reactNode: A React node you want to render to HTML. For example, a JSX node like <App />.
optional options: An object for server render.
optional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to hydrateRoot.
Returns 
An HTML string.
Caveats 
renderToString has limited Suspense support. If a component suspends, renderToString immediately sends its fallback as HTML.
renderToString works in the browser, but using it in the client code is not recommended.

Usage 
Rendering a React tree as HTML to a string 
Call renderToString to render your app to an HTML string which you can send with your server response:
import { renderToString } from 'react-dom/server';

// The route handler syntax depends on your backend framework
app.use('/', (request, response) => {
 const html = renderToString(<App />);
 response.send(html);
});
This will produce the initial non-interactive HTML output of your React components. On the client, you will need to call hydrateRoot to hydrate that server-generated HTML and make it interactive.
Pitfall
renderToString does not support streaming or waiting for data. See the alternatives.

Alternatives 
Migrating from renderToString to a streaming render on the server 
renderToString returns a string immediately, so it does not support streaming content as it loads.
When possible, we recommend using these fully-featured alternatives:
If you use Node.js, use renderToPipeableStream.
If you use Deno or a modern edge runtime with Web Streams, use renderToReadableStream.
You can continue using renderToString if your server environment does not support streams.

Migrating from renderToString to a static prerender on the server 
renderToString returns a string immediately, so it does not support waiting for data to load for static HTML generation.
We recommend using these fully-featured alternatives:
If you use Node.js, use prerenderToNodeStream.
If you use Deno or a modern edge runtime with Web Streams, use prerender.
You can continue using renderToString if your static site generation environment does not support streams.

Removing renderToString from the client code 
Sometimes, renderToString is used on the client to convert some component to HTML.
// 🚩 Unnecessary: using renderToString on the client
import { renderToString } from 'react-dom/server';

const html = renderToString(<MyIcon />);
console.log(html); // For example, "<svg>...</svg>"
Importing react-dom/server on the client unnecessarily increases your bundle size and should be avoided. If you need to render some component to HTML in the browser, use createRoot and read HTML from the DOM:
import { createRoot } from 'react-dom/client';
import { flushSync } from 'react-dom';

const div = document.createElement('div');
const root = createRoot(div);
flushSync(() => {
 root.render(<MyIcon />);
});
console.log(div.innerHTML); // For example, "<svg>...</svg>"
The flushSync call is necessary so that the DOM is updated before reading its innerHTML property.

Troubleshooting 
When a component suspends, the HTML always contains a fallback 
renderToString does not fully support Suspense.
If some component suspends (for example, because it’s defined with lazy or fetches data), renderToString will not wait for its content to resolve. Instead, renderToString will find the closest <Suspense> boundary above it and render its fallback prop in the HTML. The content will not appear until the client code loads.
To solve this, use one of the recommended streaming solutions. For server side rendering, they can stream content in chunks as it resolves on the server so that the user sees the page being progressively filled in before the client code loads. For static site generation, they can wait for all the content to resolve before generating the static HTML.

Static React DOM APIs
The react-dom/static APIs let you generate static HTML for React components. They have limited functionality compared to the streaming APIs. A framework may call them for you. Most of your components don’t need to import or use them.

Static APIs for Web Streams 
These methods are only available in the environments with Web Streams, which includes browsers, Deno, and some modern edge runtimes:
prerender renders a React tree to static HTML with a Readable Web Stream.

Static APIs for Node.js Streams 
These methods are only available in the environments with Node.js Streams:
prerenderToNodeStream renders a React tree to static HTML with a Node.js Stream.
prerender
prerender renders a React tree to a static HTML string using a Web Stream.
const {prelude} = await prerender(reactNode, options?)
Reference
prerender(reactNode, options?)
Usage
Rendering a React tree to a stream of static HTML
Rendering a React tree to a string of static HTML
Waiting for all data to load
Aborting prerendering
Troubleshooting
My stream doesn’t start until the entire app is rendered
Note
This API depends on Web Streams. For Node.js, use prerenderToNodeStream instead.

Reference 
prerender(reactNode, options?) 
Call prerender to render your app to static HTML.
import { prerender } from 'react-dom/static';

async function handler(request) {
 const {prelude} = await prerender(<App />, {
   bootstrapScripts: ['/main.js']
 });
 return new Response(prelude, {
   headers: { 'content-type': 'text/html' },
 });
}
On the client, call hydrateRoot to make the server-generated HTML interactive.
See more examples below.
Parameters 
reactNode: A React node you want to render to HTML. For example, a JSX node like <App />. It is expected to represent the entire document, so the App component should render the <html> tag.
optional options: An object with static generation options.
optional bootstrapScriptContent: If specified, this string will be placed in an inline <script> tag.
optional bootstrapScripts: An array of string URLs for the <script> tags to emit on the page. Use this to include the <script> that calls hydrateRoot. Omit it if you don’t want to run React on the client at all.
optional bootstrapModules: Like bootstrapScripts, but emits <script type="module"> instead.
optional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to hydrateRoot.
optional namespaceURI: A string with the root namespace URI for the stream. Defaults to regular HTML. Pass 'http://www.w3.org/2000/svg' for SVG or 'http://www.w3.org/1998/Math/MathML' for MathML.
optional onError: A callback that fires whenever there is a server error, whether recoverable or not. By default, this only calls console.error. If you override it to log crash reports, make sure that you still call console.error. You can also use it to adjust the status code before the shell is emitted.
optional progressiveChunkSize: The number of bytes in a chunk. Read more about the default heuristic.
optional signal: An abort signal that lets you abort prerendering and render the rest on the client.
Returns 
prerender returns a Promise:
If rendering the is successful, the Promise will resolve to an object containing:
prelude: a Web Stream of HTML. You can use this stream to send a response in chunks, or you can read the entire stream into a string.
If rendering fails, the Promise will be rejected. Use this to output a fallback shell.
Caveats 
nonce is not an available option when prerendering. Nonces must be unique per request and if you use nonces to secure your application with CSP it would be inappropriate and insecure to include the nonce value in the prerender itself.
Note
When should I use prerender? 
The static prerender API is used for static server-side generation (SSG). Unlike renderToString, prerender waits for all data to load before resolving. This makes it suitable for generating static HTML for a full page, including data that needs to be fetched using Suspense. To stream content as it loads, use a streaming server-side render (SSR) API like renderToReadableStream.

Usage 
Rendering a React tree to a stream of static HTML 
Call prerender to render your React tree to static HTML into a Readable Web Stream::
import { prerender } from 'react-dom/static';

async function handler(request) {
 const {prelude} = await prerender(<App />, {
   bootstrapScripts: ['/main.js']
 });
 return new Response(prelude, {
   headers: { 'content-type': 'text/html' },
 });
}
Along with the root component, you need to provide a list of bootstrap <script> paths. Your root component should return the entire document including the root <html> tag.
For example, it might look like this:
export default function App() {
 return (
   <html>
     <head>
       <meta charSet="utf-8" />
       <meta name="viewport" content="width=device-width, initial-scale=1" />
       <link rel="stylesheet" href="/styles.css"></link>
       <title>My app</title>
     </head>
     <body>
       <Router />
     </body>
   </html>
 );
}
React will inject the doctype and your bootstrap <script> tags into the resulting HTML stream:
<!DOCTYPE html>
<html>
 <!-- ... HTML from your components ... -->
</html>
<script src="/main.js" async=""></script>
On the client, your bootstrap script should hydrate the entire document with a call to hydrateRoot:
import { hydrateRoot } from 'react-dom/client';
import App from './App.js';

hydrateRoot(document, <App />);
This will attach event listeners to the static server-generated HTML and make it interactive.
Deep Dive
Reading CSS and JS asset paths from the build output 
Hide Details
The final asset URLs (like JavaScript and CSS files) are often hashed after the build. For example, instead of styles.css you might end up with styles.123456.css. Hashing static asset filenames guarantees that every distinct build of the same asset will have a different filename. This is useful because it lets you safely enable long-term caching for static assets: a file with a certain name would never change content.
However, if you don’t know the asset URLs until after the build, there’s no way for you to put them in the source code. For example, hardcoding "/styles.css" into JSX like earlier wouldn’t work. To keep them out of your source code, your root component can read the real filenames from a map passed as a prop:
export default function App({ assetMap }) {
 return (
   <html>
     <head>
       <title>My app</title>
       <link rel="stylesheet" href={assetMap['styles.css']}></link>
     </head>
     ...
   </html>
 );
}
On the server, render <App assetMap={assetMap} /> and pass your assetMap with the asset URLs:
// You'd need to get this JSON from your build tooling, e.g. read it from the build output.
const assetMap = {
 'styles.css': '/styles.123456.css',
 'main.js': '/main.123456.js'
};

async function handler(request) {
 const {prelude} = await prerender(<App assetMap={assetMap} />, {
   bootstrapScripts: [assetMap['/main.js']]
 });
 return new Response(prelude, {
   headers: { 'content-type': 'text/html' },
 });
}
Since your server is now rendering <App assetMap={assetMap} />, you need to render it with assetMap on the client too to avoid hydration errors. You can serialize and pass assetMap to the client like this:
// You'd need to get this JSON from your build tooling.
const assetMap = {
 'styles.css': '/styles.123456.css',
 'main.js': '/main.123456.js'
};

async function handler(request) {
 const {prelude} = await prerender(<App assetMap={assetMap} />, {
   // Careful: It's safe to stringify() this because this data isn't user-generated.
   bootstrapScriptContent: `window.assetMap = ${JSON.stringify(assetMap)};`,
   bootstrapScripts: [assetMap['/main.js']],
 });
 return new Response(prelude, {
   headers: { 'content-type': 'text/html' },
 });
}
In the example above, the bootstrapScriptContent option adds an extra inline <script> tag that sets the global window.assetMap variable on the client. This lets the client code read the same assetMap:
import { hydrateRoot } from 'react-dom/client';
import App from './App.js';

hydrateRoot(document, <App assetMap={window.assetMap} />);
Both client and server render App with the same assetMap prop, so there are no hydration errors.

Rendering a React tree to a string of static HTML 
Call prerender to render your app to a static HTML string:
import { prerender } from 'react-dom/static';

async function renderToString() {
 const {prelude} = await prerender(<App />, {
   bootstrapScripts: ['/main.js']
 });

 const reader = prelude.getReader();
 let content = '';
 while (true) {
   const {done, value} = await reader.read();
   if (done) {
     return content;
   }
   content += Buffer.from(value).toString('utf8');
 }
}
This will produce the initial non-interactive HTML output of your React components. On the client, you will need to call hydrateRoot to hydrate that server-generated HTML and make it interactive.

Waiting for all data to load 
prerender waits for all data to load before finishing the static HTML generation and resolving. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:
function ProfilePage() {
 return (
   <ProfileLayout>
     <ProfileCover />
     <Sidebar>
       <Friends />
       <Photos />
     </Sidebar>
     <Suspense fallback={<PostsGlimmer />}>
       <Posts />
     </Suspense>
   </ProfileLayout>
 );
}
Imagine that <Posts /> needs to load some data, which takes some time. Ideally, you’d want wait for the posts to finish so it’s included in the HTML. To do this, you can use Suspense to suspend on the data, and prerender will wait for the suspended content to finish before resolving to the static HTML.
Note
Only Suspense-enabled data sources will activate the Suspense component. They include:
Data fetching with Suspense-enabled frameworks like Relay and Next.js
Lazy-loading component code with lazy
Reading the value of a Promise with use
Suspense does not detect when data is fetched inside an Effect or event handler.
The exact way you would load data in the Posts component above depends on your framework. If you use a Suspense-enabled framework, you’ll find the details in its data fetching documentation.
Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.

Aborting prerendering 
You can force the prerender to “give up” after a timeout:
async function renderToString() {
 const controller = new AbortController();
 setTimeout(() => {
   controller.abort()
 }, 10000);

 try {
   // the prelude will contain all the HTML that was prerendered
   // before the controller aborted.
   const {prelude} = await prerender(<App />, {
     signal: controller.signal,
   });
   //...
Any Suspense boundaries with incomplete children will be included in the prelude in the fallback state.

Troubleshooting 
My stream doesn’t start until the entire app is rendered 
The prerender response waits for the entire app to finish rendering, including waiting for all Suspense boundaries to resolve, before resolving. It is designed for static site generation (SSG) ahead of time and does not support streaming more content as it loads.
To stream content as it loads, use a streaming server render API like renderToReadableStream.
prerenderToNodeStream
prerenderToNodeStream renders a React tree to a static HTML string using a Node.js Stream..
const {prelude} = await prerenderToNodeStream(reactNode, options?)
Reference
prerenderToNodeStream(reactNode, options?)
Usage
Rendering a React tree to a stream of static HTML
Rendering a React tree to a string of static HTML
Waiting for all data to load
Aborting prerendering
Troubleshooting
My stream doesn’t start until the entire app is rendered
Note
This API is specific to Node.js. Environments with Web Streams, like Deno and modern edge runtimes, should use prerender instead.

Reference 
prerenderToNodeStream(reactNode, options?) 
Call prerenderToNodeStream to render your app to static HTML.
import { prerenderToNodeStream } from 'react-dom/static';

// The route handler syntax depends on your backend framework
app.use('/', async (request, response) => {
 const { prelude } = await prerenderToNodeStream(<App />, {
   bootstrapScripts: ['/main.js'],
 });

 response.setHeader('Content-Type', 'text/plain');
 prelude.pipe(response);
});
On the client, call hydrateRoot to make the server-generated HTML interactive.
See more examples below.
Parameters 
reactNode: A React node you want to render to HTML. For example, a JSX node like <App />. It is expected to represent the entire document, so the App component should render the <html> tag.
optional options: An object with static generation options.
optional bootstrapScriptContent: If specified, this string will be placed in an inline <script> tag.
optional bootstrapScripts: An array of string URLs for the <script> tags to emit on the page. Use this to include the <script> that calls hydrateRoot. Omit it if you don’t want to run React on the client at all.
optional bootstrapModules: Like bootstrapScripts, but emits <script type="module"> instead.
optional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to hydrateRoot.
optional namespaceURI: A string with the root namespace URI for the stream. Defaults to regular HTML. Pass 'http://www.w3.org/2000/svg' for SVG or 'http://www.w3.org/1998/Math/MathML' for MathML.
optional onError: A callback that fires whenever there is a server error, whether recoverable or not. By default, this only calls console.error. If you override it to log crash reports, make sure that you still call console.error. You can also use it to adjust the status code before the shell is emitted.
optional progressiveChunkSize: The number of bytes in a chunk. Read more about the default heuristic.
optional signal: An abort signal that lets you abort prerendering and render the rest on the client.
Returns 
prerenderToNodeStream returns a Promise:
If rendering the is successful, the Promise will resolve to an object containing:
prelude: a Node.js Stream. of HTML. You can use this stream to send a response in chunks, or you can read the entire stream into a string.
If rendering fails, the Promise will be rejected. Use this to output a fallback shell.
Caveats 
nonce is not an available option when prerendering. Nonces must be unique per request and if you use nonces to secure your application with CSP it would be inappropriate and insecure to include the nonce value in the prerender itself.
Note
When should I use prerenderToNodeStream? 
The static prerenderToNodeStream API is used for static server-side generation (SSG). Unlike renderToString, prerenderToNodeStream waits for all data to load before resolving. This makes it suitable for generating static HTML for a full page, including data that needs to be fetched using Suspense. To stream content as it loads, use a streaming server-side render (SSR) API like renderToReadableStream.

Usage 
Rendering a React tree to a stream of static HTML 
Call prerenderToNodeStream to render your React tree to static HTML into a Node.js Stream.:
import { prerenderToNodeStream } from 'react-dom/static';

// The route handler syntax depends on your backend framework
app.use('/', async (request, response) => {
 const { prelude } = await prerenderToNodeStream(<App />, {
   bootstrapScripts: ['/main.js'],
 });

 response.setHeader('Content-Type', 'text/plain');
 prelude.pipe(response);
});
Along with the root component, you need to provide a list of bootstrap <script> paths. Your root component should return the entire document including the root <html> tag.
For example, it might look like this:
export default function App() {
 return (
   <html>
     <head>
       <meta charSet="utf-8" />
       <meta name="viewport" content="width=device-width, initial-scale=1" />
       <link rel="stylesheet" href="/styles.css"></link>
       <title>My app</title>
     </head>
     <body>
       <Router />
     </body>
   </html>
 );
}
React will inject the doctype and your bootstrap <script> tags into the resulting HTML stream:
<!DOCTYPE html>
<html>
 <!-- ... HTML from your components ... -->
</html>
<script src="/main.js" async=""></script>
On the client, your bootstrap script should hydrate the entire document with a call to hydrateRoot:
import { hydrateRoot } from 'react-dom/client';
import App from './App.js';

hydrateRoot(document, <App />);
This will attach event listeners to the static server-generated HTML and make it interactive.
Deep Dive
Reading CSS and JS asset paths from the build output 
Hide Details
The final asset URLs (like JavaScript and CSS files) are often hashed after the build. For example, instead of styles.css you might end up with styles.123456.css. Hashing static asset filenames guarantees that every distinct build of the same asset will have a different filename. This is useful because it lets you safely enable long-term caching for static assets: a file with a certain name would never change content.
However, if you don’t know the asset URLs until after the build, there’s no way for you to put them in the source code. For example, hardcoding "/styles.css" into JSX like earlier wouldn’t work. To keep them out of your source code, your root component can read the real filenames from a map passed as a prop:
export default function App({ assetMap }) {
 return (
   <html>
     <head>
       <title>My app</title>
       <link rel="stylesheet" href={assetMap['styles.css']}></link>
     </head>
     ...
   </html>
 );
}
On the server, render <App assetMap={assetMap} /> and pass your assetMap with the asset URLs:
// You'd need to get this JSON from your build tooling, e.g. read it from the build output.
const assetMap = {
 'styles.css': '/styles.123456.css',
 'main.js': '/main.123456.js'
};

app.use('/', async (request, response) => {
 const { prelude } = await prerenderToNodeStream(<App />, {
   bootstrapScripts: [assetMap['/main.js']]
 });

 response.setHeader('Content-Type', 'text/html');
 prelude.pipe(response);
});
Since your server is now rendering <App assetMap={assetMap} />, you need to render it with assetMap on the client too to avoid hydration errors. You can serialize and pass assetMap to the client like this:
// You'd need to get this JSON from your build tooling.
const assetMap = {
 'styles.css': '/styles.123456.css',
 'main.js': '/main.123456.js'
};

app.use('/', async (request, response) => {
 const { prelude } = await prerenderToNodeStream(<App />, {
   // Careful: It's safe to stringify() this because this data isn't user-generated.
   bootstrapScriptContent: `window.assetMap = ${JSON.stringify(assetMap)};`,
   bootstrapScripts: [assetMap['/main.js']],
 });

 response.setHeader('Content-Type', 'text/html');
 prelude.pipe(response);
});
In the example above, the bootstrapScriptContent option adds an extra inline <script> tag that sets the global window.assetMap variable on the client. This lets the client code read the same assetMap:
import { hydrateRoot } from 'react-dom/client';
import App from './App.js';

hydrateRoot(document, <App assetMap={window.assetMap} />);
Both client and server render App with the same assetMap prop, so there are no hydration errors.

Rendering a React tree to a string of static HTML 
Call prerenderToNodeStream to render your app to a static HTML string:
import { prerenderToNodeStream } from 'react-dom/static';

async function renderToString() {
 const {prelude} = await prerenderToNodeStream(<App />, {
   bootstrapScripts: ['/main.js']
 });

 return new Promise((resolve, reject) => {
   let data = '';
   prelude.on('data', chunk => {
     data += chunk;
   });
   prelude.on('end', () => resolve(data));
   prelude.on('error', reject);
 });
}
This will produce the initial non-interactive HTML output of your React components. On the client, you will need to call hydrateRoot to hydrate that server-generated HTML and make it interactive.

Waiting for all data to load 
prerenderToNodeStream waits for all data to load before finishing the static HTML generation and resolving. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:
function ProfilePage() {
 return (
   <ProfileLayout>
     <ProfileCover />
     <Sidebar>
       <Friends />
       <Photos />
     </Sidebar>
     <Suspense fallback={<PostsGlimmer />}>
       <Posts />
     </Suspense>
   </ProfileLayout>
 );
}
Imagine that <Posts /> needs to load some data, which takes some time. Ideally, you’d want wait for the posts to finish so it’s included in the HTML. To do this, you can use Suspense to suspend on the data, and prerenderToNodeStream will wait for the suspended content to finish before resolving to the static HTML.
Note
Only Suspense-enabled data sources will activate the Suspense component. They include:
Data fetching with Suspense-enabled frameworks like Relay and Next.js
Lazy-loading component code with lazy
Reading the value of a Promise with use
Suspense does not detect when data is fetched inside an Effect or event handler.
The exact way you would load data in the Posts component above depends on your framework. If you use a Suspense-enabled framework, you’ll find the details in its data fetching documentation.
Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.

Aborting prerendering 
You can force the prerender to “give up” after a timeout:
async function renderToString() {
 const controller = new AbortController();
 setTimeout(() => {
   controller.abort()
 }, 10000);

 try {
   // the prelude will contain all the HTML that was prerendered
   // before the controller aborted.
   const {prelude} = await prerenderToNodeStream(<App />, {
     signal: controller.signal,
   });
   //...
Any Suspense boundaries with incomplete children will be included in the prelude in the fallback state.

Troubleshooting 
My stream doesn’t start until the entire app is rendered 
The prerenderToNodeStream response waits for the entire app to finish rendering, including waiting for all Suspense boundaries to resolve, before resolving. It is designed for static site generation (SSG) ahead of time and does not support streaming more content as it loads.
To stream content as it loads, use a streaming server render API like renderToPipeableStream.
Rules of React
Just as different programming languages have their own ways of expressing concepts, React has its own idioms — or rules — for how to express patterns in a way that is easy to understand and yields high-quality applications.
Components and Hooks must be pure
React calls Components and Hooks
Rules of Hooks

Note
To learn more about expressing UIs with React, we recommend reading Thinking in React.
This section describes the rules you need to follow to write idiomatic React code. Writing idiomatic React code can help you write well organized, safe, and composable applications. These properties make your app more resilient to changes and makes it easier to work with other developers, libraries, and tools.
These rules are known as the Rules of React. They are rules – and not just guidelines – in the sense that if they are broken, your app likely has bugs. Your code also becomes unidiomatic and harder to understand and reason about.
We strongly recommend using Strict Mode alongside React’s ESLint plugin to help your codebase follow the Rules of React. By following the Rules of React, you’ll be able to find and address these bugs and keep your application maintainable.

Components and Hooks must be pure 
Purity in Components and Hooks is a key rule of React that makes your app predictable, easy to debug, and allows React to automatically optimize your code.
Components must be idempotent – React components are assumed to always return the same output with respect to their inputs – props, state, and context.
Side effects must run outside of render – Side effects should not run in render, as React can render components multiple times to create the best possible user experience.
Props and state are immutable – A component’s props and state are immutable snapshots with respect to a single render. Never mutate them directly.
Return values and arguments to Hooks are immutable – Once values are passed to a Hook, you should not modify them. Like props in JSX, values become immutable when passed to a Hook.
Values are immutable after being passed to JSX – Don’t mutate values after they’ve been used in JSX. Move the mutation before the JSX is created.

React calls Components and Hooks 
React is responsible for rendering components and hooks when necessary to optimize the user experience. It is declarative: you tell React what to render in your component’s logic, and React will figure out how best to display it to your user.
Never call component functions directly – Components should only be used in JSX. Don’t call them as regular functions.
Never pass around hooks as regular values – Hooks should only be called inside of components. Never pass it around as a regular value.

Rules of Hooks 
Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called. You need to follow the Rules of Hooks when using them.
Only call Hooks at the top level – Don’t call Hooks inside loops, conditions, or nested functions. Instead, always use Hooks at the top level of your React function, before any early returns.
Only call Hooks from React functions – Don’t call Hooks from regular JavaScript functions.

Components and Hooks must be pure
Pure functions only perform a calculation and nothing more. It makes your code easier to understand, debug, and allows React to automatically optimize your components and Hooks correctly.
Note
This reference page covers advanced topics and requires familiarity with the concepts covered in the Keeping Components Pure page.
Why does purity matter?
Components and Hooks must be idempotent
Side effects must run outside of render
When is it okay to have mutation?
Props and state are immutable
Don’t mutate Props
Don’t mutate State
Return values and arguments to Hooks are immutable
Values are immutable after being passed to JSX
Why does purity matter? 
One of the key concepts that makes React, React is purity. A pure component or hook is one that is:
Idempotent – You always get the same result every time you run it with the same inputs – props, state, context for component inputs; and arguments for hook inputs.
Has no side effects in render – Code with side effects should run separately from rendering. For example as an event handler – where the user interacts with the UI and causes it to update; or as an Effect – which runs after render.
Does not mutate non-local values: Components and Hooks should never modify values that aren’t created locally in render.
When render is kept pure, React can understand how to prioritize which updates are most important for the user to see first. This is made possible because of render purity: since components don’t have side effects in render, React can pause rendering components that aren’t as important to update, and only come back to them later when it’s needed.
Concretely, this means that rendering logic can be run multiple times in a way that allows React to give your user a pleasant user experience. However, if your component has an untracked side effect – like modifying the value of a global variable during render – when React runs your rendering code again, your side effects will be triggered in a way that won’t match what you want. This often leads to unexpected bugs that can degrade how your users experience your app. You can see an example of this in the Keeping Components Pure page.
How does React run your code? 
React is declarative: you tell React what to render, and React will figure out how best to display it to your user. To do this, React has a few phases where it runs your code. You don’t need to know about all of these phases to use React well. But at a high level, you should know about what code runs in render, and what runs outside of it.
Rendering refers to calculating what the next version of your UI should look like. After rendering, Effects are flushed (meaning they are run until there are no more left) and may update the calculation if the Effects have impacts on layout. React takes this new calculation and compares it to the calculation used to create the previous version of your UI, then commits just the minimum changes needed to the DOM (what your user actually sees) to catch it up to the latest version.
Deep Dive
How to tell if code runs in render 
Hide Details
One quick heuristic to tell if code runs during render is to examine where it is: if it’s written at the top level like in the example below, there’s a good chance it runs during render.
function Dropdown() {
 const selectedItems = new Set(); // created during render
 // ...
}
Event handlers and Effects don’t run in render:
function Dropdown() {
 const selectedItems = new Set();
 const onSelect = (item) => {
   // this code is in an event handler, so it's only run when the user triggers this
   selectedItems.add(item);
 }
}
function Dropdown() {
 const selectedItems = new Set();
 useEffect(() => {
   // this code is inside of an Effect, so it only runs after rendering
   logForAnalytics(selectedItems);
 }, [selectedItems]);
}

Components and Hooks must be idempotent 
Components must always return the same output with respect to their inputs – props, state, and context. This is known as idempotency. Idempotency is a term popularized in functional programming. It refers to the idea that you always get the same result every time you run that piece of code with the same inputs.
This means that all code that runs during render must also be idempotent in order for this rule to hold. For example, this line of code is not idempotent (and therefore, neither is the component):
function Clock() {
 const time = new Date(); // 🔴 Bad: always returns a different result!
 return <span>{time.toLocaleString()}</span>
}
new Date() is not idempotent as it always returns the current date and changes its result every time it’s called. When you render the above component, the time displayed on the screen will stay stuck on the time that the component was rendered. Similarly, functions like Math.random() also aren’t idempotent, because they return different results every time they’re called, even when the inputs are the same.
This doesn’t mean you shouldn’t use non-idempotent functions like new Date() at all – you should just avoid using them during render. In this case, we can synchronize the latest date to this component using an Effect:
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
import { useState, useEffect } from 'react';

function useTime() {
 // 1. Keep track of the current date's state. `useState` receives an initializer function as its
 //    initial state. It only runs once when the hook is called, so only the current date at the
 //    time the hook is called is set first.
 const [time, setTime] = useState(() => new Date());

 useEffect(() => {
   // 2. Update the current date every second using `setInterval`.
   const id = setInterval(() => {
     setTime(new Date()); // ✅ Good: non-idempotent code no longer runs in render
   }, 1000);
   // 3. Return a cleanup function so we don't leak the `setInterval` timer.
   return () => clearInterval(id);
 }, []);

 return time;
}

export default function Clock() {
 const time = useTime();
 return <span>{time.toLocaleString()}</span>;
}

Show more
By wrapping the non-idempotent new Date() call in an Effect, it moves that calculation outside of rendering.
If you don’t need to synchronize some external state with React, you can also consider using an event handler if it only needs to be updated in response to a user interaction.

Side effects must run outside of render 
Side effects should not run in render, as React can render components multiple times to create the best possible user experience.
Note
Side effects are a broader term than Effects. Effects specifically refer to code that’s wrapped in useEffect, while a side effect is a general term for code that has any observable effect other than its primary result of returning a value to the caller.
Side effects are typically written inside of event handlers or Effects. But never during render.
While render must be kept pure, side effects are necessary at some point in order for your app to do anything interesting, like showing something on the screen! The key point of this rule is that side effects should not run in render, as React can render components multiple times. In most cases, you’ll use event handlers to handle side effects. Using an event handler explicitly tells React that this code doesn’t need to run during render, keeping render pure. If you’ve exhausted all options – and only as a last resort – you can also handle side effects using useEffect.
When is it okay to have mutation? 
Local mutation 
One common example of a side effect is mutation, which in JavaScript refers to changing the value of a non-primitive value. In general, while mutation is not idiomatic in React, local mutation is absolutely fine:
function FriendList({ friends }) {
 const items = []; // ✅ Good: locally created
 for (let i = 0; i < friends.length; i++) {
   const friend = friends[i];
   items.push(
     <Friend key={friend.id} friend={friend} />
   ); // ✅ Good: local mutation is okay
 }
 return <section>{items}</section>;
}
There is no need to contort your code to avoid local mutation. Array.map could also be used here for brevity, but there is nothing wrong with creating a local array and then pushing items into it during render.
Even though it looks like we are mutating items, the key point to note is that this code only does so locally – the mutation isn’t “remembered” when the component is rendered again. In other words, items only stays around as long as the component does. Because items is always recreated every time <FriendList /> is rendered, the component will always return the same result.
On the other hand, if items was created outside of the component, it holds on to its previous values and remembers changes:
const items = []; // 🔴 Bad: created outside of the component
function FriendList({ friends }) {
 for (let i = 0; i < friends.length; i++) {
   const friend = friends[i];
   items.push(
     <Friend key={friend.id} friend={friend} />
   ); // 🔴 Bad: mutates a value created outside of render
 }
 return <section>{items}</section>;
}
When <FriendList /> runs again, we will continue appending friends to items every time that component is run, leading to multiple duplicated results. This version of <FriendList /> has observable side effects during render and breaks the rule.
Lazy initialization 
Lazy initialization is also fine despite not being fully “pure”:
function ExpenseForm() {
 SuperCalculator.initializeIfNotReady(); // ✅ Good: if it doesn't affect other components
 // Continue rendering...
}
Changing the DOM 
Side effects that are directly visible to the user are not allowed in the render logic of React components. In other words, merely calling a component function shouldn’t by itself produce a change on the screen.
function ProductDetailPage({ product }) {
 document.title = product.title; // 🔴 Bad: Changes the DOM
}
One way to achieve the desired result of updating document.title outside of render is to synchronize the component with document.
As long as calling a component multiple times is safe and doesn’t affect the rendering of other components, React doesn’t care if it’s 100% pure in the strict functional programming sense of the word. It is more important that components must be idempotent.

Props and state are immutable 
A component’s props and state are immutable snapshots. Never mutate them directly. Instead, pass new props down, and use the setter function from useState.
You can think of the props and state values as snapshots that are updated after rendering. For this reason, you don’t modify the props or state variables directly: instead you pass new props, or use the setter function provided to you to tell React that state needs to update the next time the component is rendered.
Don’t mutate Props 
Props are immutable because if you mutate them, the application will produce inconsistent output, which can be hard to debug as it may or may not work depending on the circumstances.
function Post({ item }) {
 item.url = new Url(item.url, base); // 🔴 Bad: never mutate props directly
 return <Link url={item.url}>{item.title}</Link>;
}
function Post({ item }) {
 const url = new Url(item.url, base); // ✅ Good: make a copy instead
 return <Link url={url}>{item.title}</Link>;
}
Don’t mutate State 
useState returns the state variable and a setter to update that state.
const [stateVariable, setter] = useState(0);
Rather than updating the state variable in-place, we need to update it using the setter function that is returned by useState. Changing values on the state variable doesn’t cause the component to update, leaving your users with an outdated UI. Using the setter function informs React that the state has changed, and that we need to queue a re-render to update the UI.
function Counter() {
 const [count, setCount] = useState(0);

 function handleClick() {
   count = count + 1; // 🔴 Bad: never mutate state directly
 }

 return (
   <button onClick={handleClick}>
     You pressed me {count} times
   </button>
 );
}
function Counter() {
 const [count, setCount] = useState(0);

 function handleClick() {
   setCount(count + 1); // ✅ Good: use the setter function returned by useState
 }

 return (
   <button onClick={handleClick}>
     You pressed me {count} times
   </button>
 );
}

Return values and arguments to Hooks are immutable 
Once values are passed to a hook, you should not modify them. Like props in JSX, values become immutable when passed to a hook.
function useIconStyle(icon) {
 const theme = useContext(ThemeContext);
 if (icon.enabled) {
   icon.className = computeStyle(icon, theme); // 🔴 Bad: never mutate hook arguments directly
 }
 return icon;
}
function useIconStyle(icon) {
 const theme = useContext(ThemeContext);
 const newIcon = { ...icon }; // ✅ Good: make a copy instead
 if (icon.enabled) {
   newIcon.className = computeStyle(icon, theme);
 }
 return newIcon;
}
One important principle in React is local reasoning: the ability to understand what a component or hook does by looking at its code in isolation. Hooks should be treated like “black boxes” when they are called. For example, a custom hook might have used its arguments as dependencies to memoize values inside it:
function useIconStyle(icon) {
 const theme = useContext(ThemeContext);

 return useMemo(() => {
   const newIcon = { ...icon };
   if (icon.enabled) {
     newIcon.className = computeStyle(icon, theme);
   }
   return newIcon;
 }, [icon, theme]);
}
If you were to mutate the Hook’s arguments, the custom hook’s memoization will become incorrect,  so it’s important to avoid doing that.
style = useIconStyle(icon);         // `style` is memoized based on `icon`
icon.enabled = false;               // Bad: 🔴 never mutate hook arguments directly
style = useIconStyle(icon);         // previously memoized result is returned
style = useIconStyle(icon);         // `style` is memoized based on `icon`
icon = { ...icon, enabled: false }; // Good: ✅ make a copy instead
style = useIconStyle(icon);         // new value of `style` is calculated
Similarly, it’s important to not modify the return values of Hooks, as they may have been memoized.

Values are immutable after being passed to JSX 
Don’t mutate values after they’ve been used in JSX. Move the mutation to before the JSX is created.
When you use JSX in an expression, React may eagerly evaluate the JSX before the component finishes rendering. This means that mutating values after they’ve been passed to JSX can lead to outdated UIs, as React won’t know to update the component’s output.
function Page({ colour }) {
 const styles = { colour, size: "large" };
 const header = <Header styles={styles} />;
 styles.size = "small"; // 🔴 Bad: styles was already used in the JSX above
 const footer = <Footer styles={styles} />;
 return (
   <>
     {header}
     <Content />
     {footer}
   </>
 );
}
function Page({ colour }) {
 const headerStyles = { colour, size: "large" };
 const header = <Header styles={headerStyles} />;
 const footerStyles = { colour, size: "small" }; // ✅ Good: we created a new value
 const footer = <Footer styles={footerStyles} />;
 return (
   <>
     {header}
     <Content />
     {footer}
   </>
 );
}

React calls Components and Hooks
React is responsible for rendering components and Hooks when necessary to optimize the user experience. It is declarative: you tell React what to render in your component’s logic, and React will figure out how best to display it to your user.
Never call component functions directly
Never pass around Hooks as regular values
Don’t dynamically mutate a Hook
Don’t dynamically use Hooks

Never call component functions directly 
Components should only be used in JSX. Don’t call them as regular functions. React should call it.
React must decide when your component function is called during rendering. In React, you do this using JSX.
function BlogPost() {
 return <Layout><Article /></Layout>; // ✅ Good: Only use components in JSX
}
function BlogPost() {
 return <Layout>{Article()}</Layout>; // 🔴 Bad: Never call them directly
}
If a component contains Hooks, it’s easy to violate the Rules of Hooks when components are called directly in a loop or conditionally.
Letting React orchestrate rendering also allows a number of benefits:
Components become more than functions. React can augment them with features like local state through Hooks that are tied to the component’s identity in the tree.
Component types participate in reconciliation. By letting React call your components, you also tell it more about the conceptual structure of your tree. For example, when you move from rendering <Feed> to the <Profile> page, React won’t attempt to re-use them.
React can enhance your user experience. For example, it can let the browser do some work between component calls so that re-rendering a large component tree doesn’t block the main thread.
A better debugging story. If components are first-class citizens that the library is aware of, we can build rich developer tools for introspection in development.
More efficient reconciliation. React can decide exactly which components in the tree need re-rendering and skip over the ones that don’t. That makes your app faster and more snappy.

Never pass around Hooks as regular values 
Hooks should only be called inside of components or Hooks. Never pass it around as a regular value.
Hooks allow you to augment a component with React features. They should always be called as a function, and never passed around as a regular value. This enables local reasoning, or the ability for developers to understand everything a component can do by looking at that component in isolation.
Breaking this rule will cause React to not automatically optimize your component.
Don’t dynamically mutate a Hook 
Hooks should be as “static” as possible. This means you shouldn’t dynamically mutate them. For example, this means you shouldn’t write higher order Hooks:
function ChatInput() {
 const useDataWithLogging = withLogging(useData); // 🔴 Bad: don't write higher order Hooks
 const data = useDataWithLogging();
}
Hooks should be immutable and not be mutated. Instead of mutating a Hook dynamically, create a static version of the Hook with the desired functionality.
function ChatInput() {
 const data = useDataWithLogging(); // ✅ Good: Create a new version of the Hook
}

function useDataWithLogging() {
 // ... Create a new version of the Hook and inline the logic here
}
Don’t dynamically use Hooks 
Hooks should also not be dynamically used: for example, instead of doing dependency injection in a component by passing a Hook as a value:
function ChatInput() {
 return <Button useData={useDataWithLogging} /> // 🔴 Bad: don't pass Hooks as props
}
You should always inline the call of the Hook into that component and handle any logic in there.
function ChatInput() {
 return <Button />
}

function Button() {
 const data = useDataWithLogging(); // ✅ Good: Use the Hook directly
}

function useDataWithLogging() {
 // If there's any conditional logic to change the Hook's behavior, it should be inlined into
 // the Hook
}
This way, <Button /> is much easier to understand and debug. When Hooks are used in dynamic ways, it increases the complexity of your app greatly and inhibits local reasoning, making your team less productive in the long term. It also makes it easier to accidentally break the Rules of Hooks that Hooks should not be called conditionally. If you find yourself needing to mock components for tests, it’s better to mock the server instead to respond with canned data. If possible, it’s also usually more effective to test your app with end-to-end tests.
Rules of Hooks
Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called.
Only call Hooks at the top level
Only call Hooks from React functions

Only call Hooks at the top level 
Functions whose names start with use are called Hooks in React.
Don’t call Hooks inside loops, conditions, nested functions, or try/catch/finally blocks. Instead, always use Hooks at the top level of your React function, before any early returns. You can only call Hooks while React is rendering a function component:
✅ Call them at the top level in the body of a function component.
✅ Call them at the top level in the body of a custom Hook.
function Counter() {
 // ✅ Good: top-level in a function component
 const [count, setCount] = useState(0);
 // ...
}

function useWindowWidth() {
 // ✅ Good: top-level in a custom Hook
 const [width, setWidth] = useState(window.innerWidth);
 // ...
}
It’s not supported to call Hooks (functions starting with use) in any other cases, for example:
🔴 Do not call Hooks inside conditions or loops.
🔴 Do not call Hooks after a conditional return statement.
🔴 Do not call Hooks in event handlers.
🔴 Do not call Hooks in class components.
🔴 Do not call Hooks inside functions passed to useMemo, useReducer, or useEffect.
🔴 Do not call Hooks inside try/catch/finally blocks.
If you break these rules, you might see this error.
function Bad({ cond }) {
 if (cond) {
   // 🔴 Bad: inside a condition (to fix, move it outside!)
   const theme = useContext(ThemeContext);
 }
 // ...
}

function Bad() {
 for (let i = 0; i < 10; i++) {
   // 🔴 Bad: inside a loop (to fix, move it outside!)
   const theme = useContext(ThemeContext);
 }
 // ...
}

function Bad({ cond }) {
 if (cond) {
   return;
 }
 // 🔴 Bad: after a conditional return (to fix, move it before the return!)
 const theme = useContext(ThemeContext);
 // ...
}

function Bad() {
 function handleClick() {
   // 🔴 Bad: inside an event handler (to fix, move it outside!)
   const theme = useContext(ThemeContext);
 }
 // ...
}

function Bad() {
 const style = useMemo(() => {
   // 🔴 Bad: inside useMemo (to fix, move it outside!)
   const theme = useContext(ThemeContext);
   return createStyle(theme);
 });
 // ...
}

class Bad extends React.Component {
 render() {
   // 🔴 Bad: inside a class component (to fix, write a function component instead of a class!)
   useEffect(() => {})
   // ...
 }
}

function Bad() {
 try {
   // 🔴 Bad: inside try/catch/finally block (to fix, move it outside!)
   const [x, setX] = useState(0);
 } catch {
   const [x, setX] = useState(1);
 }
}
You can use the eslint-plugin-react-hooks plugin to catch these mistakes.
Note
Custom Hooks may call other Hooks (that’s their whole purpose). This works because custom Hooks are also supposed to only be called while a function component is rendering.

Only call Hooks from React functions 
Don’t call Hooks from regular JavaScript functions. Instead, you can:
✅ Call Hooks from React function components.
✅ Call Hooks from custom Hooks.
By following this rule, you ensure that all stateful logic in a component is clearly visible from its source code.
function FriendList() {
 const [onlineStatus, setOnlineStatus] = useOnlineStatus(); // ✅
}

function setOnlineStatus() { // ❌ Not a component or custom Hook!
 const [onlineStatus, setOnlineStatus] = useOnlineStatus();
}

Server Components
React Server Components
Server Components are for use in React Server Components.
Server Components are a new type of Component that renders ahead of time, before bundling, in an environment separate from your client app or SSR server.
This separate environment is the “server” in React Server Components. Server Components can run once at build time on your CI server, or they can be run for each request using a web server.
Server Components without a Server
Server Components with a Server
Adding interactivity to Server Components
Async components with Server Components
Note
How do I build support for Server Components? 
While React Server Components in React 19 are stable and will not break between minor versions, the underlying APIs used to implement a React Server Components bundler or framework do not follow semver and may break between minors in React 19.x.
To support React Server Components as a bundler or framework, we recommend pinning to a specific React version, or using the Canary release. We will continue working with bundlers and frameworks to stabilize the APIs used to implement React Server Components in the future.
Server Components without a Server 
Server components can run at build time to read from the filesystem or fetch static content, so a web server is not required. For example, you may want to read static data from a content management system.
Without Server Components, it’s common to fetch static data on the client with an Effect:
// bundle.js
import marked from 'marked'; // 35.9K (11.2K gzipped)
import sanitizeHtml from 'sanitize-html'; // 206K (63.3K gzipped)

function Page({page}) {
 const [content, setContent] = useState('');
 // NOTE: loads *after* first page render.
 useEffect(() => {
   fetch(`/api/content/${page}`).then((data) => {
     setContent(data.content);
   });
 }, [page]);

 return <div>{sanitizeHtml(marked(content))}</div>;
}
// api.js
app.get(`/api/content/:page`, async (req, res) => {
 const page = req.params.page;
 const content = await file.readFile(`${page}.md`);
 res.send({content});
});
This pattern means users need to download and parse an additional 75K (gzipped) of libraries, and wait for a second request to fetch the data after the page loads, just to render static content that will not change for the lifetime of the page.
With Server Components, you can render these components once at build time:
import marked from 'marked'; // Not included in bundle
import sanitizeHtml from 'sanitize-html'; // Not included in bundle

async function Page({page}) {
 // NOTE: loads *during* render, when the app is built.
 const content = await file.readFile(`${page}.md`);

 return <div>{sanitizeHtml(marked(content))}</div>;
}
The rendered output can then be server-side rendered (SSR) to HTML and uploaded to a CDN. When the app loads, the client will not see the original Page component, or the expensive libraries for rendering the markdown. The client will only see the rendered output:
<div><!-- html for markdown --></div>
This means the content is visible during first page load, and the bundle does not include the expensive libraries needed to render the static content.
Note
You may notice that the Server Component above is an async function:
async function Page({page}) {
 //...
}
Async Components are a new feature of Server Components that allow you to await in render.
See Async components with Server Components below.
Server Components with a Server 
Server Components can also run on a web server during a request for a page, letting you access your data layer without having to build an API. They are rendered before your application is bundled, and can pass data and JSX as props to Client Components.
Without Server Components, it’s common to fetch dynamic data on the client in an Effect:
// bundle.js
function Note({id}) {
 const [note, setNote] = useState('');
 // NOTE: loads *after* first render.
 useEffect(() => {
   fetch(`/api/notes/${id}`).then(data => {
     setNote(data.note);
   });
 }, [id]);

 return (
   <div>
     <Author id={note.authorId} />
     <p>{note}</p>
   </div>
 );
}

function Author({id}) {
 const [author, setAuthor] = useState('');
 // NOTE: loads *after* Note renders.
 // Causing an expensive client-server waterfall.
 useEffect(() => {
   fetch(`/api/authors/${id}`).then(data => {
     setAuthor(data.author);
   });
 }, [id]);

 return <span>By: {author.name}</span>;
}
// api
import db from './database';

app.get(`/api/notes/:id`, async (req, res) => {
 const note = await db.notes.get(id);
 res.send({note});
});

app.get(`/api/authors/:id`, async (req, res) => {
 const author = await db.authors.get(id);
 res.send({author});
});
With Server Components, you can read the data and render it in the component:
import db from './database';

async function Note({id}) {
 // NOTE: loads *during* render.
 const note = await db.notes.get(id);
 return (
   <div>
     <Author id={note.authorId} />
     <p>{note}</p>
   </div>
 );
}

async function Author({id}) {
 // NOTE: loads *after* Note,
 // but is fast if data is co-located.
 const author = await db.authors.get(id);
 return <span>By: {author.name}</span>;
}
The bundler then combines the data, rendered Server Components and dynamic Client Components into a bundle. Optionally, that bundle can then be server-side rendered (SSR) to create the initial HTML for the page. When the page loads, the browser does not see the original Note and Author components; only the rendered output is sent to the client:
<div>
 <span>By: The React Team</span>
 <p>React 19 is...</p>
</div>
Server Components can be made dynamic by re-fetching them from a server, where they can access the data and render again. This new application architecture combines the simple “request/response” mental model of server-centric Multi-Page Apps with the seamless interactivity of client-centric Single-Page Apps, giving you the best of both worlds.
Adding interactivity to Server Components 
Server Components are not sent to the browser, so they cannot use interactive APIs like useState. To add interactivity to Server Components, you can compose them with Client Component using the "use client" directive.
Note
There is no directive for Server Components. 
A common misunderstanding is that Server Components are denoted by "use server", but there is no directive for Server Components. The "use server" directive is used for Server Functions.
For more info, see the docs for Directives.
In the following example, the Notes Server Component imports an Expandable Client Component that uses state to toggle its expanded state:
// Server Component
import Expandable from './Expandable';

async function Notes() {
 const notes = await db.notes.getAll();
 return (
   <div>
     {notes.map(note => (
       <Expandable key={note.id}>
         <p note={note} />
       </Expandable>
     ))}
   </div>
 )
}
// Client Component
"use client"

export default function Expandable({children}) {
 const [expanded, setExpanded] = useState(false);
 return (
   <div>
     <button
       onClick={() => setExpanded(!expanded)}
     >
       Toggle
     </button>
     {expanded && children}
   </div>
 )
}
This works by first rendering Notes as a Server Component, and then instructing the bundler to create a bundle for the Client Component Expandable. In the browser, the Client Components will see output of the Server Components passed as props:
<head>
 <!-- the bundle for Client Components -->
 <script src="bundle.js" />
</head>
<body>
 <div>
   <Expandable key={1}>
     <p>this is the first note</p>
   </Expandable>
   <Expandable key={2}>
     <p>this is the second note</p>
   </Expandable>
   <!--...-->
 </div>
</body>
Async components with Server Components 
Server Components introduce a new way to write Components using async/await. When you await in an async component, React will suspend and wait for the promise to resolve before resuming rendering. This works across server/client boundaries with streaming support for Suspense.
You can even create a promise on the server, and await it on the client:
// Server Component
import db from './database';

async function Page({id}) {
 // Will suspend the Server Component.
 const note = await db.notes.get(id);

 // NOTE: not awaited, will start here and await on the client.
 const commentsPromise = db.comments.get(note.id);
 return (
   <div>
     {note}
     <Suspense fallback={<p>Loading Comments...</p>}>
       <Comments commentsPromise={commentsPromise} />
     </Suspense>
   </div>
 );
}
// Client Component
"use client";
import {use} from 'react';

function Comments({commentsPromise}) {
 // NOTE: this will resume the promise from the server.
 // It will suspend until the data is available.
 const comments = use(commentsPromise);
 return comments.map(commment => <p>{comment}</p>);
}
The note content is important data for the page to render, so we await it on the server. The comments are below the fold and lower-priority, so we start the promise on the server, and wait for it on the client with the use API. This will Suspend on the client, without blocking the note content from rendering.
Since async components are not supported on the client, we await the promise with use.
Server Functions
React Server Components
Server Functions are for use in React Server Components.
Note: Until September 2024, we referred to all Server Functions as “Server Actions”. If a Server Function is passed to an action prop or called from inside an action then it is a Server Action, but not all Server Functions are Server Actions. The naming in this documentation has been updated to reflect that Server Functions can be used for multiple purposes.
Server Functions allow Client Components to call async functions executed on the server.
Note
How do I build support for Server Functions? 
While Server Functions in React 19 are stable and will not break between minor versions, the underlying APIs used to implement Server Functions in a React Server Components bundler or framework do not follow semver and may break between minors in React 19.x.
To support Server Functions as a bundler or framework, we recommend pinning to a specific React version, or using the Canary release. We will continue working with bundlers and frameworks to stabilize the APIs used to implement Server Functions in the future.
When a Server Function is defined with the "use server" directive, your framework will automatically create a reference to the Server Function, and pass that reference to the Client Component. When that function is called on the client, React will send a request to the server to execute the function, and return the result.
Server Functions can be created in Server Components and passed as props to Client Components, or they can be imported and used in Client Components.
Usage 
Creating a Server Function from a Server Component 
Server Components can define Server Functions with the "use server" directive:
// Server Component
import Button from './Button';

function EmptyNote () {
 async function createNoteAction() {
   // Server Function
   'use server';
  
   await db.notes.create();
 }

 return <Button onClick={createNoteAction}/>;
}
When React renders the EmptyNote Server Component, it will create a reference to the createNoteAction function, and pass that reference to the Button Client Component. When the button is clicked, React will send a request to the server to execute the createNoteAction function with the reference provided:
"use client";

export default function Button({onClick}) {
 console.log(onClick);
 // {$$typeof: Symbol.for("react.server.reference"), $$id: 'createNoteAction'}
 return <button onClick={() => onClick()}>Create Empty Note</button>
}
For more, see the docs for "use server".
Importing Server Functions from Client Components 
Client Components can import Server Functions from files that use the "use server" directive:
"use server";

export async function createNote() {
 await db.notes.create();
}
When the bundler builds the EmptyNote Client Component, it will create a reference to the createNote function in the bundle. When the button is clicked, React will send a request to the server to execute the createNote function using the reference provided:
"use client";
import {createNote} from './actions';

function EmptyNote() {
 console.log(createNote);
 // {$$typeof: Symbol.for("react.server.reference"), $$id: 'createNote'}
 <button onClick={() => createNote()} />
}
For more, see the docs for "use server".
Server Functions with Actions 
Server Functions can be called from Actions on the client:
"use server";

export async function updateName(name) {
 if (!name) {
   return {error: 'Name is required'};
 }
 await db.users.updateName(name);
}
"use client";

import {updateName} from './actions';

function UpdateName() {
 const [name, setName] = useState('');
 const [error, setError] = useState(null);

 const [isPending, startTransition] = useTransition();

 const submitAction = async () => {
   startTransition(async () => {
     const {error} = await updateName(name);
     if (error) {
       setError(error);
     } else {
       setName('');
     }
   })
 }

 return (
   <form action={submitAction}>
     <input type="text" name="name" disabled={isPending}/>
     {error && <span>Failed: {error}</span>}
   </form>
 )
}
This allows you to access the isPending state of the Server Function by wrapping it in an Action on the client.
For more, see the docs for Calling a Server Function outside of <form>
Server Functions with Form Actions 
Server Functions work with the new Form features in React 19.
You can pass a Server Function to a Form to automatically submit the form to the server:
"use client";

import {updateName} from './actions';

function UpdateName() {
 return (
   <form action={updateName}>
     <input type="text" name="name" />
   </form>
 )
}
When the Form submission succeeds, React will automatically reset the form. You can add useActionState to access the pending state, last response, or to support progressive enhancement.
For more, see the docs for Server Functions in Forms.
Server Functions with useActionState 
You can call Server Functions with useActionState for the common case where you just need access to the action pending state and last returned response:
"use client";

import {updateName} from './actions';

function UpdateName() {
 const [state, submitAction, isPending] = useActionState(updateName, {error: null});

 return (
   <form action={submitAction}>
     <input type="text" name="name" disabled={isPending}/>
     {state.error && <span>Failed: {state.error}</span>}
   </form>
 );
}
When using useActionState with Server Functions, React will also automatically replay form submissions entered before hydration finishes. This means users can interact with your app even before the app has hydrated.
For more, see the docs for useActionState.
Progressive enhancement with useActionState 
Server Functions also support progressive enhancement with the third argument of useActionState.
"use client";

import {updateName} from './actions';

function UpdateName() {
 const [, submitAction] = useActionState(updateName, null, `/name/update`);

 return (
   <form action={submitAction}>
     ...
   </form>
 );
}
When the permalink is provided to useActionState, React will redirect to the provided URL if the form is submitted before the JavaScript bundle loads.
For more, see the docs for useActionState.
Directives
React Server Components
Directives are for use in React Server Components.
Directives provide instructions to bundlers compatible with React Server Components.

Source code directives 
'use client' lets you mark what code runs on the client.
'use server' marks server-side functions that can be called from client-side code.
PreviousServer Functions
'use client'
React Server Components
'use client' is for use with React Server Components.
'use client' lets you mark what code runs on the client.
Reference
'use client'
How 'use client' marks client code
When to use 'use client'
Serializable types returned by Server Components
Usage
Building with interactivity and state
Using client APIs
Using third-party libraries

Reference 
'use client' 
Add 'use client' at the top of a file to mark the module and its transitive dependencies as client code.
'use client';

import { useState } from 'react';
import { formatDate } from './formatters';
import Button from './button';

export default function RichTextEditor({ timestamp, text }) {
 const date = formatDate(timestamp);
 // ...
 const editButton = <Button />;
 // ...
}
When a file marked with 'use client' is imported from a Server Component, compatible bundlers will treat the module import as a boundary between server-run and client-run code.
As dependencies of RichTextEditor, formatDate and Button will also be evaluated on the client regardless of whether their modules contain a 'use client' directive. Note that a single module may be evaluated on the server when imported from server code and on the client when imported from client code.
Caveats 
'use client' must be at the very beginning of a file, above any imports or other code (comments are OK). They must be written with single or double quotes, but not backticks.
When a 'use client' module is imported from another client-rendered module, the directive has no effect.
When a component module contains a 'use client' directive, any usage of that component is guaranteed to be a Client Component. However, a component can still be evaluated on the client even if it does not have a 'use client' directive.
A component usage is considered a Client Component if it is defined in module with 'use client' directive or when it is a transitive dependency of a module that contains a 'use client' directive. Otherwise, it is a Server Component.
Code that is marked for client evaluation is not limited to components. All code that is a part of the Client module sub-tree is sent to and run by the client.
When a server evaluated module imports values from a 'use client' module, the values must either be a React component or supported serializable prop values to be passed to a Client Component. Any other use case will throw an exception.
How 'use client' marks client code 
In a React app, components are often split into separate files, or modules.
For apps that use React Server Components, the app is server-rendered by default. 'use client' introduces a server-client boundary in the module dependency tree, effectively creating a subtree of Client modules.
To better illustrate this, consider the following React Server Components app.
App.jsFancyText.jsInspirationGenerator.jsCopyright.jsinspirations.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
import FancyText from './FancyText';
import InspirationGenerator from './InspirationGenerator';
import Copyright from './Copyright';

export default function App() {
 return (
   <>
     <FancyText title text="Get Inspired App" />
     <InspirationGenerator>
       <Copyright year={2004} />
     </InspirationGenerator>
   </>
 );
}


In the module dependency tree of this example app, the 'use client' directive in InspirationGenerator.js marks that module and all of its transitive dependencies as Client modules. The subtree starting at InspirationGenerator.js is now marked as Client modules.

'use client' segments the module dependency tree of the React Server Components app, marking InspirationGenerator.js and all of its dependencies as client-rendered.
During render, the framework will server-render the root component and continue through the render tree, opting-out of evaluating any code imported from client-marked code.
The server-rendered portion of the render tree is then sent to the client. The client, with its client code downloaded, then completes rendering the rest of the tree.

The render tree for the React Server Components app. InspirationGenerator and its child component FancyText are components exported from client-marked code and considered Client Components.
We introduce the following definitions:
Client Components are components in a render tree that are rendered on the client.
Server Components are components in a render tree that are rendered on the server.
Working through the example app, App, FancyText and Copyright are all server-rendered and considered Server Components. As InspirationGenerator.js and its transitive dependencies are marked as client code, the component InspirationGenerator and its child component FancyText are Client Components.
Deep Dive
How is FancyText both a Server and a Client Component? 
Hide Details
By the above definitions, the component FancyText is both a Server and Client Component, how can that be?
First, let’s clarify that the term “component” is not very precise. Here are just two ways “component” can be understood:
A “component” can refer to a component definition. In most cases this will be a function.
// This is a definition of a component
function MyComponent() {
 return <p>My Component</p>
}
A “component” can also refer to a component usage of its definition.
import MyComponent from './MyComponent';

function App() {
 // This is a usage of a component
 return <MyComponent />;
}
Often, the imprecision is not important when explaining concepts, but in this case it is.
When we talk about Server or Client Components, we are referring to component usages.
If the component is defined in a module with a 'use client' directive, or the component is imported and called in a Client Component, then the component usage is a Client Component.
Otherwise, the component usage is a Server Component.

A render tree illustrates component usages.
Back to the question of FancyText, we see that the component definition does not have a 'use client' directive and it has two usages.
The usage of FancyText as a child of App, marks that usage as a Server Component. When FancyText is imported and called under InspirationGenerator, that usage of FancyText is a Client Component as InspirationGenerator contains a 'use client' directive.
This means that the component definition for FancyText will both be evaluated on the server and also downloaded by the client to render its Client Component usage.
Deep Dive
Why is Copyright a Server Component? 
Hide Details
Because Copyright is rendered as a child of the Client Component InspirationGenerator, you might be surprised that it is a Server Component.
Recall that 'use client' defines the boundary between server and client code on the module dependency tree, not the render tree.

'use client' defines the boundary between server and client code on the module dependency tree.
In the module dependency tree, we see that App.js imports and calls Copyright from the Copyright.js module. As Copyright.js does not contain a 'use client' directive, the component usage is rendered on the server. App is rendered on the server as it is the root component.
Client Components can render Server Components because you can pass JSX as props. In this case, InspirationGenerator receives Copyright as children. However, the InspirationGenerator module never directly imports the Copyright module nor calls the component, all of that is done by App. In fact, the Copyright component is fully executed before InspirationGenerator starts rendering.
The takeaway is that a parent-child render relationship between components does not guarantee the same render environment.
When to use 'use client' 
With 'use client', you can determine when components are Client Components. As Server Components are default, here is a brief overview of the advantages and limitations to Server Components to determine when you need to mark something as client rendered.
For simplicity, we talk about Server Components, but the same principles apply to all code in your app that is server run.
Advantages of Server Components 
Server Components can reduce the amount of code sent and run by the client. Only Client modules are bundled and evaluated by the client.
Server Components benefit from running on the server. They can access the local filesystem and may experience low latency for data fetches and network requests.
Limitations of Server Components 
Server Components cannot support interaction as event handlers must be registered and triggered by a client.
For example, event handlers like onClick can only be defined in Client Components.
Server Components cannot use most Hooks.
When Server Components are rendered, their output is essentially a list of components for the client to render. Server Components do not persist in memory after render and cannot have their own state.
Serializable types returned by Server Components 
As in any React app, parent components pass data to child components. As they are rendered in different environments, passing data from a Server Component to a Client Component requires extra consideration.
Prop values passed from a Server Component to Client Component must be serializable.
Serializable props include:
Primitives
string
number
bigint
boolean
undefined
null
symbol, only symbols registered in the global Symbol registry via Symbol.for
Iterables containing serializable values
String
Array
Map
Set
TypedArray and ArrayBuffer
Date
Plain objects: those created with object initializers, with serializable properties
Functions that are Server Functions
Client or Server Component elements (JSX)
Promises
Notably, these are not supported:
Functions that are not exported from client-marked modules or marked with 'use server'
Classes
Objects that are instances of any class (other than the built-ins mentioned) or objects with a null prototype
Symbols not registered globally, ex. Symbol('my new symbol')
Usage 
Building with interactivity and state 
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
'use client';

import { useState } from 'react';

export default function Counter({initialValue = 0}) {
 const [countValue, setCountValue] = useState(initialValue);
 const increment = () => setCountValue(countValue + 1);
 const decrement = () => setCountValue(countValue - 1);
 return (
   <>
     <h2>Count Value: {countValue}</h2>
     <button onClick={increment}>+1</button>
     <button onClick={decrement}>-1</button>
   </>
 );
}

Show more
As Counter requires both the useState Hook and event handlers to increment or decrement the value, this component must be a Client Component and will require a 'use client' directive at the top.
In contrast, a component that renders UI without interaction will not need to be a Client Component.
import { readFile } from 'node:fs/promises';
import Counter from './Counter';

export default async function CounterContainer() {
 const initialValue = await readFile('/path/to/counter_value');
 return <Counter initialValue={initialValue} />
}
For example, Counter’s parent component, CounterContainer, does not require 'use client' as it is not interactive and does not use state. In addition, CounterContainer must be a Server Component as it reads from the local file system on the server, which is possible only in a Server Component.
There are also components that don’t use any server or client-only features and can be agnostic to where they render. In our earlier example, FancyText is one such component.
export default function FancyText({title, text}) {
 return title
   ? <h1 className='fancy title'>{text}</h1>
   : <h3 className='fancy cursive'>{text}</h3>
}
In this case, we don’t add the 'use client' directive, resulting in FancyText’s output (rather than its source code) to be sent to the browser when referenced from a Server Component. As demonstrated in the earlier Inspirations app example, FancyText is used as both a Server or Client Component, depending on where it is imported and used.
But if FancyText’s HTML output was large relative to its source code (including dependencies), it might be more efficient to force it to always be a Client Component. Components that return a long SVG path string are one case where it may be more efficient to force a component to be a Client Component.
Using client APIs 
Your React app may use client-specific APIs, such as the browser’s APIs for web storage, audio and video manipulation, and device hardware, among others.
In this example, the component uses DOM APIs to manipulate a canvas element. Since those APIs are only available in the browser, it must be marked as a Client Component.
'use client';

import {useRef, useEffect} from 'react';

export default function Circle() {
 const ref = useRef(null);
 useLayoutEffect(() => {
   const canvas = ref.current;
   const context = canvas.getContext('2d');
   context.reset();
   context.beginPath();
   context.arc(100, 75, 50, 0, 2 * Math.PI);
   context.stroke();
 });
 return <canvas ref={ref} />;
}
Using third-party libraries 
Often in a React app, you’ll leverage third-party libraries to handle common UI patterns or logic.
These libraries may rely on component Hooks or client APIs. Third-party components that use any of the following React APIs must run on the client:
createContext
react and react-dom Hooks, excluding use and useId
forwardRef
memo
startTransition
If they use client APIs, ex. DOM insertion or native platform views
If these libraries have been updated to be compatible with React Server Components, then they will already include 'use client' markers of their own, allowing you to use them directly from your Server Components. If a library hasn’t been updated, or if a component needs props like event handlers that can only be specified on the client, you may need to add your own Client Component file in between the third-party Client Component and your Server Component where you’d like to use it.


'use server'
React Server Components
'use server' is for use with using React Server Components.
'use server' marks server-side functions that can be called from client-side code.
Reference
'use server'
Security considerations
Serializable arguments and return values
Usage
Server Functions in forms
Calling a Server Function outside of <form>

Reference 
'use server' 
Add 'use server' at the top of an async function body to mark the function as callable by the client. We call these functions Server Functions.
async function addToCart(data) {
 'use server';
 // ...
}
When calling a Server Function on the client, it will make a network request to the server that includes a serialized copy of any arguments passed. If the Server Function returns a value, that value will be serialized and returned to the client.
Instead of individually marking functions with 'use server', you can add the directive to the top of a file to mark all exports within that file as Server Functions that can be used anywhere, including imported in client code.
Caveats 
'use server' must be at the very beginning of their function or module; above any other code including imports (comments above directives are OK). They must be written with single or double quotes, not backticks.
'use server' can only be used in server-side files. The resulting Server Functions can be passed to Client Components through props. See supported types for serialization.
To import a Server Functions from client code, the directive must be used on a module level.
Because the underlying network calls are always asynchronous, 'use server' can only be used on async functions.
Always treat arguments to Server Functions as untrusted input and authorize any mutations. See security considerations.
Server Functions should be called in a Transition. Server Functions passed to <form action> or formAction will automatically be called in a transition.
Server Functions are designed for mutations that update server-side state; they are not recommended for data fetching. Accordingly, frameworks implementing Server Functions typically process one action at a time and do not have a way to cache the return value.
Security considerations 
Arguments to Server Functions are fully client-controlled. For security, always treat them as untrusted input, and make sure to validate and escape arguments as appropriate.
In any Server Function, make sure to validate that the logged-in user is allowed to perform that action.
Under Construction
To prevent sending sensitive data from a Server Function, there are experimental taint APIs to prevent unique values and objects from being passed to client code.
See experimental_taintUniqueValue and experimental_taintObjectReference.
Serializable arguments and return values 
Since client code calls the Server Function over the network, any arguments passed will need to be serializable.
Here are supported types for Server Function arguments:
Primitives
string
number
bigint
boolean
undefined
null
symbol, only symbols registered in the global Symbol registry via Symbol.for
Iterables containing serializable values
String
Array
Map
Set
TypedArray and ArrayBuffer
Date
FormData instances
Plain objects: those created with object initializers, with serializable properties
Functions that are Server Functions
Promises
Notably, these are not supported:
React elements, or JSX
Functions, including component functions or any other function that is not a Server Function
Classes
Objects that are instances of any class (other than the built-ins mentioned) or objects with a null prototype
Symbols not registered globally, ex. Symbol('my new symbol')
Events from event handlers
Supported serializable return values are the same as serializable props for a boundary Client Component.
Usage 
Server Functions in forms 
The most common use case of Server Functions will be calling functions that mutate data. On the browser, the HTML form element is the traditional approach for a user to submit a mutation. With React Server Components, React introduces first-class support for Server Functions as Actions in forms.
Here is a form that allows a user to request a username.
// App.js


async function requestUsername(formData) {
 'use server';
 const username = formData.get('username');
 // ...
}


export default function App() {
 return (
   <form action={requestUsername}>
     <input type="text" name="username" />
     <button type="submit">Request</button>
   </form>
 );
}
In this example requestUsername is a Server Function passed to a <form>. When a user submits this form, there is a network request to the server function requestUsername. When calling a Server Function in a form, React will supply the form’s FormData as the first argument to the Server Function.
By passing a Server Function to the form action, React can progressively enhance the form. This means that forms can be submitted before the JavaScript bundle is loaded.
Handling return values in forms 
In the username request form, there might be the chance that a username is not available. requestUsername should tell us if it fails or not.
To update the UI based on the result of a Server Function while supporting progressive enhancement, use useActionState.
// requestUsername.js
'use server';


export default async function requestUsername(formData) {
 const username = formData.get('username');
 if (canRequest(username)) {
   // ...
   return 'successful';
 }
 return 'failed';
}
// UsernameForm.js
'use client';


import { useActionState } from 'react';
import requestUsername from './requestUsername';


function UsernameForm() {
 const [state, action] = useActionState(requestUsername, null, 'n/a');


 return (
   <>
     <form action={action}>
       <input type="text" name="username" />
       <button type="submit">Request</button>
     </form>
     <p>Last submission request returned: {state}</p>
   </>
 );
}
Note that like most Hooks, useActionState can only be called in client code.
Calling a Server Function outside of <form> 
Server Functions are exposed server endpoints and can be called anywhere in client code.
When using a Server Function outside a form, call the Server Function in a Transition, which allows you to display a loading indicator, show optimistic state updates, and handle unexpected errors. Forms will automatically wrap Server Functions in transitions.
import incrementLike from './actions';
import { useState, useTransition } from 'react';


function LikeButton() {
 const [isPending, startTransition] = useTransition();
 const [likeCount, setLikeCount] = useState(0);


 const onClick = () => {
   startTransition(async () => {
     const currentCount = await incrementLike();
     setLikeCount(currentCount);
   });
 };


 return (
   <>
     <p>Total Likes: {likeCount}</p>
     <button onClick={onClick} disabled={isPending}>Like</button>;
   </>
 );
}
// actions.js
'use server';


let likeCount = 0;
export default async function incrementLike() {
 likeCount++;
 return likeCount;
}
To read a Server Function return value, you’ll need to await the promise returned.
Legacy React APIs
These APIs are exported from the react package, but they are not recommended for use in newly written code. See the linked individual API pages for the suggested alternatives.

Legacy APIs 
Children lets you manipulate and transform the JSX received as the children prop. See alternatives.
cloneElement lets you create a React element using another element as a starting point. See alternatives.
Component lets you define a React component as a JavaScript class. See alternatives.
createElement lets you create a React element. Typically, you’ll use JSX instead.
createRef creates a ref object which can contain arbitrary value. See alternatives.
forwardRef lets your component expose a DOM node to parent component with a ref.
isValidElement checks whether a value is a React element. Typically used with cloneElement.
PureComponent is similar to Component, but it skip re-renders with same props. See alternatives.

Removed APIs 
These APIs were removed in React 19:
createFactory: use JSX instead.
Class Components: static contextTypes: use static contextType instead.
Class Components: static childContextTypes: use static contextType instead.
Class Components: static getChildContext: use Context instead.
Class Components: static propTypes: use a type system like TypeScript instead.
Class Components: this.refs: use createRef instead.
Children
Pitfall
Using Children is uncommon and can lead to fragile code. See common alternatives.
Children lets you manipulate and transform the JSX you received as the children prop.
const mappedChildren = Children.map(children, child =>
 <div className="Row">
   {child}
 </div>
);
Reference
Children.count(children)
Children.forEach(children, fn, thisArg?)
Children.map(children, fn, thisArg?)
Children.only(children)
Children.toArray(children)
Usage
Transforming children
Running some code for each child
Counting children
Converting children to an array
Alternatives
Exposing multiple components
Accepting an array of objects as a prop
Calling a render prop to customize rendering
Troubleshooting
I pass a custom component, but the Children methods don’t show its render result

Reference 
Children.count(children) 
Call Children.count(children) to count the number of children in the children data structure.
import { Children } from 'react';


function RowList({ children }) {
 return (
   <>
     <h1>Total rows: {Children.count(children)}</h1>
     ...
   </>
 );
}
See more examples below.
Parameters 
children: The value of the children prop received by your component.
Returns 
The number of nodes inside these children.
Caveats 
Empty nodes (null, undefined, and Booleans), strings, numbers, and React elements count as individual nodes. Arrays don’t count as individual nodes, but their children do. The traversal does not go deeper than React elements: they don’t get rendered, and their children aren’t traversed. Fragments don’t get traversed.

Children.forEach(children, fn, thisArg?) 
Call Children.forEach(children, fn, thisArg?) to run some code for each child in the children data structure.
import { Children } from 'react';


function SeparatorList({ children }) {
 const result = [];
 Children.forEach(children, (child, index) => {
   result.push(child);
   result.push(<hr key={index} />);
 });
 // ...
See more examples below.
Parameters 
children: The value of the children prop received by your component.
fn: The function you want to run for each child, similar to the array forEach method callback. It will be called with the child as the first argument and its index as the second argument. The index starts at 0 and increments on each call.
optional thisArg: The this value with which the fn function should be called. If omitted, it’s undefined.
Returns 
Children.forEach returns undefined.
Caveats 
Empty nodes (null, undefined, and Booleans), strings, numbers, and React elements count as individual nodes. Arrays don’t count as individual nodes, but their children do. The traversal does not go deeper than React elements: they don’t get rendered, and their children aren’t traversed. Fragments don’t get traversed.

Children.map(children, fn, thisArg?) 
Call Children.map(children, fn, thisArg?) to map or transform each child in the children data structure.
import { Children } from 'react';


function RowList({ children }) {
 return (
   <div className="RowList">
     {Children.map(children, child =>
       <div className="Row">
         {child}
       </div>
     )}
   </div>
 );
}
See more examples below.
Parameters 
children: The value of the children prop received by your component.
fn: The mapping function, similar to the array map method callback. It will be called with the child as the first argument and its index as the second argument. The index starts at 0 and increments on each call. You need to return a React node from this function. This may be an empty node (null, undefined, or a Boolean), a string, a number, a React element, or an array of other React nodes.
optional thisArg: The this value with which the fn function should be called. If omitted, it’s undefined.
Returns 
If children is null or undefined, returns the same value.
Otherwise, returns a flat array consisting of the nodes you’ve returned from the fn function. The returned array will contain all nodes you returned except for null and undefined.
Caveats 
Empty nodes (null, undefined, and Booleans), strings, numbers, and React elements count as individual nodes. Arrays don’t count as individual nodes, but their children do. The traversal does not go deeper than React elements: they don’t get rendered, and their children aren’t traversed. Fragments don’t get traversed.
If you return an element or an array of elements with keys from fn, the returned elements’ keys will be automatically combined with the key of the corresponding original item from children. When you return multiple elements from fn in an array, their keys only need to be unique locally amongst each other.

Children.only(children) 
Call Children.only(children) to assert that children represent a single React element.
function Box({ children }) {
 const element = Children.only(children);
 // ...
Parameters 
children: The value of the children prop received by your component.
Returns 
If children is a valid element, returns that element.
Otherwise, throws an error.
Caveats 
This method always throws if you pass an array (such as the return value of Children.map) as children. In other words, it enforces that children is a single React element, not that it’s an array with a single element.

Children.toArray(children) 
Call Children.toArray(children) to create an array out of the children data structure.
import { Children } from 'react';


export default function ReversedList({ children }) {
 const result = Children.toArray(children);
 result.reverse();
 // ...
Parameters 
children: The value of the children prop received by your component.
Returns 
Returns a flat array of elements in children.
Caveats 
Empty nodes (null, undefined, and Booleans) will be omitted in the returned array. The returned elements’ keys will be calculated from the original elements’ keys and their level of nesting and position. This ensures that flattening the array does not introduce changes in behavior.

Usage 
Transforming children 
To transform the children JSX that your component receives as the children prop, call Children.map:
import { Children } from 'react';


function RowList({ children }) {
 return (
   <div className="RowList">
     {Children.map(children, child =>
       <div className="Row">
         {child}
       </div>
     )}
   </div>
 );
}
In the example above, the RowList wraps every child it receives into a <div className="Row"> container. For example, let’s say the parent component passes three <p> tags as the children prop to RowList:
<RowList>
 <p>This is the first item.</p>
 <p>This is the second item.</p>
 <p>This is the third item.</p>
</RowList>
Then, with the RowList implementation above, the final rendered result will look like this:
<div className="RowList">
 <div className="Row">
   <p>This is the first item.</p>
 </div>
 <div className="Row">
   <p>This is the second item.</p>
 </div>
 <div className="Row">
   <p>This is the third item.</p>
 </div>
</div>
Children.map is similar to to transforming arrays with map(). The difference is that the children data structure is considered opaque. This means that even if it’s sometimes an array, you should not assume it’s an array or any other particular data type. This is why you should use Children.map if you need to transform it.
App.jsRowList.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
import { Children } from 'react';


export default function RowList({ children }) {
 return (
   <div className="RowList">
     {Children.map(children, child =>
       <div className="Row">
         {child}
       </div>
     )}
   </div>
 );
}


Deep Dive
Why is the children prop not always an array? 
Show Details
Pitfall
The children data structure does not include rendered output of the components you pass as JSX. In the example below, the children received by the RowList only contains two items rather than three:
<p>This is the first item.</p>
<MoreRows />
This is why only two row wrappers are generated in this example:
App.jsRowList.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
import RowList from './RowList.js';


export default function App() {
 return (
   <RowList>
     <p>This is the first item.</p>
     <MoreRows />
   </RowList>
 );
}


function MoreRows() {
 return (
   <>
     <p>This is the second item.</p>
     <p>This is the third item.</p>
   </>
 );
}


Show more
There is no way to get the rendered output of an inner component like <MoreRows /> when manipulating children. This is why it’s usually better to use one of the alternative solutions.

Running some code for each child 
Call Children.forEach to iterate over each child in the children data structure. It does not return any value and is similar to the array forEach method. You can use it to run custom logic like constructing your own array.
App.jsSeparatorList.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
import { Children } from 'react';


export default function SeparatorList({ children }) {
 const result = [];
 Children.forEach(children, (child, index) => {
   result.push(child);
   result.push(<hr key={index} />);
 });
 result.pop(); // Remove the last separator
 return result;
}


Pitfall
As mentioned earlier, there is no way to get the rendered output of an inner component when manipulating children. This is why it’s usually better to use one of the alternative solutions.

Counting children 
Call Children.count(children) to calculate the number of children.
App.jsRowList.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
import { Children } from 'react';


export default function RowList({ children }) {
 return (
   <div className="RowList">
     <h1 className="RowListHeader">
       Total rows: {Children.count(children)}
     </h1>
     {Children.map(children, child =>
       <div className="Row">
         {child}
       </div>
     )}
   </div>
 );
}


Show more
Pitfall
As mentioned earlier, there is no way to get the rendered output of an inner component when manipulating children. This is why it’s usually better to use one of the alternative solutions.

Converting children to an array 
Call Children.toArray(children) to turn the children data structure into a regular JavaScript array. This lets you manipulate the array with built-in array methods like filter, sort, or reverse.
App.jsReversedList.js
Reset
Fork
1
2
3
4
5
6
7
8
import { Children } from 'react';


export default function ReversedList({ children }) {
 const result = Children.toArray(children);
 result.reverse();
 return result;
}


Pitfall
As mentioned earlier, there is no way to get the rendered output of an inner component when manipulating children. This is why it’s usually better to use one of the alternative solutions.

Alternatives 
Note
This section describes alternatives to the Children API (with capital C) that’s imported like this:
import { Children } from 'react';
Don’t confuse it with using the children prop (lowercase c), which is good and encouraged.
Exposing multiple components 
Manipulating children with the Children methods often leads to fragile code. When you pass children to a component in JSX, you don’t usually expect the component to manipulate or transform the individual children.
When you can, try to avoid using the Children methods. For example, if you want every child of RowList to be wrapped in <div className="Row">, export a Row component, and manually wrap every row into it like this:
App.jsRowList.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
import { RowList, Row } from './RowList.js';


export default function App() {
 return (
   <RowList>
     <Row>
       <p>This is the first item.</p>
     </Row>
     <Row>
       <p>This is the second item.</p>
     </Row>
     <Row>
       <p>This is the third item.</p>
     </Row>
   </RowList>
 );
}


Show more
Unlike using Children.map, this approach does not wrap every child automatically. However, this approach has a significant benefit compared to the earlier example with Children.map because it works even if you keep extracting more components. For example, it still works if you extract your own MoreRows component:
App.jsRowList.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
import { RowList, Row } from './RowList.js';


export default function App() {
 return (
   <RowList>
     <Row>
       <p>This is the first item.</p>
     </Row>
     <MoreRows />
   </RowList>
 );
}


function MoreRows() {
 return (
   <>
     <Row>
       <p>This is the second item.</p>
     </Row>
     <Row>
       <p>This is the third item.</p>
     </Row>
   </>
 );
}


Show more
This wouldn’t work with Children.map because it would “see” <MoreRows /> as a single child (and a single row).

Accepting an array of objects as a prop 
You can also explicitly pass an array as a prop. For example, this RowList accepts a rows array as a prop:
App.jsRowList.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
import { RowList, Row } from './RowList.js';


export default function App() {
 return (
   <RowList rows={[
     { id: 'first', content: <p>This is the first item.</p> },
     { id: 'second', content: <p>This is the second item.</p> },
     { id: 'third', content: <p>This is the third item.</p> }
   ]} />
 );
}


Since rows is a regular JavaScript array, the RowList component can use built-in array methods like map on it.
This pattern is especially useful when you want to be able to pass more information as structured data together with children. In the below example, the TabSwitcher component receives an array of objects as the tabs prop:
App.jsTabSwitcher.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
import TabSwitcher from './TabSwitcher.js';


export default function App() {
 return (
   <TabSwitcher tabs={[
     {
       id: 'first',
       header: 'First',
       content: <p>This is the first item.</p>
     },
     {
       id: 'second',
       header: 'Second',
       content: <p>This is the second item.</p>
     },
     {
       id: 'third',
       header: 'Third',
       content: <p>This is the third item.</p>
     }
   ]} />
 );
}


Show more
Unlike passing the children as JSX, this approach lets you associate some extra data like header with each item. Because you are working with the tabs directly, and it is an array, you do not need the Children methods.

Calling a render prop to customize rendering 
Instead of producing JSX for every single item, you can also pass a function that returns JSX, and call that function when necessary. In this example, the App component passes a renderContent function to the TabSwitcher component. The TabSwitcher component calls renderContent only for the selected tab:
App.jsTabSwitcher.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
import TabSwitcher from './TabSwitcher.js';


export default function App() {
 return (
   <TabSwitcher
     tabIds={['first', 'second', 'third']}
     getHeader={tabId => {
       return tabId[0].toUpperCase() + tabId.slice(1);
     }}
     renderContent={tabId => {
       return <p>This is the {tabId} item.</p>;
     }}
   />
 );
}


A prop like renderContent is called a render prop because it is a prop that specifies how to render a piece of the user interface. However, there is nothing special about it: it is a regular prop which happens to be a function.
Render props are functions, so you can pass information to them. For example, this RowList component passes the id and the index of each row to the renderRow render prop, which uses index to highlight even rows:
App.jsRowList.js
Reset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
import { RowList, Row } from './RowList.js';


export default function App() {
 return (
   <RowList
     rowIds={['first', 'second', 'third']}
     renderRow={(id, index) => {
       return (
         <Row isHighlighted={index % 2 === 0}>
           <p>This is the {id} item.</p>
         </Row>
       );
     }}
   />
 );
}


Show more
This is another example of how parent and child components can cooperate without manipulating the children.

Troubleshooting 
I pass a custom component, but the Children methods don’t show its render result 
Suppose you pass two children to RowList like this:
<RowList>
 <p>First item</p>
 <MoreRows />
</RowList>
If you do Children.count(children) inside RowList, you will get 2. Even if MoreRows renders 10 different items, or if it returns null, Children.count(children) will still be 2. From the RowList’s perspective, it only “sees” the JSX it has received. It does not “see” the internals of the MoreRows component.
The limitation makes it hard to extract a component. This is why alternatives are preferred to using Children.
PreviousLegacy React APIs

PureComponent
Pitfall
We recommend defining components as functions instead of classes. See how to migrate.
PureComponent is similar to Component but it skips re-renders for same props and state. Class components are still supported by React, but we don’t recommend using them in new code.
class Greeting extends PureComponent {
 render() {
   return <h1>Hello, {this.props.name}!</h1>;
 }
}
Reference
PureComponent
Usage
Skipping unnecessary re-renders for class components
Alternatives
Migrating from a PureComponent class component to a function

Reference 
PureComponent 
To skip re-rendering a class component for same props and state, extend PureComponent instead of Component:
import { PureComponent } from 'react';


class Greeting extends PureComponent {
 render() {
   return <h1>Hello, {this.props.name}!</h1>;
 }
}
PureComponent is a subclass of Component and supports all the Component APIs. Extending PureComponent is equivalent to defining a custom shouldComponentUpdate method that shallowly compares props and state.
See more examples below.

Usage 
Skipping unnecessary re-renders for class components 
React normally re-renders a component whenever its parent re-renders. As an optimization, you can create a component that React will not re-render when its parent re-renders so long as its new props and state are the same as the old props and state. Class components can opt into this behavior by extending PureComponent:
class Greeting extends PureComponent {
 render() {
   return <h1>Hello, {this.props.name}!</h1>;
 }
}
A React component should always have pure rendering logic. This means that it must return the same output if its props, state, and context haven’t changed. By using PureComponent, you are telling React that your component complies with this requirement, so React doesn’t need to re-render as long as its props and state haven’t changed. However, your component will still re-render if a context that it’s using changes.
In this example, notice that the Greeting component re-renders whenever name is changed (because that’s one of its props), but not when address is changed (because it’s not passed to Greeting as a prop):
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
import { PureComponent, useState } from 'react';


class Greeting extends PureComponent {
 render() {
   console.log("Greeting was rendered at", new Date().toLocaleTimeString());
   return <h3>Hello{this.props.name && ', '}{this.props.name}!</h3>;
 }
}


export default function MyApp() {
 const [name, setName] = useState('');
 const [address, setAddress] = useState('');
 return (
   <>
     <label>
       Name{': '}
       <input value={name} onChange={e => setName(e.target.value)} />
     </label>
     <label>
       Address{': '}
       <input value={address} onChange={e => setAddress(e.target.value)} />
     </label>
     <Greeting name={name} />
   </>
 );
}


Console (2)
Greeting was rendered at 10:06:08 AM
Greeting was rendered at 10:06:08 AM
Show more
Pitfall
We recommend defining components as functions instead of classes. See how to migrate.

Alternatives 
Migrating from a PureComponent class component to a function 
We recommend using function components instead of class components in new code. If you have some existing class components using PureComponent, here is how you can convert them. This is the original code:
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
import { PureComponent, useState } from 'react';


class Greeting extends PureComponent {
 render() {
   console.log("Greeting was rendered at", new Date().toLocaleTimeString());
   return <h3>Hello{this.props.name && ', '}{this.props.name}!</h3>;
 }
}


export default function MyApp() {
 const [name, setName] = useState('');
 const [address, setAddress] = useState('');
 return (
   <>
     <label>
       Name{': '}
       <input value={name} onChange={e => setName(e.target.value)} />
     </label>
     <label>
       Address{': '}
       <input value={address} onChange={e => setAddress(e.target.value)} />
     </label>
     <Greeting name={name} />
   </>
 );
}


Console (2)
Greeting was rendered at 10:06:10 AM
Greeting was rendered at 10:06:10 AM
Show more
When you convert this component from a class to a function, wrap it in memo:
App.js
DownloadReset
Fork
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
import { memo, useState } from 'react';


const Greeting = memo(function Greeting({ name }) {
 console.log("Greeting was rendered at", new Date().toLocaleTimeString());
 return <h3>Hello{name && ', '}{name}!</h3>;
});


export default function MyApp() {
 const [name, setName] = useState('');
 const [address, setAddress] = useState('');
 return (
   <>
     <label>
       Name{': '}
       <input value={name} onChange={e => setName(e.target.value)} />
     </label>
     <label>
       Address{': '}
       <input value={address} onChange={e => setAddress(e.target.value)} />
     </label>
     <Greeting name={name} />
   </>
 );
}


Console (2)
Greeting was rendered at 10:06:10 AM
Greeting was rendered at 10:06:10 AM
Show more
Note
Unlike PureComponent, memo does not compare the new and the old state. In function components, calling the set function with the same state already prevents re-renders by default, even without memo.



