#!/bin/bash
# Pre-commit hook to detect secrets and sensitive information
# Based on AWS enterprise security recommendations

set -e

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

echo -e "${GREEN}üîê Running security pre-commit checks...${NC}"

# Function to check for secrets in staged files
check_secrets() {
    local found_secrets=false
    
    # Secret patterns to detect
    declare -a secret_patterns=(
        # AWS Secrets
        "aws_access_key_id.*=.*AKIA[0-9A-Z]{16}"
        "aws_secret_access_key.*=.*[A-Za-z0-9/+=]{40}"
        "aws_session_token.*=.*[A-Za-z0-9/+=]{16,}"
        
        # API Keys
        "sk_live_[a-zA-Z0-9]{24,}"         # Stripe live secret key
        "pk_live_[a-zA-Z0-9]{24,}"         # Stripe live publishable key
        "rk_live_[a-zA-Z0-9]{24,}"         # Stripe restricted key
        "whsec_[a-zA-Z0-9]{32,}"           # Stripe webhook secret
        
        # Database URLs with credentials
        "postgresql://[^:]+:[^@]+@[^/]+"
        "mysql://[^:]+:[^@]+@[^/]+"
        "mongodb://[^:]+:[^@]+@[^/]+"
        
        # OAuth secrets
        "['\"]client_secret['\"]:\s*['\"][^'\"]{20,}['\"]"
        
        # JWT tokens
        "eyJ[A-Za-z0-9_/+\-]+"
        
        # Generic API keys
        "['\"]api_key['\"]:\s*['\"][A-Za-z0-9]{20,}['\"]"
        "['\"]access_token['\"]:\s*['\"][A-Za-z0-9]{20,}['\"]"
        
        # Twilio
        "AC[a-fA-F0-9]{32}"                # Twilio Account SID
        "SK[a-fA-F0-9]{32}"                # Twilio API Key SID
        
        # LaunchDarkly
        "sdk-[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}"
        "mob-[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}"
        
        # Duffel
        "duffel_test_[a-zA-Z0-9_]+"
        "duffel_live_[a-zA-Z0-9_]+"
        
        # Common password patterns
        "['\"]password['\"]:\s*['\"].{8,}['\"]"
        "['\"]secret['\"]:\s*['\"].{8,}['\"]"
    )
    
    # Check staged files
    for file in $(git diff --cached --name-only); do
        if [[ -f "$file" ]]; then
            echo "üîç Scanning: $file"
            
            # Skip binary files
            if file "$file" | grep -q "binary"; then
                continue
            fi
            
            # Check each pattern
            for pattern in "${secret_patterns[@]}"; do
                if git show ":$file" | grep -iE "$pattern" >/dev/null 2>&1; then
                    echo -e "${RED}‚ùå POTENTIAL SECRET DETECTED in $file${NC}"
                    echo -e "${YELLOW}Pattern: $pattern${NC}"
                    echo -e "${YELLOW}Line(s):${NC}"
                    git show ":$file" | grep -iE "$pattern" | head -3
                    echo
                    found_secrets=true
                fi
            done
        fi
    done
    
    if $found_secrets; then
        return 1
    else
        return 0
    fi
}

# Function to check for hardcoded credentials in specific file types
check_hardcoded_credentials() {
    local found_hardcoded=false
    
    # Check TypeScript/JavaScript files for hardcoded values
    for file in $(git diff --cached --name-only | grep -E '\.(ts|js|tsx|jsx)$'); do
        if [[ -f "$file" ]]; then
            # Look for suspicious hardcoded values
            if git show ":$file" | grep -E "(const|let|var).*=.*['\"][A-Za-z0-9]{20,}['\"]" | grep -vE "(test|mock|example|placeholder)" >/dev/null 2>&1; then
                echo -e "${YELLOW}‚ö†Ô∏è  Potential hardcoded credential in $file${NC}"
                git show ":$file" | grep -E "(const|let|var).*=.*['\"][A-Za-z0-9]{20,}['\"]" | grep -vE "(test|mock|example|placeholder)" | head -3
                found_hardcoded=true
            fi
        fi
    done
    
    if $found_hardcoded; then
        return 1
    else
        return 0
    fi
}

# Function to check for .env files being committed
check_env_files() {
    local found_env=false
    
    for file in $(git diff --cached --name-only); do
        if [[ "$file" =~ \.env$ ]] || [[ "$file" =~ \.env\.local$ ]] || [[ "$file" =~ \.env\.production$ ]]; then
            echo -e "${RED}‚ùå Environment file detected: $file${NC}"
            echo -e "${YELLOW}Environment files should not be committed to version control${NC}"
            found_env=true
        fi
    done
    
    if $found_env; then
        return 1
    else
        return 0
    fi
}

# Function to check for AWS credential files
check_aws_files() {
    local found_aws=false
    
    for file in $(git diff --cached --name-only); do
        if [[ "$file" =~ credentials$ ]] || [[ "$file" =~ config$ ]] && [[ "$file" =~ \.aws/ ]]; then
            echo -e "${RED}‚ùå AWS credential file detected: $file${NC}"
            echo -e "${YELLOW}AWS credential files should not be committed${NC}"
            found_aws=true
        fi
    done
    
    if $found_aws; then
        return 1
    else
        return 0
    fi
}

# Main execution
main() {
    local exit_code=0
    
    echo "Running secret detection..."
    if ! check_secrets; then
        exit_code=1
    fi
    
    echo "Checking for hardcoded credentials..."
    if ! check_hardcoded_credentials; then
        exit_code=1
    fi
    
    echo "Checking for environment files..."
    if ! check_env_files; then
        exit_code=1
    fi
    
    echo "Checking for AWS credential files..."
    if ! check_aws_files; then
        exit_code=1
    fi
    
    if [[ $exit_code -eq 0 ]]; then
        echo -e "${GREEN}‚úÖ Security check passed! No secrets detected.${NC}"
    else
        echo -e "${RED}üö® SECURITY CHECK FAILED!${NC}"
        echo -e "${YELLOW}Please remove secrets before committing. Consider using:${NC}"
        echo -e "${YELLOW}1. AWS Secrets Manager for production secrets${NC}"
        echo -e "${YELLOW}2. Environment variables for local development${NC}"
        echo -e "${YELLOW}3. .env.example for documentation${NC}"
        echo
        echo -e "${YELLOW}To bypass this check (NOT RECOMMENDED):${NC}"
        echo -e "${YELLOW}git commit --no-verify${NC}"
    fi
    
    return $exit_code
}

# Run the main function
main "$@"
