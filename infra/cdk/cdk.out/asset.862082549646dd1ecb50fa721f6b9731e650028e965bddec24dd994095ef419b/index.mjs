import{DynamoDBClient as u,PutItemCommand as c,UpdateItemCommand as l,QueryCommand as S}from"@aws-sdk/client-dynamodb";var p=class{ddb;paymentsTable;sagaTable;constructor(t,e,r){this.ddb=new u({region:t}),this.paymentsTable=process.env.PAYMENTS_IDEMPOTENCY_TABLE||e||"payments-idempotency",this.sagaTable=process.env.SAGA_TRANSACTIONS_TABLE||r||"saga-transactions"}async recordPaymentAttempt(t,e,r,s=24*60*60){let o=Math.floor(Date.now()/1e3)+s;await this.ddb.send(new c({TableName:this.paymentsTable,Item:{idempotencyKey:{S:t},correlationId:{S:e},amount:{N:r.toString()},status:{S:"pending"},createdAt:{S:new Date().toISOString()},ttl:{N:o.toString()}},ConditionExpression:"attribute_not_exists(idempotencyKey)"}))}async markPaymentCompleted(t,e){await this.ddb.send(new l({TableName:this.paymentsTable,Key:{idempotencyKey:{S:t}},UpdateExpression:"SET #s = :s, paymentIntentId = :pid, completedAt = :ts",ExpressionAttributeNames:{"#s":"status"},ExpressionAttributeValues:{":s":{S:"completed"},":pid":{S:e},":ts":{S:new Date().toISOString()}}}))}async recordRefundAttempt(t,e,r,s=24*60*60){let o=Math.floor(Date.now()/1e3)+s;await this.ddb.send(new c({TableName:this.paymentsTable,Item:{idempotencyKey:{S:t},correlationId:{S:e},amount:{N:r.toString()},status:{S:"refund_pending"},createdAt:{S:new Date().toISOString()},ttl:{N:o.toString()}},ConditionExpression:"attribute_not_exists(idempotencyKey)"}))}async markRefundCompleted(t,e){await this.ddb.send(new l({TableName:this.paymentsTable,Key:{idempotencyKey:{S:t}},UpdateExpression:"SET #s = :s, refundId = :rid, completedAt = :ts",ExpressionAttributeNames:{"#s":"status"},ExpressionAttributeValues:{":s":{S:"refund_completed"},":rid":{S:e},":ts":{S:new Date().toISOString()}}}))}async recordSagaStep(t,e,r,s,o,a=7){let d=Math.floor(Date.now()/1e3)+a*24*60*60;await this.ddb.send(new c({TableName:this.sagaTable,Item:{transactionId:{S:t},stepId:{S:e},correlationId:{S:r},action:{S:s},status:{S:o},timestamp:{S:new Date().toISOString()},ttl:{N:d.toString()}}}))}async recordSagaStepOnce(t,e,r,s,o,a=7){let d=Math.floor(Date.now()/1e3)+a*24*60*60;await this.ddb.send(new c({TableName:this.sagaTable,Item:{transactionId:{S:t},stepId:{S:e},correlationId:{S:r},action:{S:s},status:{S:o},timestamp:{S:new Date().toISOString()},ttl:{N:d.toString()}},ConditionExpression:"attribute_not_exists(transactionId) AND attribute_not_exists(stepId)"}))}async getSagaStepsByCorrelation(t){return(await this.ddb.send(new S({TableName:this.sagaTable,IndexName:"CorrelationIdIndex",KeyConditionExpression:"correlationId = :c",ExpressionAttributeValues:{":c":{S:t}}}))).Items||[]}};function g(n){if(n==null)return n;if(typeof n=="string")return n.replace(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/gi,"[REDACTED]");if(Array.isArray(n))return n.map(g);if(typeof n=="object"){let t=n,e={};for(let r of Object.keys(t))/password|secret|token|ssn|dob|email/i.test(r)?e[r]="[REDACTED]":e[r]=g(t[r]);return e}return n}function m(n,t,e){let r={level:n,msg:t,timestamp:new Date().toISOString(),pii:!1,...e},s=r.pii?{...r,msg:"[REDACTED]",pii:!1}:{...r},o=g(s),a=JSON.stringify(o);switch(n){case"debug":console.debug(a);break;case"info":console.info(a);break;case"warn":console.warn(a);break;case"error":console.error(a);break}}var i={debug:(n,t)=>m("debug",n,t),info:(n,t)=>m("info",n,t),warn:(n,t)=>m("warn",n,t),error:(n,t)=>m("error",n,t)};async function T(n){let{correlationId:t,idempotencyKey:e,amount:r}=n||{};if(!t||!e||!Number.isFinite(r))throw i.error("refund_validation_error",{correlationId:t,step:"refund",state:"error",errorType:"ValidationError"}),new Error("ValidationError");let s=new p;i.info("refund_attempt",{correlationId:t,step:"refund",state:"attempt",idempotencyKey:e,amount:r});try{await s.recordRefundAttempt(e,t,r)}catch(a){if(!String(a).includes("ConditionalCheckFailed"))throw i.warn("refund_attempt_record_failed",{correlationId:t,step:"refund",state:"record",errorType:"TransientProviderError"}),new Error("TransientProviderError")}let o=`re_${Math.random().toString(36).slice(2,12)}`;try{await s.markRefundCompleted(e,o)}catch{throw i.warn("refund_mark_complete_failed",{correlationId:t,step:"refund",state:"record",errorType:"TransientProviderError"}),new Error("TransientProviderError")}return i.info("refund_success",{correlationId:t,step:"refund",state:"success",idempotencyKey:e}),{ok:!0,correlationId:t,idempotencyKey:e,refundId:o,amount:r}}export{T as handler};
