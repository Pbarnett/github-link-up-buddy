import{DynamoDBClient as p,PutItemCommand as o,UpdateItemCommand as c,QueryCommand as l}from"@aws-sdk/client-dynamodb";var d=class{ddb;paymentsTable;sagaTable;constructor(t,e,n){this.ddb=new p({region:t}),this.paymentsTable=process.env.PAYMENTS_IDEMPOTENCY_TABLE||e||"payments-idempotency",this.sagaTable=process.env.SAGA_TRANSACTIONS_TABLE||n||"saga-transactions"}async recordPaymentAttempt(t,e,n,a=24*60*60){let s=Math.floor(Date.now()/1e3)+a;await this.ddb.send(new o({TableName:this.paymentsTable,Item:{idempotencyKey:{S:t},correlationId:{S:e},amount:{N:n.toString()},status:{S:"pending"},createdAt:{S:new Date().toISOString()},ttl:{N:s.toString()}},ConditionExpression:"attribute_not_exists(idempotencyKey)"}))}async markPaymentCompleted(t,e){await this.ddb.send(new c({TableName:this.paymentsTable,Key:{idempotencyKey:{S:t}},UpdateExpression:"SET #s = :s, paymentIntentId = :pid, completedAt = :ts",ExpressionAttributeNames:{"#s":"status"},ExpressionAttributeValues:{":s":{S:"completed"},":pid":{S:e},":ts":{S:new Date().toISOString()}}}))}async recordRefundAttempt(t,e,n,a=24*60*60){let s=Math.floor(Date.now()/1e3)+a;await this.ddb.send(new o({TableName:this.paymentsTable,Item:{idempotencyKey:{S:t},correlationId:{S:e},amount:{N:n.toString()},status:{S:"refund_pending"},createdAt:{S:new Date().toISOString()},ttl:{N:s.toString()}},ConditionExpression:"attribute_not_exists(idempotencyKey)"}))}async markRefundCompleted(t,e){await this.ddb.send(new c({TableName:this.paymentsTable,Key:{idempotencyKey:{S:t}},UpdateExpression:"SET #s = :s, refundId = :rid, completedAt = :ts",ExpressionAttributeNames:{"#s":"status"},ExpressionAttributeValues:{":s":{S:"refund_completed"},":rid":{S:e},":ts":{S:new Date().toISOString()}}}))}async recordSagaStep(t,e,n,a,s,r=7){let i=Math.floor(Date.now()/1e3)+r*24*60*60;await this.ddb.send(new o({TableName:this.sagaTable,Item:{transactionId:{S:t},stepId:{S:e},correlationId:{S:n},action:{S:a},status:{S:s},timestamp:{S:new Date().toISOString()},ttl:{N:i.toString()}}}))}async recordSagaStepOnce(t,e,n,a,s,r=7){let i=Math.floor(Date.now()/1e3)+r*24*60*60;await this.ddb.send(new o({TableName:this.sagaTable,Item:{transactionId:{S:t},stepId:{S:e},correlationId:{S:n},action:{S:a},status:{S:s},timestamp:{S:new Date().toISOString()},ttl:{N:i.toString()}},ConditionExpression:"attribute_not_exists(transactionId) AND attribute_not_exists(stepId)"}))}async getSagaStepsByCorrelation(t){return(await this.ddb.send(new l({TableName:this.sagaTable,IndexName:"CorrelationIdIndex",KeyConditionExpression:"correlationId = :c",ExpressionAttributeValues:{":c":{S:t}}}))).Items||[]}};async function u(m){let{correlationId:t,idempotencyKey:e,amount:n}=m||{};if(!t||!e||!Number.isFinite(n))throw new Error("ValidationError");let a=new d;try{await a.recordRefundAttempt(e,t,n)}catch(r){if(!String(r).includes("ConditionalCheckFailed"))throw new Error("TransientProviderError")}let s=`re_${Math.random().toString(36).slice(2,12)}`;try{await a.markRefundCompleted(e,s)}catch{throw new Error("TransientProviderError")}return{ok:!0,correlationId:t,idempotencyKey:e,refundId:s,amount:n}}export{u as handler};
