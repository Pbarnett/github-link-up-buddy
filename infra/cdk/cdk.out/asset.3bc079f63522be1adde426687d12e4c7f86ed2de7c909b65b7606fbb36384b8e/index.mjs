import{DynamoDBClient as S,PutItemCommand as g}from"@aws-sdk/client-dynamodb";import{DynamoDBClient as m,PutItemCommand as o,UpdateItemCommand as l,QueryCommand as p}from"@aws-sdk/client-dynamodb";var i=class{ddb;paymentsTable;sagaTable;constructor(t,e,a){this.ddb=new m({region:t}),this.paymentsTable=process.env.PAYMENTS_IDEMPOTENCY_TABLE||e||"payments-idempotency",this.sagaTable=process.env.SAGA_TRANSACTIONS_TABLE||a||"saga-transactions"}async recordPaymentAttempt(t,e,a,n=24*60*60){let s=Math.floor(Date.now()/1e3)+n;await this.ddb.send(new o({TableName:this.paymentsTable,Item:{idempotencyKey:{S:t},correlationId:{S:e},amount:{N:a.toString()},status:{S:"pending"},createdAt:{S:new Date().toISOString()},ttl:{N:s.toString()}},ConditionExpression:"attribute_not_exists(idempotencyKey)"}))}async markPaymentCompleted(t,e){await this.ddb.send(new l({TableName:this.paymentsTable,Key:{idempotencyKey:{S:t}},UpdateExpression:"SET #s = :s, paymentIntentId = :pid, completedAt = :ts",ExpressionAttributeNames:{"#s":"status"},ExpressionAttributeValues:{":s":{S:"completed"},":pid":{S:e},":ts":{S:new Date().toISOString()}}}))}async recordRefundAttempt(t,e,a,n=24*60*60){let s=Math.floor(Date.now()/1e3)+n;await this.ddb.send(new o({TableName:this.paymentsTable,Item:{idempotencyKey:{S:t},correlationId:{S:e},amount:{N:a.toString()},status:{S:"refund_pending"},createdAt:{S:new Date().toISOString()},ttl:{N:s.toString()}},ConditionExpression:"attribute_not_exists(idempotencyKey)"}))}async markRefundCompleted(t,e){await this.ddb.send(new l({TableName:this.paymentsTable,Key:{idempotencyKey:{S:t}},UpdateExpression:"SET #s = :s, refundId = :rid, completedAt = :ts",ExpressionAttributeNames:{"#s":"status"},ExpressionAttributeValues:{":s":{S:"refund_completed"},":rid":{S:e},":ts":{S:new Date().toISOString()}}}))}async recordSagaStep(t,e,a,n,s,d=7){let c=Math.floor(Date.now()/1e3)+d*24*60*60;await this.ddb.send(new o({TableName:this.sagaTable,Item:{transactionId:{S:t},stepId:{S:e},correlationId:{S:a},action:{S:n},status:{S:s},timestamp:{S:new Date().toISOString()},ttl:{N:c.toString()}}}))}async recordSagaStepOnce(t,e,a,n,s,d=7){let c=Math.floor(Date.now()/1e3)+d*24*60*60;await this.ddb.send(new o({TableName:this.sagaTable,Item:{transactionId:{S:t},stepId:{S:e},correlationId:{S:a},action:{S:n},status:{S:s},timestamp:{S:new Date().toISOString()},ttl:{N:c.toString()}},ConditionExpression:"attribute_not_exists(transactionId) AND attribute_not_exists(stepId)"}))}async getSagaStepsByCorrelation(t){return(await this.ddb.send(new p({TableName:this.sagaTable,IndexName:"CorrelationIdIndex",KeyConditionExpression:"correlationId = :c",ExpressionAttributeValues:{":c":{S:t}}}))).Items||[]}};var y=new S({}),b=process.env.CALLBACK_TABLE||"pending-callbacks";async function A(r){let{correlationId:t,TaskToken:e}=r;console.log(JSON.stringify({correlationId:t,stage:"callback_initiate",status:"storing_token"}));let a=r.payload&&r.payload.simulate||process.env.CALLBACK_SIMULATE;try{await y.send(new g({TableName:b,Item:{correlationId:{S:t},taskToken:{S:e},createdAt:{S:new Date().toISOString()}}}))}catch(n){throw console.error("Failed to store task token:",n),new Error("TransientProviderError")}try{await new i().recordSagaStep(t,"callback_token_stored",t,"store_task_token","completed")}catch(n){console.warn("Failed to record saga step (callback_token_stored):",n)}if(a==="transient")throw console.warn("Simulating transient provider error after token storage"),new Error("TransientProviderError");return{ok:!0}}export{A as handler};
